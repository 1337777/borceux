<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>borceuxSolution.v</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #b22222;
      }
      .company-coq-comment-h2 {
        /* company-coq-comment-h2-face */
        color: #8b2252;
        font-size: 180%;
      }
      .company-coq-coqdoc-h2 {
        /* company-coq-coqdoc-h2-face */
        color: #8b2252;
        font-weight: bold;
      }
      .company-coq-featuresXsmart-subscripts {
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .coq-solve-tactics {
        /* coq-solve-tactics-face */
        color: #ff0000;
      }
      .doc {
        /* font-lock-doc-face */
        color: #8b2252;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .proof-tactics-name {
        /* proof-tactics-name-face */
        color: #00008b;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #a0522d;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="company-coq-comment-h2">(*+ borceuxSolution.v +*)</span>

<span class="doc">(******************************************

Proph

https://github.com/1337777/borceux/blob/master/borceuxSolution.v

1. Short: This [1] solves some question of Ahrens [2] and Kan-Riehl [3], which is how to program Kelly's &lt;&lt;enriched categories&gt;&gt; and how the inter-dependence of &lt;&lt;naturality&gt;&gt; with &lt;&lt;category&gt;&gt; is cyclic. Also This [4] attempts to clarify the contrast &lt;&lt;categorical algebra&gt;&gt; (ring/locale-presentation and its "internal logic"), from &lt;&lt;categorial logic&gt;&gt; in the style of the &lt;&lt;enriched/encoded/programmed/recursion&gt;&gt; categories of Kelly-Dosen or Lawvere-Lambek and as attempted in [5], for example : the yoneda lemma and most categorial lemmas are no-more-than Gentzen's constructive logic of re-arranging the input-output positions &lt;&lt;modulo naturality&gt;&gt;. Now homotopy/knots/proof-nets may be held as (faithfull or almost-faithfull) semantical techniques (&lt;&lt;descent&gt;&gt;) to do this &lt;&lt;categorial logic&gt;&gt;, and the homotopy itself may be programmed in specialized grammars (for example [6] or HOTT).

2. The common assumption that catC( - , X ) is dual to catC( Y , - ) is FALSIFIED. This falsification originates from the description of the composition as some binary form instead of as some functional form which is programmed/encoded/enriched onto the computer. Then get some new thing which is named &lt;&lt;polymorphism&gt;&gt; from which to define &lt;&lt;polymorph category&gt;&gt;. This is the only-ever real description and deduction of the yoneda lemma, which says that the image of polyF (which is injective and contained in natural transformations) also contains all natural transformations.

3. Some polymorph category is given by polyF, which is commonly ( _1 o&gt; _2 ), polymorph in V and polymorph in A :
Variable obF : Type.
Variable polyF00 : obF -&gt; obF -&gt; obV.
Notation "F[0 A1 ~&gt; A2 ]0" := (polyF00 A1 A2) (at level 25).
Parameter polyF : forall (B : obF), forall (V : obV) (A : obF),
                    V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                    forall X : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

4. And to get polymorph functor, instead of describing F : catA --&gt; catB  then (contrast yoneda structures) describe catV[ V , catB[ B , F - ] ] : catA --&gt; catV
   And to get polymorph transformation, instead of describing phi A : G A -&gt; H A  then a-la-dosen (contrast weighted colimiting Kan extension) describe phi _f : catV( V , catB[ B , G A ] ) -&gt;  catV( V , catB[ B , H A ] )

5. Stake for nondependent Solution Programme Seminary at FMCS2016 and ICMS2016 :
paypal 1337777.OOO@gmail.com , wechatpay 2796386464 , irc #OOO1337777

[1] 1337777.OOO, https://github.com/1337777/borceux/blob/master/borceuxSolution.v
[2] Ahrens, https://github.com/benediktahrens/monads/blob/trunk/CAT/enriched_cat.v
[3] Riehl, http://www.math.jhu.edu/~eriehl/context.pdf
[4] 1337777.OOO, https://github.com/1337777/borceux/blob/master/chic05.pdf
[5] 1337777.OOO, https://github.com/1337777/dosen/blob/master/itp.pdf
[6] Ye, http://katherineye.com/post/129960474471/strange-loops-capturing-knots-with-powerful

* use this authorizing-geolocated-timed-tutoring tool to play these links as TV !
http://1337777.link/ooo/guJAHkwRZYYyuhrh4GyYWv7BPOwNEF-jSeQcYN9WxLk!Zw1GYSFfr6cheRhkPhTPCnsog7DFPZQUCcv7ZEKh22s

******************************************)</span>

<span class="keyword">Set Implicit Arguments</span>.

<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put any category V</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">obV</span> : <span class="type">Type</span>.
<span class="keyword">Variable</span> <span class="variable-name">arrV00</span> : obV -&gt; obV -&gt; <span class="type">Type</span>.
<span class="keyword">Notation</span> <span class="string">"V(0 V1 |- V2 )0"</span> := (arrV00 V1 V2) (<span class="type">at</span> level 35).

<span class="keyword">Variable</span> <span class="variable-name">IdenV</span> : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, V(0 V |- V )0.
<span class="keyword">Notation</span> <span class="string">"1"</span> := (<span class="constant">@</span>IdenV _) (<span class="type">at</span> level 0).

<span class="keyword">Variable</span> <span class="variable-name">ComV</span> : <span class="type">forall</span> <span class="variable-name">UCom V3</span>, V(0 UCom |- V3 )0 -&gt; <span class="type">forall</span> <span class="variable-name">V1</span>, V(0 V1 |-  UCom )0 -&gt; V(0 V1 |- V3 )0.
<span class="keyword">Notation</span> <span class="string">"f2 &lt;o f1"</span> := (ComV f2 f1) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
<span class="keyword">Notation</span> <span class="string">"f1 o&gt; f2"</span> := (ComV f2 f1) (<span class="type">at</span> level 34, <span class="proof-tactics-name">right</span> <span class="comment-delimiter">(*</span><span class="comment">yes right</span><span class="comment-delimiter">*)</span> associativity).

<span class="keyword">Variable</span> <span class="variable-name">convV</span> : <span class="type">forall</span> <span class="variable-name">V1 V2</span>, V(0 V1 |- V2)0 -&gt; V(0 V1 |- V2 )0 -&gt; <span class="type">Prop</span>.
<span class="keyword">Notation</span> <span class="string">"v2 ~~ v1"</span> := (convV v2 v1)  (<span class="type">at</span> level 70).

<span class="keyword">Hypothesis</span> <span class="variable-name">CongCom</span> : <span class="type">forall</span> <span class="variable-name">A2 A3</span>, <span class="type">forall</span> (<span class="variable-name">f2 f2'</span> : V(0 A2 |- A3 )0), f2 ~~ f2' -&gt; <span class="type">forall</span> <span class="variable-name">A1</span>, <span class="type">forall</span> (<span class="variable-name">f1 f1'</span> : V(0 A1 |- A2 )0), f1 ~~ f1' -&gt; f2 &lt;o f1 ~~ f2' &lt;o f1'.
<span class="keyword">Hypothesis</span> <span class="variable-name">ReflV</span> : <span class="type">forall</span> A1 A2 (<span class="variable-name">f</span> : V(0 A1 |- A2 )0), f ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">TransV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> (<span class="variable-name">uTrans f</span> : V(0 A1 |- A2)0), uTrans ~~ f -&gt; <span class="type">forall</span> (<span class="variable-name">f'</span> : V(0 A1 |- A2)0), f' ~~ uTrans -&gt; f' ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">SymV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>,  <span class="type">forall</span> (<span class="variable-name">f' f</span> : V(0 A1 |- A2)0), f ~~ f' -&gt; f' ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">Cat1RightV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ f &lt;o 1.
<span class="keyword">Hypothesis</span> <span class="variable-name">Cat1LeftV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ 1 &lt;o f.
<span class="keyword">Hypothesis</span> <span class="variable-name">Cat2V</span> : <span class="type">forall</span> A3 A4 (<span class="variable-name">f3</span> : V(0 A3 |- A4)0), <span class="type">forall</span> A2 (<span class="variable-name">f2</span> : V(0 A2 |- A3)0), <span class="type">forall</span> A1 (<span class="variable-name">f1</span> : V(0 A1 |- A2)0),
                     (f3 &lt;o f2) &lt;o f1 ~~ f3 &lt;o (f2 &lt;o f1).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put functional monoidal logic onto V</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">desV00</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> <span class="variable-name">V1</span> : obV, obV.
<span class="keyword">Notation</span>  <span class="string">"(0 V1 * V2 )0"</span> := (desV00 V2 V1) (<span class="type">at</span> level 30, V1 <span class="type">at</span> next level).
<span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">V2 V1</span> =&gt; (0 V1 *  V2 )0  ).
<span class="keyword">Variable</span> <span class="variable-name">desV10</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> V1 V1' (<span class="variable-name">v</span> : arrV00 V1 V1'),  V(0 (0 V1* V2 )0 |- (0 V1' * V2 )0 )0.
<span class="keyword">Notation</span>  <span class="string">"(1 v * V2 )0"</span> := (desV10 V2 v) (<span class="type">at</span> level 30, v <span class="type">at</span> next level).
<span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">V2 v</span> =&gt; (1 v *  V2 )0  ).

<span class="keyword">Variable</span> <span class="variable-name">consV00</span> : obV -&gt; obV -&gt; obV.
<span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; V2 ]0"</span> := (consV00 V1 V2) (<span class="type">at</span> level 30).
<span class="keyword">Variable</span> <span class="variable-name">consV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : arrV00 V2 V2'), V(0 [0 V1 ~&gt; V2 ]0 |- [0 V1 ~&gt; V2' ]0 )0.
<span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; v ]1"</span> := (consV01 V1 v) (<span class="type">at</span> level 30).
<span class="keyword">Variable</span> <span class="variable-name">consV10</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : arrV00 V1' V1), <span class="type">forall</span> <span class="variable-name">V2</span> : obV, V(0 [0 V1 ~&gt; V2 ]0 |- [0 V1' ~&gt; V2 ]0 )0.
<span class="keyword">Notation</span> <span class="string">"[1 v ~&gt; V2 ]0"</span> := (consV10 v V2) (<span class="type">at</span> level 30).

<span class="keyword">Variable</span> <span class="variable-name">Des</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 U |- [0 V ~&gt; W ]0 )0 -&gt; V(0 (0 U * V )0  |- W )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongDes</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 U |- [0 V ~&gt; W ]0 )0),
                     f' ~~ f -&gt; Des f' ~~ Des f.
<span class="keyword">Variable</span> <span class="variable-name">DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 -&gt; V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0.
<span class="keyword">Variable</span> <span class="variable-name">CongDesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                       v' ~~ v -&gt; DesIn v' ~~ DesIn v.
<span class="keyword">Variable</span> <span class="variable-name">ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0 -&gt; V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                         v' ~~ v -&gt; ConsIn v' ~~ ConsIn v.
<span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                           ConsIn (DesIn f) ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">DesIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                     (DesIn v) &lt;o i ~~ DesIn( v &lt;o i ).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get the definition of polymorph category F</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">obF</span> : <span class="type">Type</span>.
<span class="keyword">Variable</span> <span class="variable-name">polyF00</span> : obF -&gt; obF -&gt; obV.
<span class="keyword">Notation</span> <span class="string">"F[0 A1 ~&gt; A2 ]0"</span> := (polyF00 A1 A2) (<span class="type">at</span> level 25).

<span class="keyword">Parameter</span> <span class="variable-name">polyF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                    V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

<span class="comment-delimiter">(*</span><span class="comment"> therefore "F[1 f ~&gt; X ]0" is similar to ( f o&gt; _ ) </span><span class="comment-delimiter">*)</span>
<span class="keyword">Notation</span> <span class="string">"F[1 f ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ _ _ f X) (<span class="type">at</span> level 25).

<span class="comment-delimiter">(*</span><span class="comment"> therefore "F[0 X ~&gt; g ]1" is similar to the common ( _ &lt;o g ) </span><span class="comment-delimiter">*)</span>
<span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; g ]1"</span> := (<span class="constant">@</span>polyF _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">g</span> : V(0 _ |- F[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).


<span class="doc">(** related to correspondence with the common representation **)</span>
<span class="keyword">Variable</span> <span class="variable-name">polyF_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">A</span> : obF) (<span class="variable-name">V</span> : obV),
                        <span class="type">forall</span> (<span class="variable-name">V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                          F[1 f &lt;o v ~&gt; X ]0
                           ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 .

<span class="doc">(** related to associativity, polyF_morphism says that, put the parameter f and the modifier argument g, then get
        (outer modification)    ( g &lt;o f ) o&gt; _  =  f o&gt; ( g o&gt; _ )    (inner modification)
which is, holding only f as parameter and running all the arguments,
        (outer modification)    ( _1 &lt;o f ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
 **)</span>
<span class="keyword">Variable</span> <span class="variable-name">polyF_morphism</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">A</span> : obF) (<span class="variable-name">V</span> : obV),
                           <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obF) (<span class="variable-name">g</span> : V(0 W |- F[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                             F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                              ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[1 g ~&gt; X ]0 ).

<span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                       <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                         f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obF, polyF f' X ~~ polyF f X.

<span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">A</span> : obF),
                         <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
  := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF B (F[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) X).
<span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV B) (<span class="type">at</span> level 25).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the logical category V is polymorph</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">polyV</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">V</span> : obV),
                   V(0 U |- [0 W ~&gt; V ]0 )0 -&gt;
                   <span class="type">forall</span> <span class="variable-name">X</span> : obV, V(0 [0 V ~&gt; X ]0  |- [0 U ~&gt; [0 W ~&gt; X ]0 ]0 )0.

<span class="keyword">Notation</span> <span class="string">"V[0 U ~&gt; V ]0"</span> := ([0 U ~&gt; V ]0) (<span class="type">at</span> level 25, only parsing).
<span class="keyword">Notation</span> <span class="string">"V[1 v ~&gt; X ]0"</span> := (<span class="constant">@</span>polyV _ _ _ v X) (<span class="type">at</span> level 25).
<span class="keyword">Notation</span> <span class="string">"V[0 X ~&gt; w ]1"</span> := (<span class="constant">@</span>polyV _ _ _ 1 X &lt;o w) (<span class="type">at</span> level 25).
<span class="keyword">Notation</span> <span class="string">"V[0 W ~&gt; - ]1"</span> := (<span class="type">fun</span> <span class="variable-name">V X</span> =&gt; <span class="constant">@</span>polyV _ _ _ (<span class="constant">@</span>IdenV ([0 W ~&gt; V ]0)) X) (<span class="type">at</span> level 25). 

<span class="keyword">Hypothesis</span> <span class="variable-name">polyV_monoV</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">V</span> : obV),
                       <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 W ~&gt; V ]0 )0), <span class="type">forall</span> <span class="variable-name">X</span> : obV,
                         [1 Des v ~&gt; X]0
                                       ~~ DesIn( V[1 v ~&gt; X ]0 ) .

<span class="keyword">Hypothesis</span> <span class="variable-name">polyV_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obV) (<span class="variable-name">V</span> : obV),
                        <span class="type">forall</span> (<span class="variable-name">V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obV),
                          V[1 f &lt;o v ~&gt; X ]0
                           ~~ [1 v ~&gt; V[0 B ~&gt; X ]0 ]0 &lt;o V[1 f ~&gt; X ]0 .


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF are contained in natural transformations</span></span><span class="doc"> **)</span>

<span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">A</span> : obF) (<span class="variable-name">V</span> : obV),
                        <span class="type">forall</span> (<span class="variable-name">W V'</span> : obV) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                          F[1 f &lt;o (Des v) ~&gt; X ]0
                           ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> polyF_arrow ].
  <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_monoV.
<span class="keyword">Qed</span>.

<span class="doc">(** polyF_natural (sym) says that, put the parameter f, then get
        (outer modification)    _1 &lt;o ( f o&gt; _2 )  =  f o&gt; ( _1 &lt;o _2 )    (inner modification)
and this is codeductible with polyF_morphism above which says that, put the parameter f, then get
        (outer modification)    ( _1 &lt;o f ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
now memo that in the left hand sides there is mirroring of whole and permutation of inputs, and that in the right hand sides there is mirroring of block and permutation of inputs,
 **)</span>
<span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                      <span class="type">forall</span> (<span class="variable-name">C X</span> : obF),
                        ( [0 F[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                          &lt;o F[0 A ~&gt; - ]1 C X )
                          ~~ ( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .
<span class="keyword">Proof</span>.
  <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
  <span class="proof-tactics-name">apply</span> CongConsIn.

  <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (F[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0
                   ~~ DesIn( [0 F[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[0 A ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) &lt;o f  ~&gt; C ]0 ) ~&gt; X ]0
                   ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (F[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0 )
    <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
         <span class="proof-tactics-name">apply</span> polyF_arrow ).

  <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X )
                       ~~ DesIn( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
         <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
         <span class="proof-tactics-name">apply</span> polyV_arrow ).

  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; C ]0)) &lt;o Des( (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ) ~&gt; X ]0 )
                    ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

  <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

  <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
  
  <span class="proof-tactics-name">apply</span> ReflV.
<span class="keyword">Qed</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF contains all natural transformations</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">IdenObV</span> : obV.
<span class="keyword">Notation</span>  <span class="string">"'I'"</span> := (IdenObV) (<span class="type">at</span> level 0).

<span class="keyword">Parameter</span> <span class="variable-name">unitF</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obF}, V(0 I |- F[0 A ~&gt; A ]0 )0.
<span class="keyword">Notation</span> <span class="string">"'u'"</span> := (<span class="constant">@</span>unitF _) (<span class="type">at</span> level 0).

<span class="keyword">Variable</span> <span class="variable-name">DesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 U |- [0 I ~&gt; W ]0 )0 -&gt; V(0 U  |- W )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongDesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U |- [0 I ~&gt; W ]0 )0),
                              v' ~~ v -&gt; DesIdenObR v' ~~ DesIdenObR v.
<span class="keyword">Hypothesis</span> <span class="variable-name">DesIdenObR_output</span> : <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">W W'</span> : obV) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                 DesIdenObR( [0 I ~&gt; w ]1 &lt;o v ) ~~ w &lt;o DesIdenObR( v ).

<span class="keyword">Variable</span> <span class="variable-name">DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), V(0 I |- [0 V ~&gt; W ]0 )0 -&gt; V(0 V |- W )0.
<span class="keyword">Variable</span> <span class="variable-name">ConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), V(0 V |- W )0 -&gt; V(0 I |- [0 V ~&gt; W ]0 )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">ConsIdenObL_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0,
                                       v ~~ ConsIdenObL( DesIdenObL v).
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 V |- W )0),
                                v' ~~ v -&gt; ConsIdenObL v' ~~ ConsIdenObL v.

<span class="keyword">Hypothesis</span> <span class="variable-name">consV10_functorial</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : arrV00 V1' V1), <span class="type">forall</span> V1'' (<span class="variable-name">v'</span> : arrV00 V1'' V1'), <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                                 [1 v &lt;o v' ~&gt; V2 ]0 ~~  [1 v' ~&gt; V2 ]0 &lt;o  [1 v ~&gt; V2 ]0 .
<span class="keyword">Hypothesis</span> <span class="variable-name">consV11_bifunctorial</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : arrV00 V1' V1), <span class="type">forall</span> W1 W1' (<span class="variable-name">w</span> : arrV00 W1 W1'),
                                   [0 V1' ~&gt; w ]1 &lt;o  [1 v ~&gt; W1 ]0 ~~ [1 v ~&gt; W1' ]0 &lt;o [0 V1 ~&gt; w ]1 .
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsV10</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v v'</span> : arrV00 V1' V1), <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                          v' ~~ v -&gt; [1 v' ~&gt; V2 ]0 ~~ [1 v ~&gt; V2 ]0 .

<span class="doc">(** related to non-variance when unit pull the input **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">polyF_unitF</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obF), <span class="type">forall</span> <span class="variable-name">X</span> : obF, (<span class="constant">@</span>IdenV (F[0 A ~&gt; X ]0)) ~~ DesIdenObR( F[1 (<span class="constant">@</span>unitF A) ~&gt; X ]0 ) .

<span class="doc">(** related to non-variance when unit push the output,
       therefore polyF is injective **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">polyF_inputUnitF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                f  ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitF A) ).

<span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ) :=
  <span class="type">forall</span> (<span class="variable-name">C X</span> : obF),
    ( [0 F[0 A ~&gt; C ]0 ~&gt; &#966; X ]1
      &lt;o F[0 A ~&gt; - ]1 C X )
      ~~ ( [1 &#966; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
           &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

<span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                                 natural &#966; -&gt;
                                 <span class="type">forall</span> (<span class="variable-name">X</span> : obF),
                                   DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitF A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                             ~~ ( &#966; X ) .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyF_arrow ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyF, SymV, Cat1LeftV ].  
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyF_unitF ].
  <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                        natural &#966; -&gt; natural &#966;' -&gt;
                        &#966;' A &lt;o (<span class="constant">@</span>unitF A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitF A) -&gt;
                        <span class="type">forall</span> <span class="variable-name">X</span> : obF, &#966;' X ~~ &#966; X.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                          <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
  <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
  <span class="coq-solve-tactics">assumption</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                 natural &#966; -&gt;
                 <span class="type">forall</span> <span class="variable-name">X</span> : obF, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitF A) ) ~&gt; X ]0.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitF A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitF A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitF A) ).
  <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
  <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
  
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
  <span class="proof-tactics-name">apply</span> CongConsIdenObL.
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitF |  <span class="proof-tactics-name">apply</span> ReflV ].
<span class="keyword">Qed</span>.


<span class="keyword">Module</span> <span class="function-name">Functor</span>.
  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">next : polymorph functor</span></span><span class="doc"> **)</span>
  <span class="doc">(** instead of describing F : catA --&gt; catB  then (contrast yoneda structures) describe catV( V , catB[ B , F - ] ) : catA --&gt; catV **)</span>
<span class="keyword">End</span> <span class="function-name">Functor</span>.


<span class="keyword">Module</span> <span class="function-name">Transformation</span>.
  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">next : polymorph transformation</span></span><span class="doc"> **)</span>
  <span class="doc">(** instead of describing &#966; A : G A -&gt; H A  then a-la-dosen (contrast weighted colimiting Kan extension) describe &#966; _f : catV( V , catB[ B , G A ] ) -&gt;  catV( V , catB[ B , H A ] ) **)</span>
<span class="keyword">End</span> <span class="function-name">Transformation</span>.
</pre>
  </body>
</html>
