<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>borceuxSolution2.v</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #b22222;
      }
      .company-coq-comment-h2 {
        /* company-coq-comment-h2-face */
        color: #8b2252;
        font-size: 180%;
      }
      .company-coq-coqdoc-h2 {
        /* company-coq-coqdoc-h2-face */
        color: #8b2252;
        font-weight: bold;
      }
      .company-coq-featuresXsmart-subscripts {
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .coq-solve-tactics {
        /* coq-solve-tactics-face */
        color: #ff0000;
      }
      .doc {
        /* font-lock-doc-face */
        color: #8b2252;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .proof-tactics-name {
        /* proof-tactics-name-face */
        color: #00008b;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #a0522d;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="company-coq-comment-h2">(*+ borceuxSolution.v +*)</span>

<span class="doc">(******************************************

TODO: in polyF_morphism, change DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[1 g ~&gt; X ]0 ) to DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 ) &lt;o F[1 g ~&gt; X ]0 

Proph

https://github.com/1337777/borceux/blob/master/borceuxSolution.v

1. Short: This [1] solves some question of Ahrens [2] and Kan-Riehl [3], which is how to program Kelly's &lt;&lt;enriched categories&gt;&gt; and how the inter-dependence of &lt;&lt;naturality&gt;&gt; with &lt;&lt;category&gt;&gt; is cyclic. Also This [4] attempts to clarify the contrast &lt;&lt;categorical algebra&gt;&gt; (ring/locale-presentation and its "internal logic"), from &lt;&lt;categorial logic&gt;&gt; in the style of the &lt;&lt;enriched/encoded/programmed/recursion&gt;&gt; categories of Kelly-Dosen or Lawvere-Lambek and as attempted in [5], for example : the yoneda lemma and most categorial lemmas are no-more-than Gentzen's constructive logic of re-arranging the input-output positions &lt;&lt;modulo naturality&gt;&gt;. Now homotopy/knots/proof-nets may be held as (faithfull or almost-faithfull) semantical techniques (&lt;&lt;descent&gt;&gt;) to do this &lt;&lt;categorial logic&gt;&gt;, and the homotopy itself may be programmed in specialized grammars (for example [6] or HOTT).

2. The common assumption that catC( - , X ) is dual to catC( Y , - ) is FALSIFIED. This falsification originates from the description of the composition as some binary form instead of as some functional form which is programmed/encoded/enriched onto the computer. Then get some new thing which is named &lt;&lt;polymorphism&gt;&gt; from which to define &lt;&lt;polymorph category&gt;&gt;. This is the only-ever real description and deduction of the yoneda lemma, which says that the image of polyF (which is injective and contained in natural transformations) also contains all natural transformations.

3. Some polymorph category is given by polyF, which is commonly ( _1 o&gt; _2 ), polymorph in V and polymorph in A :
 Variable obF : Type.
 Variable polyF00 : obF -&gt; obF -&gt; obV.
 Notation "F[0 B ~&gt; A ]0" := (polyF00 B A) (at level 25).
 Parameter polyF : forall (B : obF), forall (V : obV) (A : obF),
                     V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                     forall X : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

4. And to get polymorph functor, instead of describing F : catA --&gt; catB  then (contrast yoneda structures) describe catV[ V , catB[ B , F - ] ] : catA --&gt; catV , more precisely
  Variable polyF0 : obA -&gt; obB.
  Notation "F|0 A" := (polyF0 A) (at level 4, right associativity).
  Notation "F[0 B ~&gt; A ]0" := (B[0 B ~&gt; F|0 A ]0) (at level 25).
  Parameter polyF : forall (V : obV) (B : obB) (A : obA),
                      V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                      forall X : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

5. And to get polymorph transformation, instead of describing phi A : G A -&gt; H A  then a-la-dosen (contrast weighted colimiting Kan extension) describe phi _f : catV( V , catB[ B , G A ] ) -&gt;  catV( V , catB[ B , H A ] ) , more precisely
   Parameter poly_phi : forall (V : obV) (B : obB) (A : obA),
                       V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                       V(0 V |- G[0 B ~&gt; A ]0 )0 .
And finally one shall relate the earlier &lt;&lt;naturality of transformation inside catV&gt;&gt; to this new &lt;&lt;polymorphism&gt;&gt; of transformation.

6. The earlier texts refering to Maclane associativity coherence and Dosen semiassociativity coherence and Dosen cut elimination for adjunctions and Chlipala ur/web database programming are all related to this present text which is how to program logically-enriched categories.

7. Stake for nondependent Solution Programme Seminary at FMCS2016 and ICMS2016 :
paypal 1337777.OOO@gmail.com , wechatpay 2796386464 , irc #OOO1337777

[1] 1337777.OOO, https://github.com/1337777/borceux/blob/master/borceuxSolution.v
[2] Ahrens, https://github.com/benediktahrens/monads/blob/trunk/CAT/enriched_cat.v
[3] Riehl, http://www.math.jhu.edu/~eriehl/context.pdf
[4] 1337777.OOO, https://github.com/1337777/borceux/blob/master/chic05.pdf
[5] 1337777.OOO, https://github.com/1337777/dosen/blob/master/itp.pdf
[6] Ye, http://katherineye.com/post/129960474471/strange-loops-capturing-knots-with-powerful

* use this authorizing-geolocated-timed-tutoring tool to play these links as TV !
http://1337777.link/ooo/guJAHkwRZYYyuhrh4GyYWv7BPOwNEF-jSeQcYN9WxLk!Zw1GYSFfr6cheRhkPhTPCnsog7DFPZQUCcv7ZEKh22s

 ******************************************)</span>

<span class="keyword">Set Implicit Arguments</span>.

<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put any ( may be written in polymorph-style ... ) `arrows :^) logic'   V</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">obV</span> : <span class="type">Type</span>.
<span class="keyword">Parameter</span> <span class="variable-name">monoV00</span> : obV -&gt; obV -&gt; <span class="type">Type</span>.
<span class="keyword">Notation</span> <span class="string">"V(0 B |- A )0"</span> := (monoV00 B A) (<span class="type">at</span> level 35).

<span class="keyword">Parameter</span> <span class="variable-name">convV</span> : <span class="type">forall</span> <span class="variable-name">V1 V2</span>, V(0 V1 |- V2)0 -&gt; V(0 V1 |- V2 )0 -&gt; <span class="type">Prop</span>.
<span class="keyword">Notation</span> <span class="string">"v2 ~~ v1"</span> := (convV v2 v1)  (<span class="type">at</span> level 70).
<span class="keyword">Hypothesis</span> <span class="variable-name">ReflV</span> : <span class="type">forall</span> A1 A2 (<span class="variable-name">f</span> : V(0 A1 |- A2 )0), f ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">TransV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> (<span class="variable-name">uTrans f</span> : V(0 A1 |- A2)0), uTrans ~~ f -&gt; <span class="type">forall</span> (<span class="variable-name">f'</span> : V(0 A1 |- A2)0), f' ~~ uTrans -&gt; f' ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">SymV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>,  <span class="type">forall</span> (<span class="variable-name">f' f</span> : V(0 A1 |- A2)0), f ~~ f' -&gt; f' ~~ f.

<span class="keyword">Parameter</span> <span class="variable-name">monoV_unitary</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                             V(0 B |- A )0 -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV, V(0 A |- X )0  -&gt; V(0 B |- X )0.

<span class="keyword">Definition</span> <span class="function-name">monoV_identitary</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                    <span class="type">forall</span> <span class="variable-name">X</span> : obV, V(0 A |- X )0  -&gt; V(0 B |- A )0 -&gt; V(0 B |- X )0
  :=  <span class="type">fun</span> (<span class="variable-name">B</span> : obV) =&gt; <span class="type">fun</span> (<span class="variable-name">A</span> : obV) =&gt;
                     <span class="type">fun</span> <span class="variable-name">X</span> : obV =&gt;  <span class="type">fun</span> (<span class="variable-name">a</span> : V(0 A |- X )0) =&gt; <span class="type">fun</span> (<span class="variable-name">b</span> : V(0 B |- A )0) =&gt;
                                                           (<span class="constant">@</span>monoV_unitary B A b X a).

<span class="keyword">Notation</span> <span class="string">"V(1 b |- - )0"</span> := (<span class="constant">@</span>monoV_unitary _ _ b) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( b 0 ) o&gt; _ )   **)</span>
<span class="keyword">Notation</span> <span class="string">"V(1 b |- X )0"</span> := (<span class="constant">@</span>monoV_unitary _ _ b X) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( b 0 ) o&gt; a )  **)</span>
<span class="keyword">Notation</span> <span class="string">"b o&gt; a"</span> := (<span class="constant">@</span>monoV_unitary _ _ b _ a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

<span class="keyword">Notation</span> <span class="string">"V(1 'id' |- X )0"</span> := (<span class="constant">@</span>monoV_identitary _ _ X) (<span class="type">at</span> level 35).
<span class="keyword">Notation</span> <span class="string">"V(0 X |- - )1"</span> := (<span class="constant">@</span>monoV_identitary _ _ X) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( id _ ) o&gt; a )  **)</span>
<span class="keyword">Notation</span> <span class="string">"V(0 X |- a )1"</span> := (<span class="constant">@</span>monoV_identitary _ _ X a) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( id b ) o&gt; a )  **)</span>
<span class="keyword">Notation</span> <span class="string">"a &lt;o b"</span> := (<span class="constant">@</span>monoV_identitary _ _ _ a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

<span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">monoV_morphism</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV), 
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obV) (<span class="variable-name">A'</span> : obV) (<span class="variable-name">g</span> : V(0 A |- A')0),
                           <span class="type">forall</span> (<span class="variable-name">X</span> : obV), <span class="type">forall</span> (<span class="variable-name">pull</span> : V(0 B |- A)0), <span class="type">forall</span> (<span class="variable-name">push</span> : V(0 A'  |- X )0 ),
                             V(1 V(0 A' |- g )1 pull |- X )0 push
                              ~~  V(0 X |- V(1 g |- X )0 push )1 pull .

<span class="keyword">Check</span> monoV_morphism : <span class="type">forall</span> (<span class="variable-name">B A A'</span> : obV) (<span class="variable-name">g</span> : V(0 A |- A' )0) (<span class="variable-name">X</span> : obV) 
                         (<span class="variable-name">pull</span> : V(0 B |- A )0) (<span class="variable-name">push</span> : V(0 A' |- X )0),
                         (g &lt;o pull) o&gt; push ~~ (g o&gt; push) &lt;o pull .
<span class="keyword">About</span> monoV_morphism.

<span class="keyword">Lemma</span> <span class="function-name">Cat2V</span> : <span class="type">forall</span> A3 A4 (<span class="variable-name">f3</span> : V(0 A3 |- A4)0), <span class="type">forall</span> A2 (<span class="variable-name">f2</span> : V(0 A2 |- A3)0), <span class="type">forall</span> A1 (<span class="variable-name">f1</span> : V(0 A1 |- A2)0),
                (f3 &lt;o f2) &lt;o f1 ~~ f3 &lt;o (f2 &lt;o f1).
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> SymV, monoV_morphism.
<span class="keyword">Qed</span>.

<span class="keyword">Definition</span> <span class="function-name">convV_fun</span> : <span class="type">forall</span> <span class="variable-name">U1 U2 V1 V2</span>, (V(0 U1 |- U2)0 -&gt; V(0 V1 |- V2)0) -&gt; (V(0 U1 |- U2)0 -&gt; V(0 V1 |- V2 )0) -&gt; <span class="type">Prop</span>
  := <span class="type">fun</span>  U1 U2 V1 V2 (<span class="variable-name">w' w</span> : (V(0 U1 |- U2)0 -&gt; V(0 V1 |- V2)0)) =&gt;
       <span class="type">forall</span> <span class="variable-name">u1 u2</span>, u1 ~~ u2 -&gt; w' u1 ~~ w u2 .
<span class="keyword">Notation</span> <span class="string">"w' ~~~ w"</span> := (convV_fun w' w)  (<span class="type">at</span> level 70).
<span class="doc">(** ALT 
Hypothesis CongMonoV : forall (B : obV), forall (A : obV),
                       forall X : obV, forall (a a' : V(0 A |- X )0),
                         a' ~~ a -&gt; </span><span class="constant"><span class="doc">@</span></span><span class="doc">monoV_identitary B A X a' ~~~ </span><span class="constant"><span class="doc">@</span></span><span class="doc">monoV_identitary B A X a .
**)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">CongMonoV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                       <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 B |- A )0),
                         f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV, <span class="constant">@</span>monoV_unitary B A f' X ~~~ <span class="constant">@</span>monoV_unitary B A f X.


<span class="keyword">Lemma</span> <span class="function-name">CongCom</span> : <span class="type">forall</span> <span class="variable-name">A2 A3</span>, <span class="type">forall</span> (<span class="variable-name">f2 f2'</span> : V(0 A2 |- A3 )0), f2 ~~ f2' -&gt; <span class="type">forall</span> <span class="variable-name">A1</span>, <span class="type">forall</span> (<span class="variable-name">f1 f1'</span> : V(0 A1 |- A2 )0), f1 ~~ f1' -&gt; f2 &lt;o f1 ~~ f2' &lt;o f1'.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> CongMonoV.
  <span class="coq-solve-tactics">assumption</span>.
  <span class="coq-solve-tactics">assumption</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Parameter</span> <span class="variable-name">IdenV</span> : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, V(0 V |- V )0.
<span class="keyword">Notation</span> <span class="string">"1"</span> := (<span class="constant">@</span>IdenV _) (<span class="type">at</span> level 0).

<span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
<span class="keyword">Definition</span> <span class="function-name">idT</span> : <span class="type">forall</span> <span class="variable-name">T</span> : <span class="type">Type</span>, T -&gt; T := <span class="type">fun</span> <span class="variable-name">T</span> : <span class="type">Type</span> =&gt; <span class="type">fun</span> <span class="variable-name">x</span> : T =&gt; x .
<span class="keyword">Hypothesis</span> <span class="variable-name">monoV_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV), <span class="type">forall</span> <span class="variable-name">X</span> : obV, ( <span class="constant">@</span>idT (V(0 A |- X )0)  ) ~~~ ( V(1 (<span class="constant">@</span>IdenV A) |- X )0 ) .

<span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyV is injective **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">monoV_inputUnitV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                              <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 B |- A )0),
                                b  ~~ ( (V(1 b |- A )0)  (<span class="constant">@</span>IdenV A) ).

<span class="keyword">Lemma</span> <span class="function-name">Cat1RightV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ f &lt;o 1.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> monoV_unitV.
  <span class="proof-tactics-name">apply</span> ReflV.
<span class="keyword">Qed</span>.
  
<span class="keyword">Lemma</span> <span class="function-name">Cat1LeftV</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ 1 &lt;o f.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> monoV_inputUnitV.
<span class="keyword">Qed</span>.

<span class="keyword">Definition</span> <span class="function-name">ComV</span> : <span class="type">forall</span> <span class="variable-name">V1</span>, <span class="type">forall</span> <span class="variable-name">UCom</span>, V(0 V1 |-  UCom )0 -&gt; <span class="type">forall</span> <span class="variable-name">V3</span>, V(0 UCom |- V3 )0 -&gt; V(0 V1 |- V3 )0.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> monoV_unitary. <span class="coq-solve-tactics">eassumption</span>. <span class="coq-solve-tactics">eassumption</span>.
<span class="keyword">Defined</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put functional monoidal logic onto V</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">desV00</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> <span class="variable-name">V1</span> : obV, obV.
<span class="keyword">Notation</span>  <span class="string">"(0 V1 * V2 )0"</span> := (desV00 V2 V1) (<span class="type">at</span> level 30, V1 <span class="type">at</span> next level).
<span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">V2 V1</span> =&gt; (0 V1 *  V2 )0  ).
<span class="keyword">Variable</span> <span class="variable-name">desV10</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> V1 V1' (<span class="variable-name">v</span> : V(0 V1 |- V1' )0),  V(0 (0 V1* V2 )0 |- (0 V1' * V2 )0 )0.
<span class="keyword">Notation</span>  <span class="string">"(1 v * V2 )0"</span> := (desV10 V2 v) (<span class="type">at</span> level 30, v <span class="type">at</span> next level).
<span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">V2 v</span> =&gt; (1 v *  V2 )0  ).

<span class="keyword">Variable</span> <span class="variable-name">consV00</span> : obV -&gt; obV -&gt; obV.
<span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; V2 ]0"</span> := (consV00 V1 V2) (<span class="type">at</span> level 30).
<span class="keyword">Variable</span> <span class="variable-name">consV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : V(0 V2 |- V2' )0), V(0 [0 V1 ~&gt; V2 ]0 |- [0 V1 ~&gt; V2' ]0 )0.
<span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; v ]1"</span> := (consV01 V1 v) (<span class="type">at</span> level 30).
<span class="keyword">Variable</span> <span class="variable-name">consV10</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : V(0 V1' |- V1)0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV, V(0 [0 V1 ~&gt; V2 ]0 |- [0 V1' ~&gt; V2 ]0 )0.
<span class="keyword">Notation</span> <span class="string">"[1 v ~&gt; V2 ]0"</span> := (consV10 v V2) (<span class="type">at</span> level 30).

<span class="keyword">Variable</span> <span class="variable-name">Des</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 U |- [0 V ~&gt; W ]0 )0 -&gt; V(0 (0 U * V )0  |- W )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongDes</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 U |- [0 V ~&gt; W ]0 )0),
                       f' ~~ f -&gt; Des f' ~~ Des f.
<span class="keyword">Variable</span> <span class="variable-name">DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 -&gt; V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0.
<span class="keyword">Variable</span> <span class="variable-name">CongDesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                       v' ~~ v -&gt; DesIn v' ~~ DesIn v.
<span class="keyword">Variable</span> <span class="variable-name">ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0 -&gt; V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                          v' ~~ v -&gt; ConsIn v' ~~ ConsIn v.
<span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                            ConsIn (DesIn f) ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">DesIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                           (DesIn v) &lt;o i ~~ DesIn( v &lt;o i ).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get the definition of polymorph category F</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">obF</span> : <span class="type">Type</span>.
<span class="keyword">Variable</span> <span class="variable-name">polyF00</span> : obF -&gt; obF -&gt; obV.
<span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (polyF00 B A) (<span class="type">at</span> level 25).

<span class="keyword">Parameter</span> <span class="variable-name">polyF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                    V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

<span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to ( b o&gt; _ ) **)</span>
<span class="keyword">Notation</span> <span class="string">"F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ _ _ b X) (<span class="type">at</span> level 25).

<span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to the common ( _ o&gt; a ) ,   more precisely ( (id _) o&gt; a )   **)</span>
<span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- F[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).
<span class="doc">(** memo: may attempt  "F[1 b ~&gt; a ]1" ,  shall be similar to the common ( (b _i) o&gt; a ) 
therefore "F[1 _1 ~&gt; _2 ]1 _3 shall be ( (_1 _3) o&gt; _2 ) **)</span>

<span class="doc">(** related to correspondence with the common representation **)</span>
<span class="keyword">Variable</span> <span class="variable-name">polyF_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">A</span> : obF),
                        <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                          F[1 f &lt;o v ~&gt; X ]0
                           ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 .

<span class="doc">(** related to associativity, polyF_morphism says that, put the parameter f and the modifier argument g, then get
xxERASE        (outer modification)    ( g &lt;o f ) o&gt; _  =  f o&gt; ( g o&gt; _ )    (inner modification)
           (outer modification)    ( (f ) o&gt; g ) o&gt; _  =  f o&gt; ( g o&gt; _ )    (inner modification)
which is, holding only f as parameter and running all the arguments,
xxERASE        (outer modification)    ( _1 &lt;o f ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
           (outer modification)    ( (f ) o&gt; _1 ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
 **)</span>
<span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
<span class="keyword">Variable</span> <span class="variable-name">polyF_morphism</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obF) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obF) (<span class="variable-name">g</span> : V(0 W |- F[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                             F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                              ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[1 g ~&gt; X ]0 ).

<span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                       <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                         f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obF, polyF f' X ~~ polyF f X.

<span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">A</span> : obF),
                         <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
  := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF B (F[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) X).
<span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV B) (<span class="type">at</span> level 25).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the logical category V is polymorph</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">polyV</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">V</span> : obV),
                   V(0 U |- [0 W ~&gt; V ]0 )0 -&gt;
                   <span class="type">forall</span> <span class="variable-name">X</span> : obV, V(0 [0 V ~&gt; X ]0  |- [0 U ~&gt; [0 W ~&gt; X ]0 ]0 )0.

<span class="keyword">Notation</span> <span class="string">"V[0 U ~&gt; V ]0"</span> := ([0 U ~&gt; V ]0) (<span class="type">at</span> level 25, only parsing).
<span class="keyword">Notation</span> <span class="string">"V[1 v ~&gt; X ]0"</span> := (<span class="constant">@</span>polyV _ _ _ v X) (<span class="type">at</span> level 25).
<span class="keyword">Notation</span> <span class="string">"V[0 X ~&gt; w ]1"</span> := (<span class="constant">@</span>polyV _ _ _ 1 X &lt;o w) (<span class="type">at</span> level 25).
<span class="keyword">Notation</span> <span class="string">"V[0 W ~&gt; - ]1"</span> := (<span class="type">fun</span> <span class="variable-name">V X</span> =&gt; <span class="constant">@</span>polyV _ _ _ (<span class="constant">@</span>IdenV ([0 W ~&gt; V ]0)) X) (<span class="type">at</span> level 25). 

<span class="keyword">Hypothesis</span> <span class="variable-name">polyV_monoV</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">V</span> : obV),
                         <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 W ~&gt; V ]0 )0), <span class="type">forall</span> <span class="variable-name">X</span> : obV,
                           [1 Des v ~&gt; X]0
                                         ~~ DesIn( V[1 v ~&gt; X ]0 ) .

<span class="keyword">Hypothesis</span> <span class="variable-name">polyV_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obV) (<span class="variable-name">V</span> : obV),
                          <span class="type">forall</span> (<span class="variable-name">V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obV),
                            V[1 f &lt;o v ~&gt; X ]0
                             ~~ [1 v ~&gt; V[0 B ~&gt; X ]0 ]0 &lt;o V[1 f ~&gt; X ]0 .


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF are contained in natural transformations</span></span><span class="doc"> **)</span>

<span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">A</span> : obF) (<span class="variable-name">V</span> : obV),
                       <span class="type">forall</span> (<span class="variable-name">W V'</span> : obV) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                         F[1 f &lt;o (Des v) ~&gt; X ]0
                          ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> polyF_arrow ].
  <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_monoV.
<span class="keyword">Qed</span>.

<span class="doc">(** polyF_natural (sym) says that, put the parameter f, then get
xxERASE        (outer modification)    _1 &lt;o ( f o&gt; _2 )  =  f o&gt; ( _1 &lt;o _2 )    (inner modification)
           (outer modification)    ( f o&gt; _2 ) o&gt; _1  =  f o&gt; ( _2 o&gt; _1 )    (inner modification)
and this is codeductible with polyF_morphism above which says that, put the parameter f, then get
xxERASE       (outer modification)    ( _1 &lt;o f ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
          (outer modification)    ( (f ) o&gt; _1 ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
xxERASE now memo that in the left hand sides there is mirroring of whole and permutation of inputs, and that in the right hand sides there is mirroring of block and permutation of inputs,
xxnow memo that in the left hand sides there is permutation of inputs, and that in the right hand sides there is mirroring of block and permutation of inputs,
now memo that in the left hand sides there is permutation of inputs, and that in the right hand sides there is permutation of inputs,  **)</span>
<span class="doc">(** written here :   (inner modification) ~~ (outer modification) **)</span>
<span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                      <span class="type">forall</span> (<span class="variable-name">C X</span> : obF),
                        ( [0 F[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                          &lt;o F[0 A ~&gt; - ]1 C X )
                          ~~ ( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .
<span class="keyword">Proof</span>.
  <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
  <span class="proof-tactics-name">apply</span> CongConsIn.

  <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (F[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0
                   ~~ DesIn( [0 F[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[0 A ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) &lt;o f  ~&gt; C ]0 ) ~&gt; X ]0
                   ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (F[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0 )
    <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
         <span class="proof-tactics-name">apply</span> polyF_arrow ).

  <span class="comment-delimiter">(*</span><span class="comment"> convert right hand side : outer polyV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X )
                       ~~ DesIn( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
         <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
         <span class="proof-tactics-name">apply</span> polyV_arrow ).

  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; C ]0)) &lt;o Des( (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ) ~&gt; X ]0 )
                    ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

  <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

  <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
  
  <span class="proof-tactics-name">apply</span> ReflV.
<span class="keyword">Qed</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF contains all natural transformations</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">IdenObV</span> : obV.
<span class="keyword">Notation</span>  <span class="string">"'I'"</span> := (IdenObV) (<span class="type">at</span> level 0).

<span class="keyword">Parameter</span> <span class="variable-name">unitF</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obF}, V(0 I |- F[0 A ~&gt; A ]0 )0.
<span class="keyword">Notation</span> <span class="string">"'u'"</span> := (<span class="constant">@</span>unitF _) (<span class="type">at</span> level 0).

<span class="keyword">Variable</span> <span class="variable-name">DesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 U |- [0 I ~&gt; W ]0 )0 -&gt; V(0 U  |- W )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongDesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U |- [0 I ~&gt; W ]0 )0),
                              v' ~~ v -&gt; DesIdenObR v' ~~ DesIdenObR v.
<span class="keyword">Hypothesis</span> <span class="variable-name">DesIdenObR_output</span> : <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">W W'</span> : obV) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                 DesIdenObR( [0 I ~&gt; w ]1 &lt;o v ) ~~ w &lt;o DesIdenObR( v ).

<span class="keyword">Variable</span> <span class="variable-name">DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), V(0 I |- [0 V ~&gt; W ]0 )0 -&gt; V(0 V |- W )0.
<span class="keyword">Variable</span> <span class="variable-name">ConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), V(0 V |- W )0 -&gt; V(0 I |- [0 V ~&gt; W ]0 )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">ConsIdenObL_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0,
                                      v ~~ ConsIdenObL( DesIdenObL v).
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 V |- W )0),
                               v' ~~ v -&gt; ConsIdenObL v' ~~ ConsIdenObL v.

<span class="keyword">Hypothesis</span> <span class="variable-name">consV10_functorial</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> :  V(0 V1' |- V1 )0), <span class="type">forall</span> V1'' (<span class="variable-name">v'</span> : V(0 V1'' |- V1' )0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                                  [1 v &lt;o v' ~&gt; V2 ]0 ~~  [1 v' ~&gt; V2 ]0 &lt;o  [1 v ~&gt; V2 ]0 .
<span class="keyword">Hypothesis</span> <span class="variable-name">consV11_bifunctorial</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : V(0 V1' |- V1 )0), <span class="type">forall</span> W1 W1' (<span class="variable-name">w</span> : V(0 W1 |- W1' )0),
                                    [0 V1' ~&gt; w ]1 &lt;o  [1 v ~&gt; W1 ]0 ~~ [1 v ~&gt; W1' ]0 &lt;o [0 V1 ~&gt; w ]1 .
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsV10</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v v'</span> : V(0 V1' |- V1)0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                           v' ~~ v -&gt; [1 v' ~&gt; V2 ]0 ~~ [1 v ~&gt; V2 ]0 .

<span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">polyF_unitF</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obF), <span class="type">forall</span> <span class="variable-name">X</span> : obF, (<span class="constant">@</span>IdenV (F[0 A ~&gt; X ]0)) ~~ DesIdenObR( F[1 (<span class="constant">@</span>unitF A) ~&gt; X ]0 ) .

<span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyF is injective **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">polyF_inputUnitF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                f  ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitF A) ).

<span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ) :=
  <span class="type">forall</span> (<span class="variable-name">C X</span> : obF),
    ( [0 F[0 A ~&gt; C ]0 ~&gt; &#966; X ]1
      &lt;o F[0 A ~&gt; - ]1 C X )
      ~~ ( [1 &#966; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
           &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

<span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                                 natural &#966; -&gt;
                                 <span class="type">forall</span> (<span class="variable-name">X</span> : obF),
                                   DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitF A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                             ~~ ( &#966; X ) .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyF_arrow ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyF, SymV, Cat1LeftV ].  
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyF_unitF ].
  <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                        natural &#966; -&gt; natural &#966;' -&gt;
                        &#966;' A &lt;o (<span class="constant">@</span>unitF A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitF A) -&gt;
                        <span class="type">forall</span> <span class="variable-name">X</span> : obF, &#966;' X ~~ &#966; X.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                           <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
  <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
  <span class="coq-solve-tactics">assumption</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                 natural &#966; -&gt;
                 <span class="type">forall</span> <span class="variable-name">X</span> : obF, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitF A) ) ~&gt; X ]0.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitF A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitF A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitF A) ).
  <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
  <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
  
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
  <span class="proof-tactics-name">apply</span> CongConsIdenObL.
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitF |  <span class="proof-tactics-name">apply</span> ReflV ].
<span class="keyword">Qed</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">polymorph functor</span></span><span class="doc"> **)</span>

<span class="keyword">Module</span> <span class="function-name">Functor</span>.
  
  <span class="doc">(** short : instead of describing F : catA --&gt; catB  then (contrast yoneda structures) describe catV[ V , catB[ B , F - ] ] : catA --&gt; catV **)</span>

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put some polymorph category A , note that unitA is lacked later</span></span><span class="doc">**)</span>

  <span class="keyword">Variable</span> <span class="variable-name">obA</span> : <span class="type">Type</span>.
  <span class="keyword">Variable</span> <span class="variable-name">polyA00</span> : obA -&gt; obA -&gt; obV.
  <span class="keyword">Notation</span> <span class="string">"A[0 A1 ~&gt; A2 ]0"</span> := (polyA00 A1 A2) (<span class="type">at</span> level 25).

  <span class="keyword">Parameter</span> <span class="variable-name">polyA</span> : <span class="type">forall</span> (<span class="variable-name">A2</span> : obA), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A1</span> : obA),
                      V(0 V |- A[0 A2 ~&gt; A1 ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A1 ~&gt; X ]0  |- [0 V ~&gt; A[0 A2 ~&gt; X ]0 ]0 )0.

  <span class="doc">(** therefore "A[1 f ~&gt; X ]0" is similar to ( f o&gt; _ ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"A[1 f ~&gt; X ]0"</span> := (<span class="constant">@</span>polyA _ _ _ f X) (<span class="type">at</span> level 25).

  <span class="doc">(** therefore "A[0 X ~&gt; g ]1" is similar to the common ( _ &lt;o g ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"A[0 X ~&gt; g ]1"</span> := (<span class="constant">@</span>polyA _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">g</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

  <span class="keyword">Definition</span> <span class="function-name">polyA_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 A[0 B ~&gt; A ]0 ~&gt; A[0 B ~&gt; X ]0 ]0 )0
    := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyA B (A[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (A[0 B ~&gt; A ]0)) X).
  <span class="keyword">Notation</span> <span class="string">"A[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyA_IdenV B) (<span class="type">at</span> level 25).

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put some polymorph category B , note that unitB is not lacked</span></span><span class="doc">  **)</span>

  <span class="keyword">Variable</span> <span class="variable-name">obB</span> : <span class="type">Type</span>.
  <span class="keyword">Variable</span> <span class="variable-name">polyB00</span> : obB -&gt; obB -&gt; obV.
  <span class="keyword">Notation</span> <span class="string">"B[0 B1 ~&gt; B2 ]0"</span> := (polyB00 B1 B2) (<span class="type">at</span> level 25).

  <span class="keyword">Parameter</span> <span class="variable-name">polyB</span> : <span class="type">forall</span> (<span class="variable-name">B2</span> : obB), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B1</span> : obB),
                      V(0 V |- B[0 B2 ~&gt; B1 ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">Y</span> : obB, V(0 B[0 B1 ~&gt; Y ]0  |- [0 V ~&gt; B[0 B2 ~&gt; Y ]0 ]0 )0.

  <span class="doc">(** therefore "B[1 m ~&gt; Y ]0" is similar to ( m o&gt; _ ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"B[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyB _ _ _ m Y) (<span class="type">at</span> level 25).

  <span class="doc">(** therefore "B[0 Y ~&gt; n ]1" is similar to the common ( _ &lt;o n ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"B[0 Y ~&gt; n ]1"</span> := (<span class="constant">@</span>polyB _ _ _ (<span class="constant">@</span>IdenV _) Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- B[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25).

  <span class="keyword">Definition</span> <span class="function-name">polyB_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB), <span class="type">forall</span> (<span class="variable-name">A</span> : obB),
                           <span class="type">forall</span> <span class="variable-name">X</span> : obB, V(0 B[0 A ~&gt; X ]0  |- [0 B[0 B ~&gt; A ]0 ~&gt; B[0 B ~&gt; X ]0 ]0 )0
    := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyB B (B[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (B[0 B ~&gt; A ]0)) X).
  <span class="keyword">Notation</span> <span class="string">"B[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyB_IdenV B) (<span class="type">at</span> level 25).

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get some polymorph funtor F</span></span><span class="doc"> **)</span>

  <span class="keyword">Variable</span> <span class="variable-name">polyF0</span> : obA -&gt; obB.
  <span class="keyword">Notation</span> <span class="string">"F|0 A"</span> := (polyF0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

  <span class="comment-delimiter">(*</span><span class="comment"> want B[ B , F A1] -&gt; forall A2, A[ A1 , A2] -&gt; B[ B , F A2 ] </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">       (F|1 _2 ) &lt;o _1   ...   _1 o&gt; (F|1 _2)      </span><span class="comment-delimiter">*)</span>

  <span class="keyword">Parameter</span> <span class="variable-name">polyF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                      V(0 V |- B[0 B ~&gt; F|0 A ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; B[0 B ~&gt; F|0 X ]0 ]0 )0.

  <span class="doc">(** :^) **)</span>
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (B[0 B ~&gt; F|0 A ]0) (<span class="type">at</span> level 25).
  
  <span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to   ( b o&gt; ( F|1 _ ) )   , alternatively   ( b o&gt;F _ )   **)</span>
  <span class="keyword">Notation</span> <span class="string">"F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ _ _ b X) (<span class="type">at</span> level 25).

  <span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to   ( B[0 B ~&gt; ( F|1 a ) ]1 ) which is ( _ o&gt; ( F|1 a ) )   , alternatively  ( _ o&gt;F a )   **)</span>
  <span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

  <span class="doc">(** NOT LACKED, may attempt
  (* for now, unitB for this notation only *)
  Parameter unitB : forall {B : obB}, V(0 I |- B[0 B ~&gt; B ]0 )0.
  Notation "'uB'" := (</span><span class="constant"><span class="doc">@</span></span><span class="doc">unitB _) (at level 0).
  (* approximative notation, may require input (g : V(0 I |- A[0 A ~&gt; X ]0 )0) but not really more progress,
      and may transform output to cancel ( [0 I ~&gt;  _ ]0 ) and now more progress *)
  Notation "F|1 a" := (DesIdenObR ([1 uB ~&gt; _ ]0 &lt;o F[0 _ ~&gt; a ]1)) (at level 5, right associativity) .
  Check (fun (W : obV) (A X : obA) (a : V(0 W |- A[0 A ~&gt; X ]0 )0) =&gt; F|1 a).
   **)</span>
  
  <span class="doc">(** related to correspondence with the common representation **)</span>
  <span class="keyword">Variable</span> <span class="variable-name">polyF_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                           F[1 f &lt;o v ~&gt; X ]0
                            ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 .

  <span class="doc">(** related to associativity, polyF_morphism says that, put the parameter f and the modifier argument g, then get
           (outer modification)    ( (f ) o&gt;F g ) o&gt;F _  =  f o&gt;F ( g o&gt; _ )    (inner modification)
which is, holding only f as parameter and running all the arguments,
           (outer modification)    ( (f ) o&gt;F _1 ) o&gt;F _2  =  f o&gt;F ( _1 o&gt; _2 )    (inner modification)
   **)</span>
  <span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
  <span class="keyword">Variable</span> <span class="variable-name">polyF_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB),
                            <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                            <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                              F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                               ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 ).

  <span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
    := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF (F[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) X).
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV B) (<span class="type">at</span> level 25).

  <span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, polyF f' X ~~ polyF f X.

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF are contained in natural transformations</span></span><span class="doc"> **)</span>

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                        <span class="type">forall</span> (<span class="variable-name">V W V'</span> : obV) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                          F[1 f &lt;o (Des v) ~&gt; X ]0
                           ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> polyF_arrow ].
    <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_monoV.
  <span class="keyword">Qed</span>.

  <span class="doc">(** polyF_natural (sym) says that, put the parameter f, then get
           (outer modification)    ( f o&gt;F _2 ) o&gt;F _1  =  f o&gt;F ( _2 o&gt; _1 )    (inner modification)
and this is codeductible with polyF_morphism above which says that, put the parameter f, then get
           (outer modification)    ( (f ) o&gt;F _1 ) o&gt;F _2  =  f o&gt;F ( _1 o&gt; _2 )    (inner modification)
now memo that in the left hand sides there is permutation of inputs, and that in the right hand sides there is permutation of inputs,  **)</span>
  <span class="doc">(** written here :   (inner modification) ~~ (outer modification) **)</span>
  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                        <span class="type">forall</span> (<span class="variable-name">C X</span> : obA),
                          ( [0 A[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                            &lt;o A[0 A ~&gt; - ]1 C X )
                            ~~ ( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .
  <span class="keyword">Proof</span>.
    <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
    <span class="proof-tactics-name">apply</span> CongConsIn.

    <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (A[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0
                     ~~ DesIn( [0 A[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[0 A ~&gt; - ]1 C X ) )
      <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) &lt;o f ~&gt; C ]0 ) ~&gt; X ]0
                     ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (A[0 A ~&gt; C ]0)) ]1 ) ~&gt; X ]0 )
      <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
           <span class="proof-tactics-name">apply</span> polyF_arrow ).

    <span class="comment-delimiter">(*</span><span class="comment"> convert right hand side : outer polyV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X )
                         ~~ DesIn( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) )
      <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
           <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
           <span class="proof-tactics-name">apply</span> polyV_arrow ).

    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; C ]0)) &lt;o Des( (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ) ~&gt; X ]0 )
                      ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X ) )
      <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

    <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

    <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
    
    <span class="proof-tactics-name">apply</span> ReflV.
  <span class="keyword">Qed</span>.

  <span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#946;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
    <span class="type">forall</span> (<span class="variable-name">C X</span> : obA),
      ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
        &lt;o A[0 A ~&gt; - ]1 C X )
        ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
             &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

  <span class="keyword">Lemma</span> <span class="function-name">polyF_natural_folded</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                                 natural (<span class="type">fun</span> <span class="variable-name">X</span> : obA =&gt; F[1 b ~&gt; X ]0).
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">unfold</span> natural.
    <span class="coq-solve-tactics">exact</span> polyF_natural.
  <span class="keyword">Qed</span>.

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF contains all natural transformations</span></span><span class="doc"> **)</span>

  <span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, polyA f' X ~~ polyA f X.

  <span class="keyword">Variable</span> <span class="variable-name">polyA_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                          <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                            A[1 f &lt;o v ~&gt; X ]0
                             ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0 .

  <span class="keyword">Parameter</span> <span class="variable-name">unitA</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obA}, V(0 I |- A[0 A ~&gt; A ]0 )0.
  <span class="keyword">Notation</span> <span class="string">"'uA'"</span> := (<span class="constant">@</span>unitA _) (<span class="type">at</span> level 0).

  <span class="keyword">Hypothesis</span> <span class="variable-name">polyA_unitA</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA), <span class="type">forall</span> <span class="variable-name">X</span> : obA, (<span class="constant">@</span>IdenV (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>unitA A) ~&gt; X ]0 ) .

  <span class="keyword">Hypothesis</span> <span class="variable-name">polyA_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                                  f  ~~ DesIdenObL( (A[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                                   natural &#966; -&gt;
                                   <span class="type">forall</span> (<span class="variable-name">X</span> : obA),
                                     DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitA A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                               ~~ ( &#966; X ) .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_arrow ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyA, SymV, Cat1LeftV ].  
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_unitA ].
    <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
  <span class="keyword">Qed</span>.

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                          natural &#966; -&gt; natural &#966;' -&gt;
                          &#966;' A &lt;o (<span class="constant">@</span>unitA A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitA A) -&gt;
                          <span class="type">forall</span> <span class="variable-name">X</span> : obA, &#966;' X ~~ &#966; X.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                             <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
    <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
    <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Qed</span>.

  <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;F 1 ) ~~ (f _i)  , 
       therefore polyF is injective **)</span>
  <span class="keyword">Hypothesis</span> <span class="variable-name">polyF_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                  f ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                   natural &#966; -&gt;
                   <span class="type">forall</span> <span class="variable-name">X</span> : obA, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA A) ) ~&gt; X ]0 .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitA A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitA A) ).
    <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
    <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
    
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
    <span class="proof-tactics-name">apply</span> CongConsIdenObL.
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitA |  <span class="proof-tactics-name">apply</span> ReflV ].
  <span class="keyword">Qed</span>.


  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">polymorph polytransformation</span></span><span class="doc"> **)</span>

  <span class="keyword">Module</span> <span class="function-name">Transformation</span>.

    <span class="doc">(** short : instead of describing &#966; A : G A -&gt; H A  then a-la-dosen (contrast weighted colimiting Kan extension) describe &#966; _f : catV( V , catB[ B , G A ] ) -&gt;  catV( V , catB[ B , H A ] ) **)</span>

    <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put some polymorph funtor G</span></span><span class="doc"> **)</span>

    <span class="keyword">Variable</span> <span class="variable-name">polyG0</span> : obA -&gt; obB.
    <span class="keyword">Notation</span> <span class="string">"G|0 A"</span> := (polyG0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

    <span class="keyword">Parameter</span> <span class="variable-name">polyG</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                        V(0 V |- B[0 B ~&gt; G|0 A ]0 )0 -&gt;
                        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; B[0 B ~&gt; G|0 X ]0 ]0 )0.

    <span class="keyword">Notation</span> <span class="string">"G[0 B ~&gt; A ]0"</span> := (B[0 B ~&gt; G|0 A ]0) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"G[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyG _ _ _ b X) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"G[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyG _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

    <span class="keyword">Variable</span> <span class="variable-name">polyG_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- G[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                             G[1 f &lt;o v ~&gt; X ]0
                              ~~ [1 v ~&gt; G[0 B ~&gt; X ]0 ]0 &lt;o G[1 f ~&gt; X ]0 .

    <span class="keyword">Variable</span> <span class="variable-name">polyG_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">V</span> : obV),
                              <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-G[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                G[1 Des( [1 f ~&gt; G[0 B ~&gt; A' ]0 ]0 &lt;o G[0 A' ~&gt; g ]1 ) ~&gt; X]0
                                 ~~  DesIn( [0 W ~&gt; G[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 ).

    <span class="keyword">Definition</span> <span class="function-name">polyG_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                             <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 G[0 B ~&gt; A ]0 ~&gt; G[0 B ~&gt; X ]0 ]0 )0
      := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyG (G[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (G[0 B ~&gt; A ]0)) X).
    <span class="keyword">Notation</span> <span class="string">"G[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyG_IdenV B) (<span class="type">at</span> level 25).

    <span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyG</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- G[0 B ~&gt; A ]0 )0),
                             f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, polyG f' X ~~ polyG f X.
    
    <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get some polymorph polytransformation &#946;</span></span><span class="doc"> **)</span>
    
    <span class="keyword">Parameter</span> <span class="variable-name">poly&#946;</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                        V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                        V(0 V |- G[0 B ~&gt; A ]0 )0 .

    <span class="doc">(** :^) **)</span>
    <span class="keyword">Notation</span> <span class="string">"&#946;|1 f"</span> := (<span class="constant">@</span>poly&#946; _ _ _ f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity).
    <span class="keyword">Notation</span> <span class="string">"&#946;|0 A"</span> := (<span class="constant">@</span>poly&#946; _ _ A (<span class="constant">@</span>IdenV _)) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

    <span class="keyword">Variable</span> <span class="variable-name">poly&#946;_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                             &#946;|1 (f &lt;o v)
                                 ~~ &#946;|1 f &lt;o v .

    <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
    <span class="keyword">Variable</span> <span class="variable-name">poly&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB),
                              <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                &#946;|1 (Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; a ]1 ))
                                    ~~ (Des( [1 &#946;|1 f ~&gt; G[0 B ~&gt; A' ]0 ]0 &lt;o G[0 A' ~&gt; a ]1 )) .

    <span class="keyword">Variable</span> <span class="variable-name">poly&#946;_morphism_codomain</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">W</span> : obV) (<span class="variable-name">B'</span> : obB) (<span class="variable-name">b</span> : V(0 W |- B[0 B' ~&gt; B]0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0),
                                         &#946;|1 (Des( B[1 b ~&gt; F|0 A ]0 &lt;o f ))
                                             ~~  Des( B[1 b ~&gt; G|0 A ]0 &lt;o &#946;|1 f ).

    <span class="doc">(** next :
     1. define naturality of any transformation of polymorph functors into catV
     2. show codeductibility of naturality for this transformation in catV with polymorphism (polymorph in V , B is easy) for the corresponding polytransformation
     3. define composition of polymorph functors, view [0 V0 ~&gt; F[0 B0 ~&gt; - ]0 ]0 as coming from composite polymorph functors
     4. confirm old naturality signify new naturality of the transformation F[1 (f0 : V(0 V0 |- F[0 B0 ~&gt; A0 ]0 )0) ~&gt; - ]0 between these polymorph functors on top of A[0 A0 ~&gt; - ]0 (which is polyA) and on top of [0 V0 ~&gt; F[0 B0 ~&gt; - ]0 ]0 (which is composite of polyV with polyF)
     5. rewrite the yoneda lemma as saying that the image is precisely any transformation whose corresponding polytransformation is polymorph
     **)</span>

    <span class="doc">(** alternatively, more immediately and particularly, show that poly_of_this_transf below satisfies poly&#946;_arrow (easy) and poly&#946;_morphism_codomain (easy) and poly&#946;_morphism (from old naturality) **)</span>
    <span class="keyword">Definition</span> <span class="function-name">poly_of_this_transf</span> : <span class="type">forall</span> (<span class="variable-name">A0</span> : obA) (<span class="variable-name">V0</span> : obV) (<span class="variable-name">B0</span> : obB) (<span class="variable-name">f0</span> : V(0 V0 |- F[0 B0 ~&gt; A0 ]0 )0),
                                     <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">U</span> : obV) (<span class="variable-name">A</span> : obA),
                                       V(0 V |- V[0 U ~&gt; A[0 A0 ~&gt; A ]0 ]0 )0 -&gt;
                                       V(0 V |- V[0 U ~&gt; [0 V0 ~&gt; F[0 B0 ~&gt; A ]0 ]0 ]0 )0
      := <span class="type">fun</span> (<span class="variable-name">A0</span> : obA) (<span class="variable-name">V0</span> : obV) (<span class="variable-name">B0</span> : obB) (<span class="variable-name">f0</span> : V(0 V0 |- F[0 B0 ~&gt; A0 ]0 )0)
         =&gt; <span class="type">fun</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">U</span> : obV) (<span class="variable-name">A</span> : obA)
           =&gt; <span class="type">fun</span> (<span class="variable-name">f</span> : V(0 V |- V[0 U ~&gt; A[0 A0 ~&gt; A ]0 ]0 )0)
             =&gt; [0 U ~&gt; F[1 f0 ~&gt; A ]0 ]1 &lt;o f .


    <span class="keyword">Section</span> <span class="function-name">FunctorComposition</span>.

      <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">composition of two polyfunctors,</span></span><span class="doc"> 
                  now put some polymorph category C , note that unitB is lacked  **)</span>

      <span class="keyword">Variable</span> <span class="variable-name">obC</span> : <span class="type">Type</span>.
      <span class="keyword">Variable</span> <span class="variable-name">polyC00</span> : obC -&gt; obC -&gt; obV.
      <span class="keyword">Notation</span> <span class="string">"C[0 C1 ~&gt; C2 ]0"</span> := (polyC00 C1 C2) (<span class="type">at</span> level 25).

      <span class="keyword">Parameter</span> <span class="variable-name">polyC</span> : <span class="type">forall</span> (<span class="variable-name">C2</span> : obC), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">C1</span> : obC),
                          V(0 V |- C[0 C2 ~&gt; C1 ]0 )0 -&gt;
                          <span class="type">forall</span> <span class="variable-name">Y</span> : obC, V(0 C[0 C1 ~&gt; Y ]0  |- [0 V ~&gt; C[0 C2 ~&gt; Y ]0 ]0 )0.

      <span class="doc">(** therefore "C[1 m ~&gt; Y ]0" is similar to ( m o&gt; _ ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"C[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyC _ _ _ m Y) (<span class="type">at</span> level 25).

      <span class="doc">(** therefore "C[0 Y ~&gt; n ]1" is similar to the common ( _ &lt;o n ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"C[0 Y ~&gt; n ]1"</span> := (<span class="constant">@</span>polyC _ _ _ (<span class="constant">@</span>IdenV _) Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- C[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">polyC_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">D</span> : obC), <span class="type">forall</span> (<span class="variable-name">C</span> : obC),
                               <span class="type">forall</span> <span class="variable-name">X</span> : obC, V(0 C[0 C ~&gt; X ]0  |- [0 C[0 D ~&gt; C ]0 ~&gt; C[0 D ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">D C X</span> =&gt; <span class="constant">@</span>polyC D (C[0 D ~&gt; C ]0) C (<span class="constant">@</span>IdenV (C[0 D ~&gt; C ]0)) X).
      <span class="keyword">Notation</span> <span class="string">"C[0 C ~&gt; - ]1"</span> := (<span class="constant">@</span>polyC_IdenV C) (<span class="type">at</span> level 25).

      <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get some polymorph funtor F'</span></span><span class="doc"> **)</span>

      <span class="keyword">Variable</span> <span class="variable-name">polyF'0</span> : obB -&gt; obC.
      <span class="keyword">Notation</span> <span class="string">"F'|0 B"</span> := (polyF'0 B) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).
      <span class="keyword">Notation</span> <span class="string">"F'[0 C ~&gt; B ]0"</span> := (C[0 C ~&gt; F'|0 B ]0) (<span class="type">at</span> level 25).
      <span class="keyword">Parameter</span> <span class="variable-name">polyF'</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">C</span> : obC) (<span class="variable-name">B</span> : obB),
                           V(0 V |- F'[0 C ~&gt; B ]0 )0 -&gt;
                           <span class="type">forall</span> <span class="variable-name">X</span> : obB, V(0 B[0 B ~&gt; X ]0  |- [0 V ~&gt; F'[0 C ~&gt; X ]0 ]0 )0.
      <span class="keyword">Notation</span> <span class="string">"F'[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF' _ _ _ b X) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"F'[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF' _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- B[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">polyF'_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">C</span> : obC) (<span class="variable-name">B</span> : obB),
                                <span class="type">forall</span> <span class="variable-name">X</span> : obB, V(0 B[0 B ~&gt; X ]0  |- [0 F'[0 C ~&gt; B ]0 ~&gt; F'[0 C ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">C B X</span> =&gt; <span class="constant">@</span>polyF' (F'[0 C ~&gt; B ]0) C B (<span class="constant">@</span>IdenV (F'[0 C ~&gt; B ]0)) X).
      <span class="keyword">Notation</span> <span class="string">"F'[0 C ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF'_IdenV C) (<span class="type">at</span> level 25).
      
      <span class="doc">(**             c o&gt;F'F a  =  c o&gt;F' (1 o&gt;F a)   ...   c o&gt;F' (b o&gt;F a) = (c o&gt;F' b) o&gt;F'F a ,       b : _ -&gt; F _              
                         d o&gt;F'' (c o&gt;F' (b o&gt;F a))              catA -&gt; catB -&gt; catC -&gt; catD         **)</span>
      <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F</span> :
        <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
        <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 V |- B[0 B ~&gt; F|0 A ]0 )0),
        <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">C</span> : obC),
        <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- C[0 C ~&gt; F'|0 B]0 )0),
        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; [0 W ~&gt; C[0 C ~&gt; F'|0 F|0 X ]0 ]0 ]0 )0.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">eapply</span> ComV.
        <span class="proof-tactics-name">apply</span> (polyF b).
        <span class="proof-tactics-name">apply</span> consV01.
        <span class="proof-tactics-name">apply</span> (polyF' c). 
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
      <span class="comment-delimiter">(*</span><span class="comment">
(fun (V : obV) (B : obB) (A : obA) (b : V(0 V |- F[0 B ~&gt; A ]0 )0) 
   (W : obV) (C : obC) (c : V(0 W |- F'[0 C ~&gt; B ]0 )0) 
   (X : obA) =&gt; [0V ~&gt; F'[1 c ~&gt; F|0 X ]0 ]1 &lt;o F[1 b ~&gt; X ]0) </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

      <span class="doc">(************
       b : V( V |- B[ B ~&gt; FA] )  -&gt;
      a : B[ B ~&gt; A[ A ~&gt; X ] ] -&gt; [V ~&gt; B[ B ~&gt; F X ]]

      _ o&gt;B ((B[ b ~&gt; FX ] &lt;o F|1 A X) a)

      _ o&gt;B  (b o&gt;F a)

     (b' _j) o&gt;B  ((b _i) o&gt;F a)

                  _j |&gt; ( (b _i) o&gt; F (a _j) )  ....  (b _i) o&gt;F a

      catA -&gt; F: catB -&gt; F': catC , and catA enriched in catB, and catB enriched in catC enriched in catV
      b : V(V |- C[ C |- B[ B ~&gt; F A] ] )  -&gt;
      a : C[ C ~&gt; B[ B ~&gt; A[ A ~&gt; X ] ] ] -&gt; [V ~&gt; C[ C ~&gt; B[ B ~&gt; F X ]]]                                                                 
                 _j |&gt; ( (b _i _i') o&gt; F (a _i' _j) )  ....  (b _i _i') o&gt;F a

      c : V( W |- C[ C' ~&gt; F' B] )  -&gt;
      b' : C[ C' ~&gt; B[ B ~&gt; Y ] ] -&gt; [W ~&gt; C[ C' ~&gt; F' Y ]]

      given only map on objects F|0, F'|0, define any polyMorphism named polyG :
      b : V(V |- C[ C |- B[ B ~&gt; F|0 A] ] )  -&gt;
      c : V( W |- C[ C ~&gt; F'|0 B] )  -&gt;
      a : V( C[ C ~&gt; B[ B ~&gt; A[ A ~&gt; X ] ] ] |- [V ~&gt; [W ~&gt; C[ C ~&gt; F'|0 F|0 X ] ] ] )

       *****)</span>                                              
      
      
      <span class="keyword">Parameter</span> <span class="variable-name">unitB</span> : <span class="type">forall</span> {<span class="variable-name">B</span> : obB}, V(0 I |- B[0 B ~&gt; B ]0 )0.
      <span class="keyword">Notation</span> <span class="string">"'uB'"</span> := (<span class="constant">@</span>unitB _) (<span class="type">at</span> level 0).

      <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F_simple</span> :
        <span class="type">forall</span>  (<span class="variable-name">A</span> : obA),
        <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">C</span> : obC),
        <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- C[0 C ~&gt; F'|0 F|0 A ]0 )0),
        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 W ~&gt; C[0 C ~&gt; F'|0 F|0 X ]0 ]0 )0.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">apply</span> DesIdenObR.
        <span class="proof-tactics-name">eapply</span> composition_F'_after_F.
        <span class="proof-tactics-name">eapply</span> unitB.
        <span class="coq-solve-tactics">exact</span> c.
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
      <span class="comment-delimiter">(*</span><span class="comment">
(fun (A : obA) (W : obV) (C : obC) (c : V(0 W |- F'[0 C ~&gt; F|0 A ]0 )0)
   (X : obA) =&gt; DesIdenObR (composition_F'_after_F uB c X))
       </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

      <span class="keyword">Notation</span> <span class="string">"F'F|0 B"</span> := (F'|0 F|0 B) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).
      <span class="keyword">Notation</span> <span class="string">"F'F[0 C ~&gt; A ]0"</span> := (C[0 C ~&gt; F'F|0 A ]0) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"F'F[1 c ~&gt; X ]0"</span> := (<span class="constant">@</span>composition_F'_after_F _ _ _ c X) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"F'F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>composition_F'_after_F _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">C</span> : obC) (<span class="variable-name">A</span> : obA),
                                                <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 F'F[0 C ~&gt; A ]0 ~&gt; F'F[0 C ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">C A X</span> =&gt; <span class="constant">@</span>composition_F'_after_F_simple A (F'F[0 C ~&gt; A ]0) C (<span class="constant">@</span>IdenV (F'F[0 C ~&gt; A ]0)) X).
      <span class="keyword">Notation</span> <span class="string">"F'F[0 C ~&gt; - ]1"</span> := (<span class="constant">@</span>composition_F'_after_F_IdenV C) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">polyF_unitB</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- B[0 F|0 A ~&gt; F|0 X ]0 )0.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">apply</span> DesIdenObR.
        <span class="proof-tactics-name">apply</span> polyF.
        <span class="proof-tactics-name">apply</span> unitB.
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
        <span class="comment-delimiter">(*</span><span class="comment"> (fun A X : obA =&gt; DesIdenObR (F[1 uB ~&gt; X ]0))  </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

      <span class="comment-delimiter">(*</span><span class="comment"> F|1 is internal structural arrow , but F[0 B ~&gt; - ]1 are external structural arrows</span><span class="comment-delimiter">*)</span>
      <span class="keyword">Notation</span> <span class="string">"F|1"</span> := (<span class="constant">@</span>polyF_unitB) (<span class="type">at</span> level 0).

      <span class="keyword">Lemma</span> <span class="function-name">composition_F'_after_F_identitary_polyF'_identitary_polyF_unitary</span> :    <span class="type">forall</span> (<span class="variable-name">C</span> : obC) (<span class="variable-name">A X</span> : obA),
                                                                                     (F'[0 C ~&gt; - ]1) F|0 A F|0 X &lt;o F|1 A X ~~ (F'F[0 C ~&gt; - ]1) A X.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_IdenV.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_simple.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F.
        <span class="proof-tactics-name">unfold</span> polyF'_IdenV.
        <span class="proof-tactics-name">unfold</span> polyF_unitB.
        <span class="proof-tactics-name">apply</span> SymV, DesIdenObR_output.
      <span class="keyword">Qed</span>.
    <span class="comment-delimiter">(*</span><span class="comment"> apply this to unfold this as identitary (external-structural) of composition of polyfunctors ( polyV o (poly_of_meta F[0 B ~&gt; - ]1) ) .. ( polyV o (poly_of_meta metaFB) )  ...  show before that
1. NEXT1 some metafunctor metaFB into catV on top of F[0 B ~&gt; - ]1  by polyF which becomes  metaFB := meta_of_poly F at B,
2. then get derived polyfunctor from this metafunctor, 
3. then unitary( |1 ) of this derived polyfunctor is  identitary( ||1 ) of the metafunctor metaFB on top of F[0 B ~&gt; - ]1 
4. NEXT2 which is  identitary ( [B ~&gt; - ]1 ) of original polyfunctor F
 
all: ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A' X   
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (meta_of_poly F at B)||1 A' X    
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o FB||1 A' X    
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (poly_of_meta metaFB)|1 A' X
       (polyV o (poly_of_meta metaFB))[0 V ~&gt; - ]1 A' X
       (meta_of_poly (polyV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X

  Definition natural (V : obV) (B : obB) (A : obA) (&#946; : forall X : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
                        forall (C X : obA),
                          ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
                            &lt;o A[0 A ~&gt; - ]1 C X )
                            ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

  Definition natural (V : obV) (B : obB) (A : obA) 
                        (&#946; : forall X : obA, V(0 (meta_of_poly polyA at A)|0 X  |- (meta_of_poly (polyV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X )0) :=
                        forall (A' X : obA),
                          ( [0 (meta_of_poly polyA at A)|0 A' ~&gt; &#946; X ]1
                            &lt;o (meta_of_poly polyA at A)||1 A' X )
                            ~~ ( [1 &#946; A' ~&gt; (meta_of_poly (polyV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X ]0
                                 &lt;o (meta_of_poly (polyV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X ) .
      ... == natural_metatransformation from (meta_of_poly polyA at A) to (meta_of_poly (polyV o (poly_of_meta (meta_of_poly F at B))) at V) by &#946; at A' at X

NEXT3: naturality of any metatransformation of any metafunctors &lt;-&gt; polymorphism of coresp polytransformation of coresp polyfuntors
NEXT4: rewrite natural as above

     </span><span class="comment-delimiter">*)</span>

      
      
    <span class="keyword">End</span>  <span class="function-name">FunctorComposition</span>.
    
    <span class="keyword">Section</span> <span class="function-name">MetaTransformation</span>.

      <span class="keyword">Section</span> <span class="function-name">Meta_of_poly</span>.
        
        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">meta_of_polyF_at_B , metafunctor FB on top of F[0 B ~&gt; - ]1</span></span><span class="doc"> **)</span>

        <span class="keyword">Variable</span> <span class="variable-name">B</span> : obB.

        <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B0</span> : obA -&gt; obV
          := <span class="type">fun</span> <span class="variable-name">A</span> : obA =&gt; F[0 B ~&gt; A ]0 .
        <span class="keyword">Notation</span> <span class="string">"FB|0 A"</span> := (meta_of_polyF_at_B0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)  (<span class="variable-name">A</span> : obA),
                                          V(0 V |- FB|0 A )0 -&gt;
                                          <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; FB|0 X ]0 )0
          := (<span class="type">fun</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0) (<span class="variable-name">X</span> : obA) =&gt;
                <span class="constant">@</span>polyF V B A f X <span class="comment-delimiter">(*</span><span class="comment"> F[1 f ~&gt; X ]0 </span><span class="comment-delimiter">*)</span> ) .
        <span class="comment-delimiter">(*</span><span class="comment"> intros. unfold meta_of_polyF_at_B0. apply polyF. assumption.
        Show Proof. </span><span class="comment-delimiter">*)</span>

        <span class="keyword">Notation</span> <span class="string">"FB[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>meta_of_polyF_at_B _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 FB|0 A ~&gt; FB|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>meta_of_polyF_at_B _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"FB||1"</span> := (<span class="constant">@</span>meta_of_polyF_at_B_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Lemma</span>  <span class="function-name">Cong_meta_of_polyF_at_B</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- FB|0 A )0),
                                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, FB[1I f' ~&gt; X ]0 ~~ FB[1I f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">apply</span> CongPolyF. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0) (<span class="variable-name">X</span> : obA),
                                           FB[1I f &lt;o v ~&gt; X ]0
                                             ~~ [1 v ~&gt; FB|0 X ]0 &lt;o FB[1I f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">apply</span> polyF_arrow.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                            <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                            <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-FB|0 A )0) (<span class="variable-name">X</span> : obA),
                                              FB[1I Des( [1 f ~&gt; FB|0 A' ]0 &lt;o (FB||1 &lt;o g) ) ~&gt; X]0
                                                ~~  DesIn( [0 W ~&gt; FB[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B.  <span class="proof-tactics-name">intros</span>.
          <span class="comment-delimiter">(*</span><span class="comment">TODO ERASE this line later </span><span class="comment-delimiter">*)</span> <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, DesIn_Input|];
          <span class="proof-tactics-name">apply</span> polyF_morphism.
        <span class="keyword">Qed</span>.

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;FB 1 ) ~~ (f _i)  , 
       therefore metaFB is injective **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0),
                                        f ~~ DesIdenObL( (FB[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">apply</span> polyF_inputUnitA.
        <span class="keyword">Qed</span>.
                    
        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_identitary_polyF_identitary</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                                               <span class="type">forall</span> <span class="variable-name">X</span> : obA,  FB||1 ~~ F[0 B ~&gt; - ]1 A X .
        <span class="keyword">Proof</span>. 
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B_IdenV. <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">unfold</span> polyF_IdenV .
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> ReflV.
        <span class="keyword">Qed</span>.

      <span class="keyword">End</span> <span class="function-name">Meta_of_poly</span>.

      <span class="keyword">Section</span> <span class="function-name">Poly_of_meta</span>.

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">poly_of_metaP of metaP</span></span><span class="doc"> **)</span>
        
        <span class="keyword">Parameter</span> <span class="variable-name">metaP0</span> : obA -&gt; obV.
        <span class="keyword">Notation</span> <span class="string">"P|0 A"</span> := (metaP0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Parameter</span> <span class="variable-name">metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                            V(0 V |- P|0 A )0 -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; P|0 X ]0 )0.

        <span class="keyword">Notation</span> <span class="string">"P[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>metaP _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">metaP_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 P|0 A ~&gt; P|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>metaP _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"P||1"</span> := (<span class="constant">@</span>metaP_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongMetaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- P|0 A )0),
                                 f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, P[1I f' ~&gt; X ]0 ~~ P[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaP_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                 <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P|0 A )0) (<span class="variable-name">X</span> : obA),
                                   P[1I f &lt;o v ~&gt; X ]0
                                    ~~ [1 v ~&gt; P|0 X ]0 &lt;o P[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaP_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P|0 A )0) (<span class="variable-name">X</span> : obA),
                                      P[1I Des( [1 f ~&gt; P|0 A' ]0 &lt;o (P||1 &lt;o g) ) ~&gt; X]0
                                       ~~  DesIn( [0 W ~&gt; P[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 .

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;P 1 ) ~~ (f _i)  , 
       therefore metaP is injective **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">metaP_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P|0 A )0),
                                        f ~~ DesIdenObL( (P[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
        <span class="comment-delimiter">(*</span><span class="comment">      (** ??? this is extra for metafunctor than polyfunctor : related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h     ....     ( 1 o&gt; # ) ~~ #  ??? **)
      Hypothesis metaP_unitB : forall (B : obB), forall X : obA, (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV (P[0 B ~&gt; X ]0)) ~~ DesIdenObR( P[1I (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitB B) ~&gt; X ]0 ) .         </span><span class="comment-delimiter">*)</span>
        <span class="keyword">Notation</span> <span class="string">"P[0 B ~&gt; A ]0"</span> := (V[0 B ~&gt; P|0 A ]0) (<span class="type">at</span> level 25).
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- P[0 B ~&gt; A ]0 )0 -&gt;
                                     <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; P[0 B ~&gt; X ]0 ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA) =&gt;
               ConsIn (P[1I Des b ~&gt; X ]0). 

        <span class="keyword">Notation</span> <span class="string">"P[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>poly_of_metaP _ _ _ b X) (<span class="type">at</span> level 25).
        <span class="keyword">Notation</span> <span class="string">"P[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>poly_of_metaP _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Input</span> : <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">V W</span> : obV) (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), 
                                 Des( v &lt;o w ) ~~ Des( v ) &lt;o desV10 V w .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV), <span class="type">forall</span> (<span class="variable-name">U1 U1'</span> : obV) (<span class="variable-name">u1</span> : V(0 U1' |- U1 )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                     ConsIn( [1 (1 u1 * V )0 ~&gt; W ]0 &lt;o v ) ~~ [1 u1 ~&gt; [0 V ~&gt; W ]0 ]0 &lt;o ConsIn( v ) .
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      P[1 f &lt;o v ~&gt; X ]0
                                       ~~ [1 v ~&gt; P[0 B ~&gt; X ]0 ]0 &lt;o P[1 f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">apply</span> ConsIn_Output.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">Cong_poly_of_metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                   <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                     f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, P[1 f' ~&gt; X ]0 ~~ P[1 f ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.  <span class="proof-tactics-name">apply</span> CongConsIn, CongMetaP, CongDes. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongConsV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> (<span class="variable-name">V2 V2'</span> : obV) (<span class="variable-name">v v'</span> : V(0 V2 |- V2' )0),
                                   v' ~~ v -&gt; [0 V1 ~&gt; v' ]1 ~~ [0 V1 ~&gt; v ]1 .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                                    ConsIn( v &lt;o i ) ~~ (ConsIn v) &lt;o i .
        <span class="keyword">Hypothesis</span> <span class="variable-name">consV01_functorial</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : V(0 V2 |- V2' )0), <span class="type">forall</span> V2'' (<span class="variable-name">v'</span> : V(0 V2' |- V2'' )0),
                                          [0 V1 ~&gt; v' &lt;o v ]1 ~~  [0 V1 ~&gt; v' ]1 &lt;o  [0 V1  ~&gt; v ]1 .
        <span class="keyword">Parameter</span> <span class="variable-name">Cons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 (0 U * V )0 |-  W )0 -&gt; V(0 U |-  [0 V ~&gt; W ]0 )0.
        <span class="keyword">Hypothesis</span> <span class="variable-name">CongCons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 (0 U * V )0 |- W )0 ),
                                v' ~~ v -&gt; Cons v' ~~ Cons v.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Des</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U |-  [0 V ~&gt; W ]0 )0),
                                Cons (Des f) ~~ f.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">v</span> : V(0 (0 U * V )0 |- W )0),
                                  Cons(v &lt;o desV10 V w)  ~~ Cons( v ) &lt;o w .
        <span class="keyword">Hypothesis</span> <span class="variable-name">DesIn_ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                    DesIn (ConsIn f) ~~ f.

        <span class="keyword">Parameter</span> <span class="variable-name">Assoc</span> : <span class="type">forall</span> {<span class="variable-name">V W</span> : obV}, <span class="type">forall</span> {<span class="variable-name">U</span>: obV}, V(0 (0 U * (0 V * W )0 )0 |- (0 ((0 U * V )0) * W )0 )0.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_Iso</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span>: obV),
                               <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV) (<span class="variable-name">f g</span> : V(0 Y |-  [0 (0 ((0 U * V )0) * W )0 ~&gt; X ]0 )0 ), 
                                 [1 Assoc ~&gt; X ]0 &lt;o f ~~ [1 Assoc  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_nat0</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">f</span> : V(0 U |- U' )0 ),
                                  Assoc &lt;o (1 f * (0 V * W )0 )0 ~~ (1 ((1 f * V )0) * W )0 &lt;o Assoc .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0) ,
                                              (Des ([1 Des (g &lt;o f) ~&gt; PA' ]0 ))
                                                ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))) ) &lt;o Assoc
                                                     : V(0 (0 ([0 QA ~&gt; PA' ]0) * (0V * B )0 )0 |- PA' )0 ).
        <span class="doc">(** Hypothesis Assoc_Des_Des_old : forall V B PA PA' (f : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                     ( (Des ([1 Des f ~&gt; PA' ]0 )) : V(0 (0 ([0 PA ~&gt; PA' ]0) * (0V * B )0 )0 |- PA' )0 )
                                       ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (</span><span class="constant"><span class="doc">@</span></span><span class="doc">IdenV ([0 B ~&gt; PA ]0)) ~&gt; PA' ]0))) ) &lt;o Assoc ). **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_DesIn_DesIn</span> :  <span class="type">forall</span> <span class="variable-name">W PX</span>, <span class="type">forall</span>  V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                          DesIn ([0 W ~&gt;  ([1 Des f ~&gt; PX ]0) ]1)
                                                ~~ [1 Assoc ~&gt; PX ]0 &lt;o DesIn( DesIn ([0 W ~&gt;  ConsIn([1 Des f ~&gt; PX ]0) ]1) ) .

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                         P[1 Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; g ]1 ) ~&gt; X ]0
                                          ~~  DesIn( [0 W ~&gt; P[1 f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="comment-delimiter">(*</span><span class="comment"> enough (  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ~~  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ) </span><span class="comment-delimiter">*)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
          <span class="proof-tactics-name">apply</span> CongConsIn, Assoc_Iso.

          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_ConsIn].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Cat1LeftV | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ConsIn_Input | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> Cat2V  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, SymV, Cat2V  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> SymV, Assoc_nat0 ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, SymV, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, Des_consV10_functorial  | <span class="proof-tactics-name">eapply</span> ReflV] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsV10, CongDes, SymV, Cat1LeftV ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, SymV, Des_Input ] .

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, CongMetaP, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, SymV, metaP_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, SymV, ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, SymV, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> Assoc_DesIn_DesIn  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, metaP_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, CongMetaP, Cat1LeftV  |].

          <span class="proof-tactics-name">eapply</span> metaP_morphism.
        <span class="keyword">Qed</span>.
        
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 P[0 B ~&gt; A ]0 ~&gt; P[0 B ~&gt; X ]0 ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>poly_of_metaP (P[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (P[0 B ~&gt; A ]0)) X).
        <span class="keyword">Notation</span> <span class="string">"P[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>poly_of_metaP_IdenV B) (<span class="type">at</span> level 25).

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">unit part of above get that the logical category V is polymorph</span></span><span class="doc"> **)</span>

        <span class="keyword">Parameter</span> <span class="variable-name">unitV</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obV}, V(0 I |- V[0 A ~&gt; A ]0 )0.
        <span class="keyword">Notation</span> <span class="string">"'uV'"</span> := (<span class="constant">@</span>unitV _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">unitV_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A</span> : obV,  (<span class="constant">@</span>IdenV A) ~~ DesIdenObL (<span class="constant">@</span>unitV A).

        <span class="keyword">Hypothesis</span> <span class="variable-name">polyV_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV), <span class="type">forall</span> <span class="variable-name">X</span> : obV, (<span class="constant">@</span>IdenV (V[0 A ~&gt; X ]0)) ~~ DesIdenObR( V[1 (<span class="constant">@</span>unitV A) ~&gt; X ]0 ) .

        <span class="keyword">Hypothesis</span> <span class="variable-name">polyV_inputUnitV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obV),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0),
                                        f  ~~ DesIdenObL( (V[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitV A) ).

        <span class="doc">(** already ConsIn_Input above **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">DesIdenObR_Input</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV) (<span class="variable-name">U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                        DesIdenObR( v &lt;o w ) ~~ DesIdenObR( v ) &lt;o w .

        <span class="keyword">Hypothesis</span> <span class="variable-name">consV10_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">U</span> : obV, <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0), 
                                          [1 DesIdenObL  v ~&gt; U ]0  ~~ DesIdenObR( ConsIn( [1 Des v ~&gt; U ]0 ) ) .

        <span class="keyword">Hypothesis</span> <span class="variable-name">consV10_functorial_fun1</span> : <span class="type">forall</span> <span class="variable-name">V1</span>, <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                                               (<span class="constant">@</span>IdenV _) ~~    [1 (<span class="constant">@</span>IdenV V1) ~&gt; V2 ]0 .

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">continue poly_of_metaP of metaP</span></span><span class="doc"> **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 P|0 A ~&gt; P|0 X ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; DesIdenObR(<span class="constant">@</span>poly_of_metaP I (P|0 A) A (<span class="constant">@</span>unitV _) X)).
        <span class="keyword">Notation</span> <span class="string">"P|1"</span> := (<span class="constant">@</span>poly_of_metaP_unitV _ _) (<span class="type">at</span> level 0).
        
        <span class="doc">(** poly_of_metaP_unitV_metaP_IdenV : forall A X : obA, P|1 ~~ P||1 **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_unitV_metaP_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, 
                                                  <span class="constant">@</span>poly_of_metaP_unitV A X ~~ <span class="constant">@</span>metaP_IdenV A X .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_metaP_unitV. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">unfold</span> metaP_IdenV.
          <span class="proof-tactics-name">eapply</span> TransV; cycle 1.
          <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaP, Cat1LeftV .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> SymV, consV10_DesIdenObL | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> SymV, Cat1LeftV.
        <span class="keyword">Qed</span>.

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">poly_of_metaQ of metaQ</span></span><span class="doc"> **)</span>

        <span class="keyword">Parameter</span> <span class="variable-name">metaQ0</span> : obA -&gt; obV.
        <span class="keyword">Notation</span> <span class="string">"Q|0 A"</span> := (metaQ0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Parameter</span> <span class="variable-name">metaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                            V(0 V |- Q|0 A )0 -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; Q|0 X ]0 )0.

        <span class="keyword">Notation</span> <span class="string">"Q[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>metaQ _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">metaQ_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 Q|0 A ~&gt; Q|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>metaQ _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"Q||1"</span> := (<span class="constant">@</span>metaQ_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongMetaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- Q|0 A )0),
                                 f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, Q[1I f' ~&gt; X ]0 ~~ Q[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaQ_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                 <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- Q|0 A )0) (<span class="variable-name">X</span> : obA),
                                   Q[1I f &lt;o v ~&gt; X ]0
                                    ~~ [1 v ~&gt; Q|0 X ]0 &lt;o Q[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaQ_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-Q|0 A )0) (<span class="variable-name">X</span> : obA),
                                      Q[1I Des( [1 f ~&gt; Q|0 A' ]0 &lt;o (Q||1 &lt;o g) ) ~&gt; X]0
                                       ~~  DesIn( [0 W ~&gt; Q[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 .

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;Q 1 ) ~~ (f _i)  , 
       therefore metaQ is injective **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">metaQ_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- Q|0 A )0),
                                        f ~~ DesIdenObL( (Q[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
        <span class="comment-delimiter">(*</span><span class="comment">      (** ??? this is extra for metafunctor than polyfunctor : related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h     ....     ( 1 o&gt; # ) ~~ #  ??? **)
      Hypothesis metaQ_unitB : forall (B : obB), forall X : obA, (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV (Q[0 B ~&gt; X ]0)) ~~ DesIdenObR( Q[1I (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitB B) ~&gt; X ]0 ) .         </span><span class="comment-delimiter">*)</span>
        <span class="keyword">Notation</span> <span class="string">"Q[0 B ~&gt; A ]0"</span> := (V[0 B ~&gt; Q|0 A ]0) (<span class="type">at</span> level 25).
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- Q[0 B ~&gt; A ]0 )0 -&gt;
                                     <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; Q[0 B ~&gt; X ]0 ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- Q[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA) =&gt;
               ConsIn (Q[1I Des b ~&gt; X ]0). 

        <span class="keyword">Notation</span> <span class="string">"Q[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>poly_of_metaQ _ _ _ b X) (<span class="type">at</span> level 25).
        <span class="keyword">Notation</span> <span class="string">"Q[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>poly_of_metaQ _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaQ_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- Q[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      Q[1 f &lt;o v ~&gt; X ]0
                                       ~~ [1 v ~&gt; Q[0 B ~&gt; X ]0 ]0 &lt;o Q[1 f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaQ, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, metaQ_arrow ].
          <span class="proof-tactics-name">apply</span> ConsIn_Output.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">Cong_poly_of_metaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                   <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- Q[0 B ~&gt; A ]0 )0),
                                     f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, Q[1 f' ~&gt; X ]0 ~~ Q[1 f ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.  <span class="proof-tactics-name">apply</span> CongConsIn, CongMetaQ, CongDes. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaQ_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-Q[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                         Q[1 Des( [1 f ~&gt; Q[0 B ~&gt; A' ]0 ]0 &lt;o Q[0 A' ~&gt; g ]1 ) ~&gt; X ]0
                                          ~~  DesIn( [0 W ~&gt; Q[1 f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="comment-delimiter">(*</span><span class="comment"> enough (  [1Assoc ~&gt; Q|0 X ]0 &lt;o DesIn ( _ ) ~~  [1Assoc ~&gt; Q|0 X ]0 &lt;o DesIn ( _ ) ) </span><span class="comment-delimiter">*)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
          <span class="proof-tactics-name">apply</span> CongConsIn, Assoc_Iso.

          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_ConsIn].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, metaQ_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaQ, Cat1LeftV | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, metaQ_arrow | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ConsIn_Input | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> Cat2V  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, SymV, Cat2V  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> SymV, Assoc_nat0 ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, SymV, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, Des_consV10_functorial  | <span class="proof-tactics-name">eapply</span> ReflV] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsV10, CongDes, SymV, Cat1LeftV ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, SymV, Des_Input ] .

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, CongMetaQ, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, SymV, metaQ_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, SymV, ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, SymV, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> Assoc_DesIn_DesIn  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, metaQ_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, CongMetaQ, Cat1LeftV  |].

          <span class="proof-tactics-name">eapply</span> metaQ_morphism.
        <span class="keyword">Qed</span>.
        
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaQ_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 Q[0 B ~&gt; A ]0 ~&gt; Q[0 B ~&gt; X ]0 ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>poly_of_metaQ (Q[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (Q[0 B ~&gt; A ]0)) X).
        <span class="keyword">Notation</span> <span class="string">"Q[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>poly_of_metaQ_IdenV B) (<span class="type">at</span> level 25).

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">continue poly_of_metaQ of metaQ</span></span><span class="doc"> **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaQ_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 Q|0 A ~&gt; Q|0 X ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; DesIdenObR(<span class="constant">@</span>poly_of_metaQ I (Q|0 A) A (<span class="constant">@</span>unitV _) X)).
        <span class="keyword">Notation</span> <span class="string">"Q|1"</span> := (<span class="constant">@</span>poly_of_metaQ_unitV _ _) (<span class="type">at</span> level 0).
        
        <span class="doc">(** poly_of_metaQ_unitV_metaQ_IdenV : forall A X : obA, Q|1 ~~ Q||1 **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaQ_unitV_metaQ_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, 
                                                  <span class="constant">@</span>poly_of_metaQ_unitV A X ~~ <span class="constant">@</span>metaQ_IdenV A X .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_metaQ_unitV. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">unfold</span> metaQ_IdenV.
          <span class="proof-tactics-name">eapply</span> TransV; cycle 1.
          <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaQ, Cat1LeftV .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaQ_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> SymV, consV10_DesIdenObL | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> SymV, Cat1LeftV.
        <span class="keyword">Qed</span>.

        
        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">now natural metatransformation</span></span><span class="doc"> **)</span>

        <span class="keyword">Parameter</span> <span class="variable-name">meta&#946;</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                            V(0 P|0 A |- Q|0 A )0.

        <span class="keyword">Notation</span> <span class="string">"&#946;||0 A"</span> := (<span class="constant">@</span>meta&#946; A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">meta&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA)  (<span class="variable-name">A'</span> : obA),
                                      [0 P|0 A ~&gt;  &#946;||0 A' ]1 &lt;o P||1
                                                                ~~ [1 &#946;||0 A ~&gt; Q|0 A' ]0 &lt;o Q||1.

        <span class="doc">(** Cons et al was here , Des_Input was here **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_meta&#946;</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- P[0 B ~&gt; A ]0 )0 -&gt;
                                     V(0 V |- Q[0 B ~&gt; A ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) =&gt;
               Cons (&#946;||0 A &lt;o Des b) .
        
        <span class="doc">(** :^) **)</span>
        <span class="keyword">Notation</span> <span class="string">"&#946;|1 f"</span> := (<span class="constant">@</span>poly_of_meta&#946; _ _ _ f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity).
        <span class="doc">(** this Notation "&#946;|0 A" is not held below **)</span>
        <span class="keyword">Notation</span> <span class="string">"&#946;|0 A"</span> := (<span class="constant">@</span>poly_of_meta&#946; _ _ A (<span class="constant">@</span>IdenV _)) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      &#946;|1 (f &lt;o v)
                                          ~~ &#946;|1 f &lt;o v .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_meta&#946;.
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cons_Input  |] .
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCons; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |] .
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCons; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV |  <span class="proof-tactics-name">eapply</span> Des_Input  ] |] .
          <span class="proof-tactics-name">eapply</span> ReflV.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> :  V(0 (0 U * V )0 |-  W )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                                   [0 V ~&gt; w ]1 &lt;o Cons( v ) ~~ Cons( w &lt;o v ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                                  Des( [0 V ~&gt; w ]1 &lt;o v ) ~~ w &lt;o Des( v ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Output2</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV), <span class="type">forall</span> (<span class="variable-name">U1</span> : obV) , <span class="type">forall</span> (<span class="variable-name">W W'</span> : obV) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                      ConsIn( [0 (0 U1 * V )0 ~&gt; w ]1 &lt;o v ) ~~ [0 U1 ~&gt; [0 V ~&gt; w ]1 ]1 &lt;o ConsIn( v ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0),
                                                 ( ConsIn (([1 Des (g &lt;o f) ~&gt; PA' ]0)) )
                                                   ~~ ( ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))
                                                        : V(0 [0 QA ~&gt; PA' ]0 |- [0 V ~&gt; [0 B ~&gt; PA' ]0 ]0 )0 ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Cons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 (0 U * V )0 |-  W )0),
                                Des (Cons f) ~~ f.
        
        <span class="doc">(** ?? may change def of funtor into V because now extra decoding while already in V ?? **)</span>
        <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                         &#946;|1 (Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; a ]1 ))
                                             ~~ (Des( [1 &#946;|1 f ~&gt; Q[0 B ~&gt; A' ]0 ]0 &lt;o Q[0 A' ~&gt; a ]1 )) .
        <span class="keyword">Proof</span>.
          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_meta&#946;. <span class="proof-tactics-name">unfold</span> poly_of_metaP. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV| <span class="proof-tactics-name">eapply</span> Cons_Des] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, ConsIn_consV10_functorial ].        
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  SymV, Des_Output ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, SymV, Cat2V].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2 ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> CongConsIn, consV11_bifunctorial ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|] ; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|] ; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> meta&#946;_morphism   ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDes; <span class="proof-tactics-name">eapply</span> SymV, Cat2V]. 
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V].

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> CongDes. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |]. <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn , CongMetaQ, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn , SymV, metaQ_arrow |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |].
          <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV].

          <span class="doc">(** more pure logic *)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10, CongDes, SymV, Cat1LeftV].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn; <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10,  SymV, Des_Cons ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10,  CongDes, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> ConsIn_consV10_functorial.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_morphism_codomain</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                                <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">W</span> : obV) (<span class="variable-name">B'</span> : obV) (<span class="variable-name">b</span> : V(0 W |- V[0 B' ~&gt; B]0 )0),
                                                <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P[0 B ~&gt; A ]0 )0),
                                                  &#946;|1 (Des( V[1 b ~&gt; P|0 A ]0 &lt;o f ))
                                                      ~~  Des( V[1 b ~&gt; Q|0 A ]0 &lt;o &#946;|1 f ).
        <span class="keyword">Proof</span>.
          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_meta&#946;.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV| <span class="proof-tactics-name">eapply</span> Cons_Des] ].

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> Cons_Output |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cons_Des |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_DesIn |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, polyV_monoV |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, Cat2V |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, consV11_bifunctorial |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, Cat1RightV |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2 |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> SymV, Des_Output  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, Cat2V |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, Cat1LeftV  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, polyV_monoV  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_DesIn  |].

          <span class="proof-tactics-name">eapply</span> ReflV.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_I_Iso</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                               <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV) (<span class="variable-name">f g</span> : V(0 Y |-  [0  A ~&gt; X ]0 )0 ), 
                                 [1 Des (<span class="constant">@</span>IdenV ([0 I ~&gt; A ]0)) ~&gt; X ]0 &lt;o f ~~ [1  Des (<span class="constant">@</span>IdenV ([0 I ~&gt; A ]0))  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .

        <span class="keyword">Lemma</span> <span class="function-name">meta_morphism_of_poly_of_meta&#946;</span> : ( <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV),
                                                 <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                                   &#946;|1 (Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; a ]1 ))
                                                       ~~ (Des( [1 &#946;|1 f ~&gt; Q[0 B ~&gt; A' ]0 ]0 &lt;o Q[0 A' ~&gt; a ]1 )) )
                                               -&gt; ( <span class="type">forall</span> (<span class="variable-name">A</span> : obA)  (<span class="variable-name">A'</span> : obA),
                                                     [0 P|0 A ~&gt;  &#946;||0 A' ]1 &lt;o P||1
                                                                               ~~ [1 &#946;||0 A ~&gt; Q|0 A' ]0 &lt;o Q||1 ) .
        <span class="keyword">Proof</span>.
          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">intro</span> H_poly_morphism. <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">specialize</span> H_poly_morphism <span class="type">with</span> (B := I) (A := A) (A' := A') (a := 1) (f := 1).
          <span class="proof-tactics-name">unfold</span> poly_of_meta&#946; <span class="type">in</span> H_poly_morphism. <span class="proof-tactics-name">unfold</span> poly_of_metaP <span class="type">in</span> H_poly_morphism. <span class="proof-tactics-name">unfold</span> poly_of_metaQ <span class="type">in</span> H_poly_morphism.
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cons_Des ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1 ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat1RightV ]. 
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsIn, CongMetaP, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Des_Output ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2   ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, SymV, ConsIn_Input   ].

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> CongCons <span class="type">in</span> H_poly_morphism.
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> Cons_Des]. <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> Cons_Des].
          <span class="proof-tactics-name">eapply</span>  TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat1RightV ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaQ, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn, metaQ_arrow].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> ConsIn_Input].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_consV10_functorial ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input].
          <span class="proof-tactics-name">eapply</span> CongDesIn <span class="type">in</span> H_poly_morphism.
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> DesIn_ConsIn]. <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> DesIn_ConsIn].        
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> CongConsV10, CongDes, SymV, Cat1LeftV].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> CongConsV10, Des_Cons].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> consV10_functorial].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> Cat2V].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> consV11_bifunctorial ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> Cat2V ].
          <span class="proof-tactics-name">eapply</span> Des_I_Iso <span class="type">in</span> H_poly_morphism.

          <span class="coq-solve-tactics">exact</span> H_poly_morphism.
        <span class="keyword">Qed</span>.
        
      <span class="keyword">End</span> <span class="function-name">Poly_of_meta</span>.

    <span class="keyword">End</span> <span class="function-name">MetaTransformation</span>.

    <span class="keyword">Module</span> <span class="function-name">NaturalityIsPolymorphic</span>.

      <span class="keyword">Variable</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA).

      <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">meta_of_polyF_at_B , metafunctor FB on top of F[0 B ~&gt; - ]1</span></span><span class="doc"> **)</span>

      <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B0</span> : obA -&gt; obV
        := <span class="type">fun</span> <span class="variable-name">A</span> : obA =&gt; F[0 B ~&gt; A ]0 .
      <span class="keyword">Notation</span> <span class="string">"FB|0 A"</span> := (meta_of_polyF_at_B0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

      <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)  (<span class="variable-name">A</span> : obA),
                                        V(0 V |- FB|0 A )0 -&gt;
                                        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; FB|0 X ]0 )0
        := (<span class="type">fun</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0) (<span class="variable-name">X</span> : obA) =&gt;
              <span class="constant">@</span>polyF V B A f X <span class="comment-delimiter">(*</span><span class="comment"> F[1 f ~&gt; X ]0 </span><span class="comment-delimiter">*)</span> ) .
      <span class="comment-delimiter">(*</span><span class="comment"> intros. unfold meta_of_polyF_at_B0. apply polyF. assumption.
        Show Proof. </span><span class="comment-delimiter">*)</span>

      <span class="keyword">Notation</span> <span class="string">"FB[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>meta_of_polyF_at_B _ _ b X) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 FB|0 A ~&gt; FB|0 X ]0 )0
        :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>meta_of_polyF_at_B _ A (<span class="constant">@</span>IdenV _) X).
      <span class="keyword">Notation</span> <span class="string">"FB||1"</span> := (<span class="constant">@</span>meta_of_polyF_at_B_IdenV _ _) (<span class="type">at</span> level 0).

      <span class="keyword">Lemma</span>  <span class="function-name">Cong_meta_of_polyF_at_B</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                                       <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- FB|0 A )0),
                                         f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, FB[1I f' ~&gt; X ]0 ~~ FB[1I f ~&gt; X ]0 .
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">apply</span> CongPolyF. <span class="coq-solve-tactics">assumption</span>.
      <span class="keyword">Qed</span>.

      <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                       <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0) (<span class="variable-name">X</span> : obA),
                                         FB[1I f &lt;o v ~&gt; X ]0
                                           ~~ [1 v ~&gt; FB|0 X ]0 &lt;o FB[1I f ~&gt; X ]0 .
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">apply</span> polyF_arrow.
      <span class="keyword">Qed</span>.

      <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                          <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-FB|0 A )0) (<span class="variable-name">X</span> : obA),
                                            FB[1I Des( [1 f ~&gt; FB|0 A' ]0 &lt;o (FB||1 &lt;o g) ) ~&gt; X]0
                                              ~~  DesIn( [0 W ~&gt; FB[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B.  <span class="proof-tactics-name">intros</span>.
        <span class="comment-delimiter">(*</span><span class="comment">TODO ERASE this line later </span><span class="comment-delimiter">*)</span> <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, DesIn_Input|];
                                        <span class="proof-tactics-name">apply</span> polyF_morphism.
      <span class="keyword">Qed</span>.

      <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;FB 1 ) ~~ (f _i)  , 
       therefore metaFB is injective **)</span>
      <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                            <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0),
                                              f ~~ DesIdenObL( (FB[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">apply</span> polyF_inputUnitA.
      <span class="keyword">Qed</span>.

      <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_identitary_polyF_identitary</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                                             <span class="type">forall</span> <span class="variable-name">X</span> : obA,  FB||1 ~~ F[0 B ~&gt; - ]1 A X .
      <span class="keyword">Proof</span>. 
        <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B_IdenV. <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">unfold</span> polyF_IdenV .
        <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> ReflV.
      <span class="keyword">Qed</span>.

      <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">poly_of_metaP of metaP</span></span><span class="doc"> **)</span>
        
        <span class="keyword">Definition</span> <span class="function-name">metaP0</span> : obA -&gt; obV := meta_of_polyF_at_B0.
        <span class="keyword">Notation</span> <span class="string">"P|0 A"</span> := (metaP0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Definition</span> <span class="function-name">metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                            V(0 V |- P|0 A )0 -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; P|0 X ]0 )0 := meta_of_polyF_at_B. 

        <span class="keyword">Notation</span> <span class="string">"P[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>metaP _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">metaP_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 P|0 A ~&gt; P|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>metaP _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"P||1"</span> := (<span class="constant">@</span>metaP_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Definition</span> <span class="function-name">CongMetaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- P|0 A )0),
                                 f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, P[1I f' ~&gt; X ]0 ~~ P[1I f ~&gt; X ]0 := Cong_meta_of_polyF_at_B .

        <span class="keyword">Definition</span> <span class="function-name">metaP_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                 <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P|0 A )0) (<span class="variable-name">X</span> : obA),
                                   P[1I f &lt;o v ~&gt; X ]0
                                    ~~ [1 v ~&gt; P|0 X ]0 &lt;o P[1I f ~&gt; X ]0 := meta_of_polyF_at_B_arrow.

        <span class="keyword">Definition</span> <span class="function-name">metaP_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P|0 A )0) (<span class="variable-name">X</span> : obA),
                                      P[1I Des( [1 f ~&gt; P|0 A' ]0 &lt;o (P||1 &lt;o g) ) ~&gt; X]0
                                       ~~  DesIn( [0 W ~&gt; P[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 := meta_of_polyF_at_B_morphism.

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;P 1 ) ~~ (f _i)  , 
       therefore metaP is injective **)</span>
        <span class="keyword">Definition</span> <span class="function-name">metaP_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P|0 A )0),
                                        f ~~ DesIdenObL( (P[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ) := meta_of_polyF_at_B_inputUnitA.
        <span class="comment-delimiter">(*</span><span class="comment">      (** ??? this is extra for metafunctor than polyfunctor : related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h     ....     ( 1 o&gt; # ) ~~ #  ??? **)
      Hypothesis metaP_unitB : forall (B : obB), forall X : obA, (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV (P[0 B ~&gt; X ]0)) ~~ DesIdenObR( P[1I (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitB B) ~&gt; X ]0 ) .         </span><span class="comment-delimiter">*)</span>
        <span class="keyword">Notation</span> <span class="string">"P[0 B ~&gt; A ]0"</span> := (V[0 B ~&gt; P|0 A ]0) (<span class="type">at</span> level 25).
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- P[0 B ~&gt; A ]0 )0 -&gt;
                                     <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; P[0 B ~&gt; X ]0 ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA) =&gt;
               ConsIn (P[1I Des b ~&gt; X ]0). 

        <span class="keyword">Notation</span> <span class="string">"P[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>poly_of_metaP _ _ _ b X) (<span class="type">at</span> level 25).
        <span class="keyword">Notation</span> <span class="string">"P[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>poly_of_metaP _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Input</span> : <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">V W</span> : obV) (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), 
                                 Des( v &lt;o w ) ~~ Des( v ) &lt;o desV10 V w .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV), <span class="type">forall</span> (<span class="variable-name">U1 U1'</span> : obV) (<span class="variable-name">u1</span> : V(0 U1' |- U1 )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                     ConsIn( [1 (1 u1 * V )0 ~&gt; W ]0 &lt;o v ) ~~ [1 u1 ~&gt; [0 V ~&gt; W ]0 ]0 &lt;o ConsIn( v ) .
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      P[1 f &lt;o v ~&gt; X ]0
                                       ~~ [1 v ~&gt; P[0 B ~&gt; X ]0 ]0 &lt;o P[1 f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">apply</span> ConsIn_Output.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">Cong_poly_of_metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                   <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                     f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, P[1 f' ~&gt; X ]0 ~~ P[1 f ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.  <span class="proof-tactics-name">apply</span> CongConsIn, CongMetaP, CongDes. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongConsV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> (<span class="variable-name">V2 V2'</span> : obV) (<span class="variable-name">v v'</span> : V(0 V2 |- V2' )0),
                                   v' ~~ v -&gt; [0 V1 ~&gt; v' ]1 ~~ [0 V1 ~&gt; v ]1 .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                                    ConsIn( v &lt;o i ) ~~ (ConsIn v) &lt;o i .
        <span class="keyword">Hypothesis</span> <span class="variable-name">consV01_functorial</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : V(0 V2 |- V2' )0), <span class="type">forall</span> V2'' (<span class="variable-name">v'</span> : V(0 V2' |- V2'' )0),
                                          [0 V1 ~&gt; v' &lt;o v ]1 ~~  [0 V1 ~&gt; v' ]1 &lt;o  [0 V1  ~&gt; v ]1 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongCons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 (0 U * V )0 |- W )0 ),
                                v' ~~ v -&gt; Cons v' ~~ Cons v.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Des</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U |-  [0 V ~&gt; W ]0 )0),
                                Cons (Des f) ~~ f.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">v</span> : V(0 (0 U * V )0 |- W )0),
                                  Cons(v &lt;o desV10 V w)  ~~ Cons( v ) &lt;o w .
        <span class="keyword">Hypothesis</span> <span class="variable-name">DesIn_ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                    DesIn (ConsIn f) ~~ f.


        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_Iso</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span>: obV),
                               <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV) (<span class="variable-name">f g</span> : V(0 Y |-  [0 (0 ((0 U * V )0) * W )0 ~&gt; X ]0 )0 ), 
                                 [1 Assoc ~&gt; X ]0 &lt;o f ~~ [1 Assoc  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_nat0</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">f</span> : V(0 U |- U' )0 ),
                                  Assoc &lt;o (1 f * (0 V * W )0 )0 ~~ (1 ((1 f * V )0) * W )0 &lt;o Assoc .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0) ,
                                              (Des ([1 Des (g &lt;o f) ~&gt; PA' ]0 ))
                                                ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))) ) &lt;o Assoc
                                                     : V(0 (0 ([0 QA ~&gt; PA' ]0) * (0V * B )0 )0 |- PA' )0 ).
        <span class="doc">(** Hypothesis Assoc_Des_Des_old : forall V B PA PA' (f : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                     ( (Des ([1 Des f ~&gt; PA' ]0 )) : V(0 (0 ([0 PA ~&gt; PA' ]0) * (0V * B )0 )0 |- PA' )0 )
                                       ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (</span><span class="constant"><span class="doc">@</span></span><span class="doc">IdenV ([0 B ~&gt; PA ]0)) ~&gt; PA' ]0))) ) &lt;o Assoc ). **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_DesIn_DesIn</span> :  <span class="type">forall</span> <span class="variable-name">W PX</span>, <span class="type">forall</span>  V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                          DesIn ([0 W ~&gt;  ([1 Des f ~&gt; PX ]0) ]1)
                                                ~~ [1 Assoc ~&gt; PX ]0 &lt;o DesIn( DesIn ([0 W ~&gt;  ConsIn([1 Des f ~&gt; PX ]0) ]1) ) .

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                         P[1 Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; g ]1 ) ~&gt; X ]0
                                          ~~  DesIn( [0 W ~&gt; P[1 f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="comment-delimiter">(*</span><span class="comment"> enough (  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ~~  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ) </span><span class="comment-delimiter">*)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
          <span class="proof-tactics-name">apply</span> CongConsIn, Assoc_Iso.

          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_ConsIn].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Cat1LeftV | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ConsIn_Input | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> Cat2V  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, SymV, Cat2V  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> SymV, Assoc_nat0 ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, SymV, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, Des_consV10_functorial  | <span class="proof-tactics-name">eapply</span> ReflV] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsV10, CongDes, SymV, Cat1LeftV ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, SymV, Des_Input ] .

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, CongMetaP, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, SymV, metaP_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, SymV, ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, SymV, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> Assoc_DesIn_DesIn  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, metaP_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, CongMetaP, Cat1LeftV  |].

          <span class="proof-tactics-name">eapply</span> metaP_morphism.
        <span class="keyword">Qed</span>.
        
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 P[0 B ~&gt; A ]0 ~&gt; P[0 B ~&gt; X ]0 ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>poly_of_metaP (P[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (P[0 B ~&gt; A ]0)) X).
        <span class="keyword">Notation</span> <span class="string">"P[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>poly_of_metaP_IdenV B) (<span class="type">at</span> level 25).

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">unit part of above get that the logical category V is polymorph</span></span><span class="doc"> **)</span>


        <span class="keyword">Notation</span> <span class="string">"'uV'"</span> := (<span class="constant">@</span>unitV _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">unitV_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A</span> : obV,  (<span class="constant">@</span>IdenV A) ~~ DesIdenObL (<span class="constant">@</span>unitV A).

        <span class="keyword">Hypothesis</span> <span class="variable-name">polyV_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV), <span class="type">forall</span> <span class="variable-name">X</span> : obV, (<span class="constant">@</span>IdenV (V[0 A ~&gt; X ]0)) ~~ DesIdenObR( V[1 (<span class="constant">@</span>unitV A) ~&gt; X ]0 ) .

        <span class="keyword">Hypothesis</span> <span class="variable-name">polyV_inputUnitV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obV),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0),
                                        f  ~~ DesIdenObL( (V[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitV A) ).

        <span class="doc">(** already ConsIn_Input above **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">DesIdenObR_Input</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV) (<span class="variable-name">U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                        DesIdenObR( v &lt;o w ) ~~ DesIdenObR( v ) &lt;o w .

        <span class="keyword">Hypothesis</span> <span class="variable-name">consV10_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">U</span> : obV, <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0), 
                                          [1 DesIdenObL  v ~&gt; U ]0  ~~ DesIdenObR( ConsIn( [1 Des v ~&gt; U ]0 ) ) .

        <span class="keyword">Hypothesis</span> <span class="variable-name">consV10_functorial_fun1</span> : <span class="type">forall</span> <span class="variable-name">V1</span>, <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                                               (<span class="constant">@</span>IdenV _) ~~    [1 (<span class="constant">@</span>IdenV V1) ~&gt; V2 ]0 .

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">continue poly_of_metaP of metaP</span></span><span class="doc"> **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 P|0 A ~&gt; P|0 X ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; DesIdenObR(<span class="constant">@</span>poly_of_metaP I (P|0 A) A (<span class="constant">@</span>unitV _) X)).
        <span class="keyword">Notation</span> <span class="string">"P|1"</span> := (<span class="constant">@</span>poly_of_metaP_unitV _ _) (<span class="type">at</span> level 0).
        
        <span class="doc">(** poly_of_metaP_unitV_metaP_IdenV : forall A X : obA, P|1 ~~ P||1 **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_unitV_metaP_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, 
                                                  <span class="constant">@</span>poly_of_metaP_unitV A X ~~ <span class="constant">@</span>metaP_IdenV A X .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_metaP_unitV. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">unfold</span> metaP_IdenV.
          <span class="proof-tactics-name">eapply</span> TransV; cycle 1.
          <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaP, Cat1LeftV .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> SymV, consV10_DesIdenObL | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> SymV, Cat1LeftV.
        <span class="keyword">Qed</span>.


      
      
    <span class="keyword">End</span> <span class="function-name">NaturalityIsPolymorphic</span>.
    
  <span class="keyword">End</span> <span class="function-name">Transformation</span>.

<span class="keyword">End</span> <span class="function-name">Functor</span>.
</pre>
  </body>
</html>
