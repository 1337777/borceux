<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>borceuxSolution3.v</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #b22222;
      }
      .company-coq-comment-h2 {
        /* company-coq-comment-h2-face */
        color: #8b2252;
        font-size: 180%;
      }
      .company-coq-coqdoc-h2 {
        /* company-coq-coqdoc-h2-face */
        color: #8b2252;
        font-weight: bold;
      }
      .company-coq-featuresXcode-folding-bullet {
        /* company-coq-features/code-folding-bullet-face */
        color: #3a5fcd;
        text-decoration: underline;
      }
      .company-coq-featuresXsmart-subscripts {
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .coq-cheat {
        /* coq-cheat-face */
        background-color: #ff0000;
      }
      .coq-solve-tactics {
        /* coq-solve-tactics-face */
        color: #ff0000;
      }
      .doc {
        /* font-lock-doc-face */
        color: #8b2252;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .proof-tactics-name {
        /* proof-tactics-name-face */
        color: #00008b;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #a0522d;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="company-coq-comment-h2">(*+ borceuxSolution.v +*)</span>

<span class="doc">(******************************************

Proph

https://github.com/1337777/borceux/blob/master/borceuxSolution.v

1. Short: This [1] solves some question of Ahrens [2] and Kan-Riehl [3], which is how to program Kelly's &lt;&lt;enriched categories&gt;&gt; and how the inter-dependence of &lt;&lt;naturality&gt;&gt; with &lt;&lt;category&gt;&gt; is cyclic. Also This [4] attempts to clarify the contrast &lt;&lt;categorical algebra&gt;&gt; (ring/locale-presentation and its "internal logic"), from &lt;&lt;categorial logic&gt;&gt; in the style of the &lt;&lt;enriched/encoded/programmed/recursion&gt;&gt; categories of Kelly-Dosen or Lawvere-Lambek and as attempted in [5], for example : the yoneda lemma and most categorial lemmas are no-more-than Gentzen's constructive logic of re-arranging the input-output positions &lt;&lt;modulo naturality&gt;&gt;. Now homotopy/knots/proof-nets may be held as (faithfull or almost-faithfull) semantical techniques (&lt;&lt;descent&gt;&gt;) to do this &lt;&lt;categorial logic&gt;&gt;, and the homotopy itself may be programmed in specialized grammars (for example [6] or HOTT).

2. The common assumption that catC( - , X ) is dual to catC( Y , - ) is FALSIFIED. This falsification originates from the description of the composition as some binary form instead of as some functional form which is programmed/encoded/enriched onto the computer. Then get some new thing which is named &lt;&lt;polymorphism&gt;&gt; from which to define &lt;&lt;polymorph category&gt;&gt;. This is the only-ever real description and deduction of the yoneda lemma, which says that the image of polyF (which is injective and contained in natural transformations) also contains all natural transformations.

3. Some polymorph category is given by polyF, which is commonly ( _1 o&gt; _2 ), polymorph in V and polymorph in A :
 Variable obF : Type.
 Variable polyF00 : obF -&gt; obF -&gt; obV.
 Notation "F[0 B ~&gt; A ]0" := (polyF00 B A) (at level 25).
 Parameter polyF : forall (B : obF), forall (V : obV) (A : obF),
                     V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                     forall X : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

4. And to get polymorph functor, instead of describing F : catA --&gt; catB  then (contrast yoneda structures) describe catV[ V , catB[ B , F - ] ] : catA --&gt; catV , more precisely
  Variable polyF0 : obA -&gt; obB.
  Notation "F|0 A" := (polyF0 A) (at level 4, right associativity).
  Notation "F[0 B ~&gt; A ]0" := (B[0 B ~&gt; F|0 A ]0) (at level 25).
  Parameter polyF : forall (V : obV) (B : obB) (A : obA),
                      V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                      forall X : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

5. And to get polymorph transformation, instead of describing phi A : G A -&gt; H A  then a-la-dosen (contrast weighted colimiting Kan extension) describe phi _f : catV( V , catB[ B , G A ] ) -&gt;  catV( V , catB[ B , H A ] ) , more precisely
   Parameter poly_phi : forall (V : obV) (B : obB) (A : obA),
                       V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                       V(0 V |- G[0 B ~&gt; A ]0 )0 .
And finally one shall relate the earlier &lt;&lt;naturality of transformation inside catV&gt;&gt; to this new &lt;&lt;polymorphism&gt;&gt; of transformation.

6. The earlier texts refering to Maclane associativity coherence and Dosen semiassociativity coherence and Dosen cut elimination for adjunctions and Chlipala ur/web database programming are all related to this present text which is how to program logically-enriched categories.

7. Stake for nondependent Solution Programme Seminary at FMCS2016 and ICMS2016 :
paypal 1337777.OOO@gmail.com , wechatpay 2796386464 , irc #OOO1337777

[1] 1337777.OOO, https://github.com/1337777/borceux/blob/master/borceuxSolution.v
[2] Ahrens, https://github.com/benediktahrens/monads/blob/trunk/CAT/enriched_cat.v
[3] Riehl, http://www.math.jhu.edu/~eriehl/context.pdf
[4] 1337777.OOO, https://github.com/1337777/borceux/blob/master/chic05.pdf
[5] 1337777.OOO, https://github.com/1337777/dosen/blob/master/itp.pdf
[6] Ye, http://katherineye.com/post/129960474471/strange-loops-capturing-knots-with-powerful

* use this authorizing-geolocated-timed-tutoring tool to play these links as TV !
http://1337777.link/ooo/guJAHkwRZYYyuhrh4GyYWv7BPOwNEF-jSeQcYN9WxLk!Zw1GYSFfr6cheRhkPhTPCnsog7DFPZQUCcv7ZEKh22s

 ******************************************)</span>

<span class="keyword">Set Implicit Arguments</span>.
<span class="type">Set</span> Universe Polymorphism.
<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">NEXT1: use (+) record structure packaking interface with (+) semi-automatic semi-programmed canonical resolution/synthesis of the polymorphicity extras which is (+) on top of the data of objects and composition. Also note that any instance of the logic interface V shall be passed as parameter to the functor interface</span></span><span class="doc">
 **)</span>

<span class="doc">(** **</span><span class="company-coq-coqdoc-h2"><span class="doc">NEXT2: is it necessary, for efficient semi-automatic semi-programmed canonical resolution/synthesis of the polymorphicity extras,  that one shall express polymorphicity as naturality in the ultimate Coq meta logic T ? Or is polymorphicity-as-is workable ?</span></span><span class="doc"> **)</span>

<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">ultimate meta logic (Coq type theory) T , which enrich all the subject logics instances of the interface V</span></span><span class="doc"> **)</span>

<span class="doc">(** T on top of Type is instance of meta/logical category with interface V , 
+    any instance of interface V is enriched in T , 
+    T is both ordinary (in T) and enriched in itself T where ordinary (0 _ |- _ )0 coincide with enriched [0 _  ~&gt; _ ]0  ,
+    polymorphicity (polyF_morphism or polyF_arrow) of category or functor  is naturality (meta&#945;_morphism or meta&#965;_morphism) of meta transformation polyF (in index A or index V) where meta is the T instance of interface V

later, top interface is  polyfunctor (which is family of metafunctors with shared category-family ), get category by putting F is identity : obA -&gt; obB := obA   and now polyF_morphism becomes the wanted polyA_morphism ,   get metafunctor by putting F is constant : obA -&gt; obB := unit   and now polyF_morphism becomes the wanted metaF_morphism

later rename polyF_unitary to polyF_constant because some constant family is same as pointing at result (or shrinking the inputdomain)   ,         keep polyF_identitary
 **)</span>

<span class="doc">(** TODO : in polyF_morphism, change DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[1 g ~&gt; X ]0 ) to DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 ) &lt;o F[1 g ~&gt; X ]0 
 **)</span>

<span class="keyword">Definition</span> <span class="function-name">obT</span> : <span class="type">Type</span> := <span class="type">Type</span>. 
<span class="keyword">Definition</span> <span class="function-name">polyT_relT00</span> : obT -&gt; obT -&gt; obT := <span class="type">fun</span> <span class="variable-name">T1 T2</span> =&gt; T1 -&gt; T2.
<span class="keyword">Notation</span> <span class="string">"T(0 B |- A )0"</span> := (polyT_relT00 B A) (<span class="type">at</span> level 35).

<span class="doc">(** comprehended as conversion on the enriched data **)</span>
<span class="comment-delimiter">(*</span><span class="comment">Inductive convT : forall T1 T2, T(0 T1 |- T2)0 -&gt; T(0 T1 |- T2 )0 -&gt; Prop :=
  convT_Base : forall T1 T2 f g,  (forall t1, f t1 = g t1) -&gt; </span><span class="constant"><span class="comment">@</span></span><span class="comment">convT T1 T2 f g
| convT_Step : forall T1 T21 T22 f g,  (forall t1 ,  (</span><span class="constant"><span class="comment">@</span></span><span class="comment">convT T21 T22 (f t1) (g t1))) -&gt; </span><span class="constant"><span class="comment">@</span></span><span class="comment">convT T1 (T21 -&gt; T22) f g.
</span><span class="comment-delimiter">*)</span>
<span class="keyword">Definition</span> <span class="function-name">convT</span> : <span class="type">forall</span> <span class="variable-name">T1 T2</span>, T(0 T1 |- T2)0 -&gt; T(0 T1 |- T2 )0 -&gt; <span class="type">Prop</span> := <span class="type">fun</span> <span class="variable-name">T1 T2</span> =&gt; eq . <span class="comment-delimiter">(*</span><span class="comment">forall t1, f t1 = g t1.</span><span class="comment-delimiter">*)</span>
<span class="keyword">Notation</span> <span class="string">"v2 ~~T v1"</span> := (convT v2 v1)  (<span class="type">at</span> level 70).
<span class="keyword">Lemma</span> <span class="function-name">ReflT</span> : <span class="type">forall</span> A1 A2 (<span class="variable-name">f</span> : T(0 A1 |- A2 )0), f ~~T f.
<span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">  intros. apply convT_Base. reflexivity.</span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">  intros; intro; intros. reflexivity.</span><span class="comment-delimiter">*)</span>
  <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">SymT</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>,  <span class="type">forall</span> (<span class="variable-name">f' f</span> : T(0 A1 |- A2)0), f ~~T f' -&gt; f' ~~T f.
<span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">  induction 1.
  constructor 1. intros. rewrite H. reflexivity.
  constructor 2.  assumption. </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(*</span><span class="comment"> intros; intro; symmetry. apply H.</span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">  symmetry. assumption. </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">symmetry</span>. <span class="coq-solve-tactics">assumption</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">TransT</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> (<span class="variable-name">uTrans f</span> : T(0 A1 |- A2)0), uTrans ~~T f -&gt; <span class="type">forall</span> (<span class="variable-name">f'</span> : T(0 A1 |- A2)0), f' ~~T uTrans -&gt; f' ~~T f.
<span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">  intros ? ? ? ? H ? H0. intro. eapply eq_trans. apply H0. apply H. </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">intros; eapply eq_trans; eassumption.</span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> eq_trans; <span class="coq-solve-tactics">eassumption</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Definition</span> <span class="function-name">polyT_relT</span> : <span class="type">forall</span> (<span class="variable-name">T</span> : <span class="type">Type</span>), <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                          ( T -&gt; T(0 B |- A )0 ) -&gt;
                          <span class="type">forall</span> <span class="variable-name">X</span> : obT, T(0 A |- X )0  -&gt;  ( T -&gt; T(0 B |- X )0 )
  := (<span class="type">fun</span> (<span class="variable-name">T</span> : <span class="type">Type</span>) (<span class="variable-name">B</span> : obT)  (<span class="variable-name">A</span> : obT) (<span class="variable-name">f</span> : T -&gt; T(0 B |- A )0) 
        (<span class="variable-name">X</span> : obT) (<span class="variable-name">g</span> : T(0 A |- X )0) (<span class="variable-name">t</span> : T) (<span class="variable-name">b</span> : B) =&gt;   g (f t b)) .

<span class="doc">(** almost same as the common unitary .. but no unit-picking mentionned **)</span>
<span class="keyword">Definition</span> <span class="function-name">polyT_relT_unitary</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                                  T(0 B |- A )0 -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obT, T(0 A |- X )0  -&gt; T(0 B |- X )0
  := (<span class="type">fun</span> (<span class="variable-name">B A</span> : obT) (<span class="variable-name">f</span> : T(0 B |- A )0) (<span class="variable-name">X</span> : obT) (<span class="variable-name">g</span> : T(0 A |- X )0) =&gt;
        polyT_relT (<span class="type">fun</span> _ : unit =&gt; f) g tt) .  

<span class="keyword">Definition</span> <span class="function-name">polyT_relT_identitary</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                                   <span class="type">forall</span> <span class="variable-name">X</span> : obT, T(0 A |- X )0  -&gt; T(0 B |- A )0 -&gt; T(0 B |- X )0
  :=  <span class="type">fun</span> (<span class="variable-name">B</span> : obT) =&gt; <span class="type">fun</span> (<span class="variable-name">A</span> : obT) =&gt;
                      <span class="type">fun</span> <span class="variable-name">X</span> : obT =&gt;  <span class="type">fun</span> (<span class="variable-name">a</span> : T(0 A |- X )0) =&gt; <span class="type">fun</span> (<span class="variable-name">b</span> : T(0 B |- A )0) =&gt;
                                                            <span class="constant">@</span>polyT_relT (T(0 B |- A )0) B A (<span class="type">fun</span> <span class="variable-name">b0</span> =&gt; b0) X a b .

<span class="keyword">Notation</span> <span class="string">"T(1 b |- X )0"</span> := (<span class="constant">@</span>polyT_relT _ _ _ b X) (<span class="type">at</span> level 35).

<span class="keyword">Notation</span> <span class="string">"T(1I b |- - )0"</span> := (<span class="constant">@</span>polyT_relT_unitary _ _ b) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( b 0 ) o&gt; _ )   **)</span>
<span class="keyword">Notation</span> <span class="string">"T(1I b |- X )0"</span> := (<span class="constant">@</span>polyT_relT_unitary _ _ b X) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( b 0 ) o&gt; a )  **)</span>
<span class="keyword">Notation</span> <span class="string">"b o&gt;&gt; a"</span> := (<span class="constant">@</span>polyT_relT_unitary _ _ b _ a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
<span class="keyword">Eval</span> <span class="proof-tactics-name">compute</span> <span class="type">in</span>  <span class="type">fun</span> <span class="variable-name">b a</span> =&gt; b o&gt;&gt; a .

<span class="keyword">Notation</span> <span class="string">"T(1 'id' |- X )0"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ X) (<span class="type">at</span> level 35).
<span class="keyword">Notation</span> <span class="string">"T(0 X |- - )1"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ X) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( id _ ) o&gt; a )  **)</span>
<span class="keyword">Notation</span> <span class="string">"T(0 X |- a )1"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ X a) (<span class="type">at</span> level 35).
<span class="doc">(**  more precisely ( ( id b ) o&gt; a )  **)</span>
<span class="keyword">Notation</span> <span class="string">"a &lt;&lt;o b"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ _ a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
<span class="keyword">Eval</span> <span class="proof-tactics-name">compute</span> <span class="type">in</span>  <span class="type">fun</span> <span class="variable-name">b a</span> =&gt; a &lt;&lt;o b .

<span class="keyword">Lemma</span> <span class="function-name">polyT_relT_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                          <span class="type">forall</span> (<span class="variable-name">T T'</span> : <span class="type">Type</span>) (<span class="variable-name">b</span> : T' -&gt; T),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : T -&gt; T(0 B |- A )0 ) (<span class="variable-name">X</span> : obT),
                          <span class="type">forall</span> (<span class="variable-name">a</span> : T(0 A |- X )0), <span class="type">forall</span> (<span class="variable-name">ttt</span>: T'),
                            T(1 (<span class="type">fun</span> <span class="variable-name">v'</span> =&gt; f (b v')) |- X )0 a ttt
                             ~~T T(1 f |- X )0 a (b ttt) .
<span class="keyword">Proof</span>.
  <span class="comment-delimiter">(*</span><span class="comment">  intros; intro. reflexivity.</span><span class="comment-delimiter">*)</span>
  <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">polyT_relT_unitary_rel_identitary</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obT) , <span class="type">forall</span> (<span class="variable-name">A</span> : obT) ,
                                           <span class="type">forall</span> <span class="variable-name">X</span> : obT , <span class="type">forall</span> (<span class="variable-name">a</span> : T(0 A |- X )0),  <span class="type">forall</span> (<span class="variable-name">b</span> : T(0 B |- A )0),
                                             <span class="constant">@</span>polyT_relT_unitary B A b X a ~~T  a &lt;&lt;o b  . <span class="comment-delimiter">(*</span><span class="comment"> </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyT_relT B (T(0 B |- A )0) A (fun b0 =&gt; b0) X a b .</span><span class="comment-delimiter">*)</span>
<span class="keyword">Proof</span>. <span class="comment-delimiter">(*</span><span class="comment"> instance-proof copy-paste</span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(*</span><span class="comment">  unfold polyT_relT_identitary. unfold polyT_relT_unitary.
  intros; intro; eapply polyT_relT_arrow with (f := fun b0 =&gt; b0) (b := fun _ : unit =&gt; b).</span><span class="comment-delimiter">*)</span>
  <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.


<span class="comment-delimiter">(*</span><span class="comment">
Definition convT_fun : forall U1 U2 T1 T2, (T(0 U1 |- U2)0 -&gt; T(0 T1 |- T2)0) -&gt; (T(0 U1 |- U2)0 -&gt; T(0 T1 |- T2 )0) -&gt; Prop
  := fun  U1 U2 T1 T2 (w' w : (T(0 U1 |- U2)0 -&gt; T(0 T1 |- T2)0)) =&gt;
       forall u1 u2, u1 ~~T u2 -&gt; w' u1 ~~T w u2 .
Notation "w' ~~~T w" := (convT_fun w' w)  (at level 70).
</span><span class="comment-delimiter">*)</span>
<span class="keyword">Lemma</span> <span class="function-name">Cong_polyT_relT</span> :   <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obT) (<span class="variable-name">f f'</span> : T(0 V |- T(0 B |- A )0 )0),
                            (<span class="type">forall</span> _v : V, f' _v ~~T f _v) -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obT,  <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~T a2 -&gt; <span class="type">forall</span> _v, T(1 f' |- X )0 a1 _v ~~T T(1 f |- X )0 a2 _v .
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">compute</span>. <span class="proof-tactics-name">rewrite</span> H, H0. <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.

<span class="comment-delimiter">(*</span><span class="comment">
Axiom Cong_polyT_relT :   forall (V : obT) (B A : obT) (f f' : T(0 V |- T(0 B |- A )0 )0),
                                f' ~~T f -&gt; forall X : obT, T(1 f' |- X )0 ~~T T(1 f |- X )0.

Axiom Cong_polyT_relT' : forall (B : obT), forall (A : obT),
                  forall (f f' : T(0 B |- A )0),
                    f' ~~T f -&gt; forall X : obT, </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyT_relT_unitary B A f' X ~~~T </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyT_relT_unitary B A f X. </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(*</span><span class="comment">Proof.
  (*  intros. intro. intros. unfold convT in * . f_equal; assumption. *) 
  intros. intro. intros. unfold convT in * . intros.  compute. (* solve [congruence]. *)
  rewrite H. apply H0.
Qed.</span><span class="comment-delimiter">*)</span>

<span class="keyword">Definition</span> <span class="function-name">idT</span> : <span class="type">forall</span> <span class="variable-name">T</span> : <span class="type">Type</span>, T -&gt; T := <span class="type">fun</span> <span class="variable-name">T</span> : <span class="type">Type</span> =&gt; <span class="type">fun</span> <span class="variable-name">x</span> : T =&gt; x .
<span class="keyword">Definition</span> <span class="function-name">IdenT</span> : <span class="type">forall</span> {<span class="variable-name">T</span> : obT}, T(0 T |- T )0 := idT .
<span class="keyword">Notation</span> <span class="string">"1T"</span> := (<span class="constant">@</span>IdenT _) (<span class="type">at</span> level 0).

<span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
<span class="keyword">Lemma</span> <span class="function-name">polyT_relT_unitT</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obT), <span class="type">forall</span> <span class="variable-name">X</span> : obT, <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~T a2 -&gt; ( <span class="constant">@</span>idT (T(0 A |- X )0)  ) a1 ~~T ( T(1I (<span class="constant">@</span>IdenT A) |- X )0 ) a2 .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>.  <span class="proof-tactics-name">intros</span>. <span class="coq-solve-tactics">assumption</span>.
<span class="keyword">Qed</span>.

<span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyT is injective **)</span>
<span class="keyword">Lemma</span> <span class="function-name">polyT_relT_inputUnitT</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                              <span class="type">forall</span> (<span class="variable-name">b</span> : T(0 B |- A )0),
                                 b  ~~T ( (T(1I b |- A )0)  (<span class="constant">@</span>IdenT A) ) .
<span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">  intros; intro; reflexivity.</span><span class="comment-delimiter">*)</span> <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.
<span class="doc">(** TODO: write the  functional monoidal logic onto T **)</span>

<span class="keyword">Definition</span> <span class="function-name">desT00</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obT, <span class="type">forall</span> <span class="variable-name">V1</span> : obT, obT.
  <span class="proof-tactics-name">intros</span> ? ? . <span class="coq-solve-tactics">exact</span> (prod V1 V2). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">desT10</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obT, <span class="type">forall</span> <span class="variable-name">V1 V1'</span>, (polyT_relT00 V1 V1') -&gt; (polyT_relT00 (desT00 V2 V1) (desT00 V2 V1')).
  <span class="proof-tactics-name">intros</span> ? ? ? v (_v1, _v2). <span class="coq-solve-tactics">exact</span> (v _v1, _v2). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">consT00</span> : obT -&gt; obT -&gt; obT.
  <span class="proof-tactics-name">intros</span> V1 V2. <span class="coq-solve-tactics">exact</span> ( (V1 -&gt; V2) % type). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">consT01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obT, <span class="type">forall</span> <span class="variable-name">V2 V2'</span>, (polyT_relT00 V2 V2') -&gt; (polyT_relT00 (consT00 V1 V2)  (consT00 V1 V2')).
  <span class="proof-tactics-name">intros</span> ? ? ? v2 v12.  <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _v1 =&gt; v2 ( v12 _v1 ) ). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">consT10</span> : <span class="type">forall</span> <span class="variable-name">V1' V1</span>, (polyT_relT00 V1' V1) -&gt; <span class="type">forall</span> <span class="variable-name">V2</span> : obT, (polyT_relT00 (consT00 V1 V2) (consT00 V1' V2)).
  <span class="proof-tactics-name">intros</span> ? ? v1 ? v12 .  <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _v1' =&gt; v12 (v1 _v1') ). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">DesT</span>: <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), (polyT_relT00 U (consT00 V W)) -&gt; (polyT_relT00 (desT00 V U) W) .
  <span class="proof-tactics-name">intros</span> ? ? ? u'v'w. <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _u_v =&gt; <span class="type">let</span> (_u, _v) := _u_v <span class="type">in</span> u'v'w _u _v ). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">ConsT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), (polyT_relT00 (desT00 V U) W) -&gt; (polyT_relT00 U (consT00 V W)).
  <span class="proof-tactics-name">intros</span> ? ? ? uv'w. <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _u =&gt; <span class="type">fun</span> _v =&gt; uv'w (_u, _v) ). <span class="keyword">Defined</span>. 
<span class="keyword">Definition</span> <span class="function-name">IdenObT</span> : obT.
  <span class="coq-solve-tactics">exact</span> unit. <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">unitT</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obT}, (polyT_relT00 IdenObT (consT00 A A) ).
  <span class="proof-tactics-name">intros</span> ? ?. <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> <span class="variable-name">a</span> =&gt; a). <span class="keyword">Defined</span>.
<span class="keyword">Definition</span> <span class="function-name">AssocT</span> : <span class="type">forall</span> {<span class="variable-name">V W</span> :obT }, <span class="type">forall</span> {<span class="variable-name">U</span>: obT }, T(0 (desT00 (desT00 W V )  U ) |- (desT00 W ( (desT00 V  U))  ) )0.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intro</span>. <span class="proof-tactics-name">destruct</span> X. <span class="proof-tactics-name">destruct</span> d. <span class="coq-solve-tactics">exact</span> ((u,v ),w).
<span class="keyword">Defined</span>.


<span class="keyword">About</span> consT01.
<span class="keyword">Notation</span>  <span class="string">"(0T V1 * V2 )0"</span> := (desT00 V2 V1) (<span class="type">at</span> level 30, V1 <span class="type">at</span> next level).
<span class="keyword">Notation</span>  <span class="string">"(1T v * V2 )0"</span> := (<span class="constant">@</span>desT10 V2 _ _ v) (<span class="type">at</span> level 30, v <span class="type">at</span> next level).
<span class="keyword">Notation</span> <span class="string">"[0T V1 ~&gt; V2 ]0"</span> := (consT00 V1 V2) (<span class="type">at</span> level 30).
<span class="keyword">Notation</span> <span class="string">"[0T V1 ~&gt; v ]1"</span> := (<span class="constant">@</span>consT01 V1 _ _ v) (<span class="type">at</span> level 30).
<span class="keyword">Notation</span> <span class="string">"[1T v ~&gt; V2 ]0"</span> := (<span class="constant">@</span>consT10 _ _ v V2) (<span class="type">at</span> level 30).
<span class="keyword">Notation</span>  <span class="string">"'IT'"</span> := (<span class="constant">@</span>IdenObT _) (<span class="type">at</span> level 0).
<span class="keyword">Notation</span> <span class="string">"'uT'"</span> := (<span class="constant">@</span>unitT _) (<span class="type">at</span> level 0).


<span class="keyword">Lemma</span> <span class="function-name">CongDesT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">f f'</span> : T(0 U |- [0T V ~&gt; W ]0 )0),
                  f' ~~T f -&gt; DesT f' ~~T DesT f .
<span class="comment-delimiter">(*</span><span class="comment">  intros ? ? ? ? ? H t1.
  destruct t1. simpl. rewrite H. reflexivity.</span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">intros</span> ? ? ? ? ? H .
   <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">rewrite</span> H. <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.
<span class="keyword">Axiom</span> <span class="variable-name">Des_ConsT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">f</span> : T(0 (0T U * V )0 |-  W )0),
                    DesT (ConsT f) ~~T f .
<span class="comment-delimiter">(*</span><span class="comment">Proof.
  (*  intros. intros [ ]. reflexivity.*)
Qed.</span><span class="comment-delimiter">*)</span>

<span class="keyword">Axiom</span> <span class="variable-name">Des_OutputT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT , <span class="type">forall</span> (<span class="variable-name">U W</span> : obT ), <span class="type">forall</span> (<span class="variable-name">v</span> : T(0 U |- T(0 V |- W )0 )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : T(0 W |- W' )0),
                           DesT( [0T V ~&gt; w ]1 &lt;&lt;o v ) ~~T w &lt;&lt;o DesT( v ) .
<span class="comment-delimiter">(*</span><span class="comment">Proof.
  (*  intros. intros []. intros. reflexivity.*)
Qed.</span><span class="comment-delimiter">*)</span>

<span class="comment-delimiter">(*</span><span class="comment"> this is some form of functional extensionality </span><span class="comment-delimiter">*)</span>
<span class="keyword">Lemma</span> <span class="function-name">CongConsT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">v v'</span> : T(0 (0T U * V )0 |- W )0 ),
                    v' ~~T v -&gt; ConsT v' ~~T ConsT v .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">compute</span>. <span class="proof-tactics-name">rewrite</span> H. <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.
  <span class="keyword">Lemma</span> <span class="function-name">Cons_DesT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">f</span> : T(0 U |-  [0T V ~&gt; W ]0 )0),
                    ConsT (DesT f) ~~T f .
    <span class="comment-delimiter">(*</span><span class="comment">    intros. intro.  reflexivity. </span><span class="comment-delimiter">*)</span>
        <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">Cons_InputT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obT) (<span class="variable-name">w</span> : T(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obT) (<span class="variable-name">v</span> : T(0 (0T U * V )0 |- W )0),
                         ConsT(v &lt;&lt;o (1T w * V )0 )  ~~T ConsT( v ) &lt;&lt;o w .
  <span class="comment-delimiter">(*</span><span class="comment">  intros. intro. reflexivity.</span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">intros</span>.  <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Definition</span> <span class="function-name">DesInT</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obT), <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obT), T(0 U0 |- [0T U1 ~&gt; [0T V ~&gt; W ]0 ]0 )0 -&gt; T(0 U0 |- [0T (0T U1 * V )0 ~&gt; W ]0 )0.
  <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> ConsT. <span class="proof-tactics-name">eapply</span> polyT_relT_identitary. <span class="keyword">Check</span> <span class="constant">@</span>AssocT. 2: <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>AssocT _ _ _).  <span class="proof-tactics-name">eapply</span> DesT.
  <span class="proof-tactics-name">eapply</span> DesT. <span class="coq-solve-tactics">exact</span> X.
<span class="keyword">Defined</span>.

<span class="keyword">Axiom</span>  <span class="variable-name">functional_extensionality_dep</span> : <span class="type">forall</span> {A} {<span class="variable-name">B</span> : A -&gt; <span class="type">Type</span>},
                                       <span class="type">forall</span> (<span class="variable-name">f g</span> : <span class="type">forall</span> <span class="variable-name">x</span> : A, B x),  (<span class="type">forall</span> <span class="variable-name">x</span>, f x = g x) -&gt; f = g.

<span class="keyword">Lemma</span>  <span class="function-name">polyT_relT_morphism''</span> :   <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obT) (<span class="variable-name">W</span> : obT) (<span class="variable-name">A'</span> : obT)
                                   (<span class="variable-name">g</span> : T(0 W |- T(0 A |- A' )0 )0) (<span class="variable-name">f</span> : T(0 V |- T(0 B |- idT A )0 )0)
                                   (<span class="variable-name">X</span> : obT),
                                   T(1 DesT
                                       ((T(1 (<span class="type">fun</span> <span class="variable-name">b0</span>  =&gt; b0) |- [0T V ~&gt; T(0 B |- idT A' )0 ]0 )0)
                                          ([1T f ~&gt; T(0 B |- idT A' )0 ]0)
                                          ((T(1 (<span class="type">fun</span> <span class="variable-name">b0</span>  =&gt; b0) |- [0T T(0 B |- idT A )0 ~&gt; T(0 B |- idT A' )0 ]0 )0)
                                             (T(1 ( IdenT ) |- A' )0) g)) |- X )0 ~~T
                                    DesInT 
                                    ((T(1 (<span class="type">fun</span> <span class="variable-name">b0</span> =&gt; b0) |- [0T W ~&gt; [0TV ~&gt; T(0 B |- idT X )0 ]0 ]0 )0)
                                       ([0TW ~&gt; T(1 f |- X )0 ]1) (T(1 g |- X )0)).
    <span class="proof-tactics-name">intros</span>.
    <span class="proof-tactics-name">compute</span>.
    <span class="proof-tactics-name">apply</span> functional_extensionality_dep. <span class="proof-tactics-name">intro</span>.
    <span class="proof-tactics-name">apply</span> functional_extensionality_dep. <span class="proof-tactics-name">intro</span>.
    <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">destruct</span> x0. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  
<span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
<span class="keyword">Lemma</span> <span class="function-name">polyT_relT_morphism</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obT), 
                             <span class="type">forall</span> (<span class="variable-name">A</span> : obT) (<span class="variable-name">A'</span> : obT) (<span class="variable-name">g</span> : T(0 A |- A')0),
                             <span class="type">forall</span> (<span class="variable-name">X</span> : obT), <span class="type">forall</span> (<span class="variable-name">pull</span> : T(0 B |- A)0), <span class="type">forall</span> (<span class="variable-name">push</span> : T(0 A'  |- X )0 ),
                               T(1I T(0 A' |- g )1 pull |- X )0 push
                                ~~T  T(0 X |- T(1I g |- X )0 push )1 pull .
<span class="keyword">Proof</span>.
  <span class="comment-delimiter">(*</span><span class="comment">  intros; intro; reflexivity.</span><span class="comment-delimiter">*)</span>
  <span class="coq-solve-tactics">reflexivity</span>.
<span class="keyword">Qed</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put any ( may be written in polymorph-style ... ) `arrows :^) logic'   V</span></span><span class="doc"> **)</span>

      <span class="comment-delimiter">(*</span><span class="comment"> now: rewrite polyV_relT more generally as if enriched in T  then get old instance... therefore must rewrite polyV_relT_polymorphism more generally then get old instance
       </span><span class="comment-delimiter">*)</span>

<span class="keyword">Module</span> <span class="function-name">LOGIC</span>.

  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.
  
    <span class="keyword">Record</span> <span class="function-name">data</span> :=
    Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
        <span class="variable-name">obV</span> : <span class="type">Type</span>;
        polyV_relT00 : obV -&gt; obV -&gt; obT;
        convV : <span class="type">forall</span> <span class="variable-name">V1 V2</span>, polyV_relT00 V1 V2 -&gt; polyV_relT00 V1 V2 -&gt; <span class="type">Prop</span>;
        <span class="comment-delimiter">(*</span><span class="comment"> polyV_relT as primitive breaks definitional of &lt;o and o&gt; .. but now clearly any instance of interface V is enriched in T </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(*</span><span class="comment">        polyV_relT : forall B : obV data_of, forall (T : obT) (A : obV data_of),
                       T(0 T |- V(0 B |- A)0 )0 -&gt;
                       forall (X : obV data_of), T(0 V(0 A |- X)0 |-  T(0 T |- V(0 B |- X)0 )0 )0;
        IdenV : forall {V : obV data_of}, V(0 V |- V )0 </span><span class="comment-delimiter">*)</span>
         polyV_relT : <span class="type">forall</span> (<span class="variable-name">T</span> : obT), <span class="type">forall</span> <span class="variable-name">B</span> : obV,  <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                       T(0 T |- (polyV_relT00 B A) )0 -&gt;
                       <span class="type">forall</span> (<span class="variable-name">X</span> : obV), T(0 (polyV_relT00 A X) |-  T(0 T |- (polyV_relT00 B X) )0 )0;
         IdenV : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, (polyV_relT00 V V);
         desV00 : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> <span class="variable-name">V1</span> : obV, obV;
         desV10 : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> {V1 V1'}, (polyV_relT00 V1 V1') -&gt; (polyV_relT00 (desV00 V2 V1) (desV00 V2 V1'));
         consV00 : obV -&gt; obV -&gt; obV;
         consV01 : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> {V2 V2'}, (polyV_relT00 V2 V2') -&gt; (polyV_relT00 (consV00 V1 V2)  (consV00 V1 V2'));
         consV10 : <span class="type">forall</span> {V1' V1}, (polyV_relT00 V1' V1) -&gt; <span class="type">forall</span> <span class="variable-name">V2</span> : obV, (polyV_relT00 (consV00 V1 V2) (consV00 V1' V2));
         Des : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, <span class="type">forall</span> {<span class="variable-name">U W</span> : obV}, (polyV_relT00 U (consV00 V W)) -&gt; (polyV_relT00 (desV00 V U) W);
         Cons : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, <span class="type">forall</span> {<span class="variable-name">U W</span> : obV}, (polyV_relT00 (desV00 V U) W) -&gt; (polyV_relT00 U (consV00 V W));
         IdenObV : obV;
         unitV : <span class="type">forall</span> {<span class="variable-name">A</span> : obV}, (polyV_relT00 IdenObV (consV00 A A) );
         Assoc : <span class="type">forall</span> {<span class="variable-name">V W</span> :obV}, <span class="type">forall</span> {<span class="variable-name">U</span>: obV}, (polyV_relT00 (desV00 (desV00 W V) U )  ((desV00 W (desV00  V U ))  ) );
        }.

    Arguments Des {_} {_ _ _} _ .
    Arguments Cons {_} {_ _ _} _ .
    Arguments Assoc {_} {_ _ _}.
    
    <span class="keyword">Notation</span> <span class="string">"v2 ~~ v1"</span> := (convV v2 v1)  (<span class="type">at</span> level 70).
  <span class="keyword">Notation</span> <span class="string">"V(0 B |- A )0"</span> := (polyV_relT00 B A) (<span class="type">at</span> level 35).
  <span class="keyword">Notation</span> <span class="string">"1"</span> := (<span class="constant">@</span>IdenV _ _) (<span class="type">at</span> level 0).
  <span class="keyword">Notation</span>  <span class="string">"(0 V1 * V2 )0"</span> := (desV00 V2 V1) (<span class="type">at</span> level 30, V1 <span class="type">at</span> next level).
  <span class="keyword">Notation</span>  <span class="string">"(1 v * V2 )0"</span> := (desV10 V2 v) (<span class="type">at</span> level 30, v <span class="type">at</span> next level).
  <span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; V2 ]0"</span> := (consV00 V1 V2) (<span class="type">at</span> level 30).
  <span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; v ]1"</span> := (consV01 V1 v) (<span class="type">at</span> level 30).
  <span class="keyword">Notation</span> <span class="string">"[1 v ~&gt; V2 ]0"</span> := (consV10 v V2) (<span class="type">at</span> level 30).
  <span class="keyword">Notation</span>  <span class="string">"'I'"</span> := (<span class="constant">@</span>IdenObV _) (<span class="type">at</span> level 0).
  <span class="keyword">Notation</span> <span class="string">"'uV'"</span> := (<span class="constant">@</span>unitV _) (<span class="type">at</span> level 0).
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations</span>.
    <span class="keyword">Notation</span> <span class="string">"v2 ~~ dat ` v1"</span> := (<span class="constant">@</span>convV dat _ _ v2 v1)  (<span class="type">at</span> level 70, dat <span class="type">at</span> next level, format <span class="string">"v2  ~~ dat `  v1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-V(0 B |- A )0"</span> := (<span class="constant">@</span>polyV_relT00 dat B A) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(0  B  |-  A  )0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-1"</span> := (<span class="constant">@</span>IdenV dat _ _) (<span class="type">at</span> level 0, format <span class="string">"dat .-1"</span>).
    <span class="keyword">Notation</span>  <span class="string">"dat .-(0 V1 * V2 )0"</span> := (<span class="constant">@</span>desV00 dat V2 V1) (<span class="type">at</span> level 30, V1 <span class="type">at</span> next level, format <span class="string">"dat .-(0  V1  *  V2  )0"</span>).
    <span class="keyword">Notation</span>  <span class="string">"dat .-(1 v * V2 )0"</span> := (<span class="constant">@</span>desV10 dat V2 _ _ v) (<span class="type">at</span> level 30, v <span class="type">at</span> next level, format <span class="string">"dat .-(1  v  *  V2  )0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-[0 V1 ~&gt; V2 ]0"</span> := (<span class="constant">@</span>consV00 dat V1 V2) (<span class="type">at</span> level 30, format <span class="string">"dat .-[0  V1  ~&gt;  V2  ]0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-[0 V1 ~&gt; v ]1"</span> := (<span class="constant">@</span>consV01 dat V1 _ _ v) (<span class="type">at</span> level 30, format <span class="string">"dat .-[0  V1  ~&gt;  v  ]1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-[1 v ~&gt; V2 ]0"</span> := (<span class="constant">@</span>consV10 dat _ _ v V2) (<span class="type">at</span> level 30, format <span class="string">"dat .-[1  v  ~&gt;  V2  ]0"</span>).
    <span class="keyword">Notation</span>  <span class="string">"dat .-I"</span> := (<span class="constant">@</span>IdenObV dat _) (<span class="type">at</span> level 0, format <span class="string">"dat .-I"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-uV"</span> := (<span class="constant">@</span>unitV dat _) (<span class="type">at</span> level 0, format <span class="string">"dat .-uV"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations</span>.

   <span class="comment-delimiter">(*</span><span class="comment"> 
    Notation "v2 ~~ dat ` v1" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">convV dat _ _ v2 v1)  (at level 70, dat at next level, format "v2  ~~ dat `  v1").
    Notation "dat .-V(0 B |- A )0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT00 dat B A) (at level 35, format "dat .-V(0  B  |-  A  )0").
    Notation "dat .-1" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV dat _) (at level 0, format "dat .-1").
    Notation  "dat .-(0 V1 * V2 )0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">desV00 dat V2 V1) (at level 30, V1 at next level, format "dat .-(0  V1  *  V2  )0").
    Notation  "dat .-(1 v * V2 )0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">desV10 dat V2 _ _ v) (at level 30, v at next level, format "dat .-(1  v  *  V2  )0").
    Notation "dat .-[0 V1 ~&gt; V2 ]0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">consV00 dat V1 V2) (at level 30, format "dat .-[0  V1  ~&gt;  V2  ]0").
    Notation "dat .-[0 V1 ~&gt; v ]1" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">consV01 dat V1 _ _ v) (at level 30, format "dat .-[0  V1  ~&gt;  v  ]1").
    Notation "dat .-[1 v ~&gt; V2 ]0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">consV10 dat _ _ v V2) (at level 30, format "dat .-[1  v  ~&gt;  V2  ]0").
    Notation  "dat .-I" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenObV dat) (at level 0, format "dat .-I").
    Notation "dat .-uV" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitV dat _) (at level 0, format "dat .-uV").

    Notation "v2 ~~ v1" := (v2 ~~ _ ` v1)  (at level 70).
    Notation "V(0 B |- A )0" := (_ .-V(0 B |- A )0) (at level 35).
    Notation "1" := (_ .-1) (at level 0).
    Notation  "(0 V1 * V2 )0" := (_ .-(0 V1 * V2 )0) (at level 30, V1 at next level).
    Notation  "(1 v * V2 )0" := (_ .-(1 v * V2 )0) (at level 30, v at next level).
    Notation "[0 V1 ~&gt; V2 ]0" := (_ .-[0 V1 ~&gt; V2 ]0) (at level 30).
    Notation "[0 V1 ~&gt; v ]1" := (_ .-[0 V1 ~&gt; v ]1) (at level 30).
    Notation "[1 v ~&gt; V2 ]0" := (_ .-[1 v ~&gt; V2 ]0) (at level 30).
    Notation  "'I'" := (_ .-I) (at level 0).
    Notation "'uV'" := (_ .-uV) (at level 0).
</span><span class="comment-delimiter">*)</span>

  <span class="comment-delimiter">(*</span><span class="comment">
  Record data :=
    Data {
        obV : Type;
        polyV_relT00 : obV -&gt; obV -&gt; obT;
        convV : forall V1 V2, polyV_relT00 V1 V2 -&gt; polyV_relT00 V1 V2 -&gt; Prop;
      }.

  Notation "v2 ~~ v1" := (convV v2 v1)  (at level 70).
  Notation "V(0 B |- A )0" := (polyV_relT00 B A) (at level 35).

  Record data1 :=
    Data1 {
        data_of :&gt; data;
        (* polyV_relT as primitive breaks definitional of &lt;o and o&gt; .. but now clearly any instance of interface V is enriched in T *)
        polyV_relT : forall B : obV data_of, forall (T : obT) (A : obV data_of),
                       T(0 T |- V(0 B |- A)0 )0 -&gt;
                       forall (X : obV data_of), T(0 V(0 A |- X)0 |-  T(0 T |- V(0 B |- X)0 )0 )0;
        IdenV : forall {V : obV data_of}, V(0 V |- V )0
      }.
</span><span class="comment-delimiter">*)</span>
  
  <span class="comment-delimiter">(*</span><span class="comment"> TODO: below everywhere change polyV_relT to polyV_relT </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">
Parameter polyV_relT_unitary : forall (B : obV), forall (A : obV),
                             V(0 B |- A )0 -&gt; forall X : obV, V(0 A |- X )0  -&gt; V(0 B |- X )0.
   </span><span class="comment-delimiter">*)</span>
  <span class="doc">(** almost same as the common unitary .. but no unit-picking mentionned **)</span>
  <span class="keyword">Definition</span> <span class="function-name">polyV_relT_unitary</span> {<span class="variable-name">log</span>: data} : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                                V(0 B |- A )0 -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV log, T(0 V(0 A |- X )0  |- V(0 B |- X )0 )0
    := (<span class="type">fun</span> (<span class="variable-name">B A</span> : obV log) (<span class="variable-name">f</span> : V(0 B |- A )0) (<span class="variable-name">X</span> : obV log) (<span class="variable-name">g</span> : V(0 A |- X )0) =&gt;
         polyV_relT (<span class="type">fun</span> _ : unit =&gt; f) g tt) .

  <span class="doc">(** definitionally: relation of polyV_relT_identitary to polyV_relT_unitary , instead of going through polyF_relT which gives only propositional equality **)</span>
  <span class="comment-delimiter">(*</span><span class="comment">Definition polyV_relT_identitary : forall (B : obV), forall (A : obV),
                    forall X : obV, V(0 A |- X )0  -&gt; V(0 B |- A )0 -&gt; V(0 B |- X )0
  :=  fun (B : obV) =&gt; fun (A : obV) =&gt;
                     fun X : obV =&gt;  fun (a : V(0 A |- X )0) =&gt; fun (b : V(0 B |- A )0) =&gt;
                                                           (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_unitary B A b X a).
   </span><span class="comment-delimiter">*)</span>
  <span class="keyword">Definition</span> <span class="function-name">polyV_relT_identitary</span> {<span class="variable-name">log</span> : data} : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                                   <span class="type">forall</span> <span class="variable-name">X</span> : obV log, T(0 V(0 A |- X )0  |- T(0 V(0 B |- A )0 |- V(0 B |- X )0 )0 )0
    :=  <span class="type">fun</span> (<span class="variable-name">B</span> : obV log) =&gt; <span class="type">fun</span> (<span class="variable-name">A</span> : obV log) =&gt;
                           <span class="type">fun</span> <span class="variable-name">X</span> : obV log =&gt;  <span class="type">fun</span> (<span class="variable-name">a</span> : V(0 A |- X )0) =&gt; <span class="type">fun</span> (<span class="variable-name">b</span> : V(0 B |- A )0) =&gt;
                                                                     <span class="constant">@</span>polyV_relT log (V(0 B |- A )0) B A (<span class="type">fun</span> <span class="variable-name">b0</span> =&gt; b0) X a b .
  
  <span class="keyword">Notation</span> <span class="string">"V(1 b |- X )0"</span> := (<span class="constant">@</span>polyV_relT _ _ _ _ b X) (<span class="type">at</span> level 35).

  <span class="keyword">Notation</span> <span class="string">"V(1I b |- - )0"</span> := (<span class="constant">@</span>polyV_relT_unitary _ _ _ b) (<span class="type">at</span> level 35).
  <span class="doc">(**  more precisely ( ( b 0 ) o&gt; _ )   **)</span>
  <span class="keyword">Notation</span> <span class="string">"V(1I b |- X )0"</span> := (<span class="constant">@</span>polyV_relT_unitary _ _ _ b X) (<span class="type">at</span> level 35).
  <span class="doc">(**  more precisely ( ( b 0 ) o&gt; a )  **)</span>
  <span class="keyword">Notation</span> <span class="string">"b o&gt; a"</span> := (<span class="constant">@</span>polyV_relT_unitary _ _ _ b _ a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Notation</span> <span class="string">"V(1 'id' |- X )0"</span> := (<span class="constant">@</span>polyV_relT_identitary _ _ _ X) (<span class="type">at</span> level 35).
  <span class="keyword">Notation</span> <span class="string">"V(0 X |- - )1"</span> := (<span class="constant">@</span>polyV_relT_identitary _ _ _ X) (<span class="type">at</span> level 35).
  <span class="doc">(**  more precisely ( ( id _ ) o&gt; a )  **)</span>
  <span class="keyword">Notation</span> <span class="string">"V(0 X |- a )1"</span> := (<span class="constant">@</span>polyV_relT_identitary _ _ _ X a) (<span class="type">at</span> level 35).
  <span class="doc">(**  more precisely ( ( id b ) o&gt; a )  **)</span>
  <span class="keyword">Notation</span> <span class="string">"a &lt;o b"</span> := (<span class="constant">@</span>polyV_relT_identitary _ _ _ _ a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations2</span>.
      
    <span class="keyword">Notation</span> <span class="string">"dat .-V(1 b |- X )0"</span> := (<span class="constant">@</span>polyV_relT dat _ _ _ b X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(1  b  |-  X  )0"</span>).

    <span class="keyword">Notation</span> <span class="string">"dat .-V(1I b |- - )0"</span> := (<span class="constant">@</span>polyV_relT_unitary dat _ _ b) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(1I  b  |-  -  )0"</span>).
    <span class="doc">(**  more precisely ( ( b 0 ) o&gt; _ )   **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-V(1I b |- X )0"</span> := (<span class="constant">@</span>polyV_relT_unitary dat _ _ b X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(1I  b  |-  X  )0"</span>).
    <span class="doc">(**  more precisely ( ( b 0 ) o&gt; a )  **)</span>
    <span class="keyword">Notation</span> <span class="string">"b o&gt; dat &gt; a"</span> := (<span class="constant">@</span>polyV_relT_unitary dat _ _ b _ a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"b  o&gt; dat &gt;  a"</span>).

    <span class="keyword">Notation</span> <span class="string">"dat .-V(1 'id' |- X )0"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(1  'id'  |-  X  )0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-V(0 X |- - )1"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(0  X  |-  -  )1"</span>).
    <span class="doc">(**  more precisely ( ( id _ ) o&gt; a )  **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-V(0 X |- a )1"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ X a) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(0  X  |-  a  )1"</span>).
    <span class="doc">(**  more precisely ( ( id b ) o&gt; a )  **)</span>
    <span class="keyword">Notation</span> <span class="string">"a &lt; dat &lt;o b"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ _ a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"a  &lt; dat &lt;o  b"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations2</span>.
  <span class="comment-delimiter">(*</span><span class="comment">
Hypothesis polyV_relT_arrow :  forall (B : obV), forall (A : obV),
                        forall (V V' : obT) (b : V' -&gt; V),
                        forall (f : V -&gt; V(0 B |- A )0 ) (X : obV),
                        forall (a : V(0 A |- X )0) (ttt: V'),
                          V(1 (fun v' =&gt; f (b v')) |- X )0 a ttt
                          = V(1 f |- X )0 a (b ttt).

Lemma polyV_relT_identitary_really :  forall (B : obV) , forall (A : obV) ,
                                 forall X : obV , forall (a : V(0 A |- X )0),  forall (b : V(0 B |- A )0),
                                   </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_identitary B A X a b = </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT B (V(0 B |- A )0) A (fun b0 =&gt; b0) X a b .
Proof.
  intros.  unfold polyV_relT_identitary. unfold polyV_relT_unitary. 
  eapply polyV_relT_arrow with (f := fun b0 =&gt; b0) (b := fun _ : unit =&gt; b).
Qed.
Notation "V(0 X |- a )1" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF _ _ _ (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV _) X &lt;o (a : V(0 _ |- F[0 _ ~&gt; X ]0 )0)) (at level 25).
   </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">
Variable polyV_relT_morphism :  forall (B : obV), forall (V : obT),
                           forall (A : obV) (W : obT) (A' : obV) (g : W -&gt; V(0 A |- A')0),
                           forall (f : V -&gt; V(0 B |- A )0) (X : obV),
                             V(1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) |- X)0
                              ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[1 g ~&gt; X ]0 ).
   </span><span class="comment-delimiter">*)</span>

  <span class="comment-delimiter">(*</span><span class="comment"> ERASE OLD: note the stronger relation (of the Coq ultimate meta logic T) ~~T instead of particular subject logic relation ~~ </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">
Hypothesis polyV_relT_arrow :  forall (B : obV), forall (A : obV),
                        forall (V V' : obT) (b : V' -&gt; V),
                        forall (f : V -&gt; V(0 B |- A )0 ) (X : obV),
                        forall (a : V(0 A |- X )0) (ttt: V'),
                          V(1 (fun v' =&gt; f (b v')) |- X )0 a ttt
                          = V(1 f |- X )0 a (b ttt).     </span><span class="comment-delimiter">*)</span>
<span class="comment-delimiter">(*</span><span class="comment">
    Definition convV_fun {dat : data}: forall (U1 U2 V1 V2 : obV dat), (V(0 U1 |- U2)0 -&gt; V(0 V1 |- V2)0) -&gt; (V(0 U1 |- U2)0 -&gt; V(0 V1 |- V2 )0) -&gt; Prop
      := fun  U1 U2 V1 V2 (w' w : (V(0 U1 |- U2)0 -&gt; V(0 V1 |- V2)0)) =&gt;
          forall u1 u2, u1 ~~ u2 -&gt; w' u1 ~~ w u2 .
    Notation "w' ~~~ w" := (convV_fun w' w)  (at level 70).
</span><span class="comment-delimiter">*)</span>
    <span class="keyword">Record</span> <span class="function-name">extras</span> {<span class="variable-name">dat</span> : data} :=
      Extras <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">ReflV</span> : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV dat) (<span class="variable-name">f</span> : V(0 A1 |- A2 )0), f ~~ f;
          TransV : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV dat) , <span class="type">forall</span> (<span class="variable-name">uTrans f</span> : V(0 A1 |- A2)0), uTrans ~~ f -&gt; <span class="type">forall</span> (<span class="variable-name">f'</span> : V(0 A1 |- A2)0), f' ~~ uTrans -&gt; f' ~~ f;
          SymV : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV dat),  <span class="type">forall</span> (<span class="variable-name">f' f</span> : V(0 A1 |- A2)0), f ~~ f' -&gt; f' ~~ f;
          Cong_polyV_relT :   <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obV dat) (<span class="variable-name">f f'</span> : T(0 V |- V(0 B |- A )0 )0),
                                (<span class="type">forall</span> _v : V, f' _v ~~ f _v) -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV dat,  <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt; <span class="type">forall</span> _v, V(1 f' |- X )0 a1 _v ~~ V(1 f |- X )0 a2 _v;
          polyV_relT_arrow :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obV dat),
                              <span class="type">forall</span> (<span class="variable-name">V V'</span> : obT) (<span class="variable-name">b</span> : V' -&gt; V),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V -&gt; V(0 B |- A )0 ) (<span class="variable-name">X</span> : obV dat),
                              <span class="type">forall</span> (<span class="variable-name">a</span> : V(0 A |- X )0), <span class="type">forall</span> (<span class="variable-name">ttt</span>: V'),
                                 V(1 (<span class="type">fun</span> <span class="variable-name">v'</span> =&gt; f (b v')) |- X )0 a ttt
                                 ~~   V(1 f |- X )0 a (b ttt);
<span class="comment-delimiter">(*</span><span class="comment">          polyV_relT_morphism :   forall (V : obT) (B A : obV dat) (W : obT) (A' : obV dat)
                                     (g : T(0 W |- V(0 A |- A' )0 )0) (f : T(0 V |- V(0 B |- idT A )0 )0)
                                     (X : obV dat),
                                     V(1 DesT
                                         ((T(1 fun
                                                 b0 : T(0 W |- [0TV(0 B |- idT A )0 ~&gt; V(0 B |- idT A' )0 ]0
                                                       )0 =&gt; b0 |- [0TV ~&gt; V(0 B |- idT A' )0 ]0 )0)
                                            ([1Tf ~&gt; V(0 B |- idT A' )0 ]0)
                                            ((T(1 fun b0 : T(0 W |- V(0 A |- A' )0 )0 =&gt; b0
                                                                                    |- [0TV(0 B |- idT A )0 ~&gt; V(0 B |- idT A' )0 ]0 )0)
                                               (V(1 ( IdenT ) |- A' )0) g)) |- X )0 ~~T
                                      DesInT (V:=V) (U0:=V(0 A' |- X )0) (U1:=W) (W:=V(0 B |- idT X )0)
                                      ((T(1 fun b0 : T(0 V(0 A' |- X )0 |- [0TW ~&gt; V(0 A |- X )0 ]0 )0 =&gt; b0
                                                                                                    |- [0TW ~&gt; [0TV ~&gt; V(0 B |- idT X )0 ]0 ]0 )0)
                                         ([0TW ~&gt; V(1 f |- X )0 ]1) (V(1 g |- X )0)); </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">        polyV_relT_morphism :   forall (V : obT) (B A : obV dat) (W : obT) (A' : obV dat)
                                    (g : T(0 W |- V(0 A |- A' )0 )0) (f : T(0 V |- V(0 B |- idT A )0 )0)
                                    (X : obV dat),
                                    V(1 DesT( ([1Tf ~&gt; V(0 B |- idT A' )0 ]0) &lt;&lt;o (V(0 A' |- g )1)) |- X )0 ~~T
                                     DesInT( ([0TW ~&gt; V(1 f |- X )0 ]1) &lt;&lt;o (V(1 g |- X )0) );
</span><span class="comment-delimiter">*)</span>
          <span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
          polyV_relT_morphism :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV dat), 
                                 <span class="type">forall</span> (<span class="variable-name">A</span> : obV dat) (<span class="variable-name">A'</span> : obV dat) (<span class="variable-name">g</span> : V(0 A |- A')0),
                                 <span class="type">forall</span> (<span class="variable-name">X</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">pull</span> : V(0 B |- A)0), <span class="type">forall</span> (<span class="variable-name">push</span> : V(0 A'  |- X )0 ),
                                    V(1I V(0 A' |- g )1 pull |- X )0 push
                                    ~~ V(0 X |- V(1I g |- X )0 push )1 pull;
          <span class="doc">(** ALT 
Hypothesis Cong_polyV_relT : forall (B : obV), forall (A : obV),
                       forall X : obV, forall (a a' : V(0 A |- X )0),
                         a' ~~ a -&gt; </span><span class="constant"><span class="doc">@</span></span><span class="doc">polyV_relT_identitary B A X a' ~~~ </span><span class="constant"><span class="doc">@</span></span><span class="doc">polyV_relT_identitary B A X a .
           **)</span>
          <span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
          polyV_relT_unitV : <span class="type">forall</span> (<span class="variable-name">A</span> : obV dat), <span class="type">forall</span> <span class="variable-name">X</span> : obV dat,  <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt; ( <span class="constant">@</span>idT (V(0 A |- X )0)  ) a1 ~~ ( V(1I (<span class="constant">@</span>IdenV _ A) |- X )0 ) a2;
          <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyV is injective **)</span>
          polyV_relT_inputUnitV : <span class="type">forall</span> (<span class="variable-name">B</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obV dat),
                              <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 B |- A )0),
                                b  ~~ ( (V(1I b |- A )0)  (<span class="constant">@</span>IdenV _ A) );
          
          CongDes : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 U |- [0 V ~&gt; W ]0 )0),
                      f' ~~ f -&gt; Des f' ~~ Des f ;
          Des_Cons : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 (0 U * V )0 |-  W )0),
                       Des (Cons f) ~~ f ;
          Des_Output : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                                  Des( [0 V ~&gt; w ]1 &lt;o v ) ~~ w &lt;o Des( v ) ;
          CongCons : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 (0 U * V )0 |- W )0 ),
                       v' ~~ v -&gt; Cons v' ~~ Cons v ;
          Cons_Des : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U |-  [0 V ~&gt; W ]0 )0),
                       Cons (Des f) ~~ f ;
          Cons_Input : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV dat) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV dat) (<span class="variable-name">v</span> : V(0 (0 U * V )0 |- W )0),
                         Cons(v &lt;o (1 w * V )0 )  ~~ Cons( v ) &lt;o w ;

        }.

    Arguments ReflV {_ _} _ _ _ .
    Arguments TransV {_ _} _ _ _ _ _ _ _ .
    Arguments SymV {_ _} _ _ _ _ _ . <span class="keyword">About</span> Cong_polyV_relT.
    Arguments Cong_polyV_relT {_ _} [_ _ _ _ _ _ _ _]  _ _ _ .
    Arguments polyV_relT_arrow {_ _} _ _ _ _ _ _ _ _ _ .
    Arguments polyV_relT_morphism {_ _} _ _ _ _ _ _ _ .
    Arguments polyV_relT_unitV {_ _} _ _ _ _ _ . 
    Arguments polyV_relT_inputUnitV {_ _} _ _ _ .
    Arguments CongDes {_ _} [_ _ _ _ _] _ .
    Arguments Des_Cons {_ _} [_ _ _] _ .
    Arguments Des_Output {_ _} [_ _ _ _ _] _ .
    Arguments CongCons {_ _} [_ _ _] _ _ _.
    Arguments Cons_Des {_ _} [_ _ _ _] .
    Arguments Cons_Input {_ _} [_ _ _ _ _] _ .
<span class="comment-delimiter">(*</span><span class="comment">    Arguments DesIn {_ _} [_ _ _ _] _ .
    Arguments DesIdenObR {_ _} [_ _] _  .
    Arguments CongDesIdenObR {_ _} [_ _ _ _] _  .
    Arguments DesIdenObR_output {_ _} [_ _ _] _ _ .
    Arguments DesIdenObL {_ _} [_ _] _  .
    Arguments ConsIdenObL {_ _} [_ _] _  .
    Arguments ConsIdenObL_DesIdenObL {_ _} [_ _] _ . 
    Arguments CongConsIdenObL {_ _} [_ _ _ _] _ .
    Arguments consV10_functorial {_ _} [_ _ _] _  _ _ .
    Arguments consV11_bifunctorial {_ _} [_ _ _ _] _ _ .
    Arguments CongConsV10 {_ _} [_ _ _ _] _ _ .
</span><span class="comment-delimiter">*)</span>    

    <span class="keyword">Lemma</span>           <span class="function-name">polyV_relT_morphism''</span> {<span class="variable-name">dat</span> : data} {<span class="variable-name">ext</span> : <span class="constant">@</span>extras dat} :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV dat), 
                                 <span class="type">forall</span> (<span class="variable-name">A</span> : obV dat) (<span class="variable-name">A'</span> : obV dat) (<span class="variable-name">g</span> : V(0 A |- A')0),
                                 <span class="type">forall</span> (<span class="variable-name">X</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">pull</span> : V(0 B |- A)0), <span class="type">forall</span> (<span class="variable-name">push</span> : V(0 A'  |- X )0 ),
                                    V(1I V(0 A' |- g )1 pull |- X )0 push
                                    ~~ V(0 X |- V(1I g |- X )0 push )1 pull.
      <span class="keyword">Check</span>           polyV_relT_morphism .
      <span class="keyword">Abort</span>.
    <span class="keyword">Lemma</span> <span class="function-name">Cong_polyV_relT'</span> {<span class="variable-name">dat</span> : data} {<span class="variable-name">ext</span> : <span class="constant">@</span>extras dat} : <span class="type">forall</span> (<span class="variable-name">B</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obV dat),
                                          <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 B |- A )0),
                               f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV dat,
                                            <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt; <span class="constant">@</span>polyV_relT_unitary dat B A f' X a1 ~~  <span class="constant">@</span>polyV_relT_unitary _ B A f X a2.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span>  (<span class="constant">@</span>Cong_polyV_relT _ ext)  <span class="type">with</span> (f:=<span class="type">fun</span> _ : unit =&gt; f)  (f':=<span class="type">fun</span> _ : unit =&gt; f'); <span class="proof-tactics-name">intros</span>; <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.
    Arguments Cong_polyV_relT' {_ _} [_ _ _ _ _ _ _] _ _ .
                                             
    <span class="keyword">Structure</span> <span class="function-name">logic</span> :=
      Logic <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; data;
          extras_of :&gt; <span class="constant">@</span>extras data_of
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> not critical, only for easy proofs without doing (extras_of _) </span><span class="comment-delimiter">*)</span>
    Existing <span class="keyword">Class</span> <span class="function-name">extras</span>. 
    <span class="keyword">Existing Instance</span> <span class="function-name">extras_of</span>. 

    <span class="keyword">Section</span> <span class="function-name">Context</span>.
      Context {<span class="variable-name">log</span> : logic}.
            
      <span class="keyword">Lemma</span> <span class="function-name">polyV_relT_unitary_rel_identitary</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV log) , <span class="type">forall</span> (<span class="variable-name">A</span> : obV log) ,
                                                              <span class="type">forall</span> <span class="variable-name">X</span> : obV log , <span class="type">forall</span> (<span class="variable-name">a</span> : V(0 A |- X )0),  <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 B |- A )0),
                                                                <span class="constant">@</span>polyV_relT_unitary log B A b X a  ~~  a &lt;o b . <span class="comment-delimiter">(*</span><span class="comment"> </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT B (V(0 B |- A )0) A (fun b0 =&gt; b0) X a b .</span><span class="comment-delimiter">*)</span>
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">unfold</span> polyV_relT_identitary. <span class="proof-tactics-name">unfold</span> polyV_relT_unitary.
        <span class="proof-tactics-name">intros</span>.  <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>polyV_relT_arrow log log) <span class="type">with</span> (f := <span class="type">fun</span> <span class="variable-name">b0</span> =&gt; b0) (b := <span class="type">fun</span> _ : unit =&gt; b).
      <span class="keyword">Qed</span>.

      <span class="keyword">Definition</span> <span class="function-name">ComV</span> : <span class="type">forall</span> (<span class="variable-name">V1</span> : obV log), <span class="type">forall</span> <span class="variable-name">UCom</span>, V(0 V1 |-  UCom )0 -&gt; <span class="type">forall</span> <span class="variable-name">V3</span>, V(0 UCom |- V3 )0 -&gt; V(0 V1 |- V3 )0 := polyV_relT_unitary .

      <span class="keyword">Lemma</span> <span class="function-name">CongCom</span> : <span class="type">forall</span> (<span class="variable-name">A2 A3</span> : obV log), <span class="type">forall</span> (<span class="variable-name">f2 f2'</span> : V(0 A2 |- A3 )0), f2 ~~ f2' -&gt; <span class="type">forall</span> <span class="variable-name">A1</span>, <span class="type">forall</span> (<span class="variable-name">f1 f1'</span> : V(0 A1 |- A2 )0), f1 ~~ f1' -&gt; f2 &lt;o f1 ~~ f2' &lt;o f1'.
      <span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">        intros. do 2 rewrite &lt;- (polyV_relT_unitary_rel_identitary ) by exact tt. Check Cong_polyV_relT'.
        pose (dd:=</span><span class="constant"><span class="comment">@</span></span><span class="comment">Cong_polyV_relT' log log). unfold convT in dd.
                                                     
        erewrite Cong_polyV_relT' with  (f':=fun _ : unit =&gt;  f2').  apply Cong_polyV_relT'.
        assumption.
        assumption. </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_unitary_rel_identitary | ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, polyV_relT_unitary_rel_identitary].
        <span class="proof-tactics-name">apply</span> Cong_polyV_relT';  <span class="coq-solve-tactics">assumption</span>.
      <span class="keyword">Qed</span>.

      <span class="keyword">Lemma</span> <span class="function-name">Cat2V</span> : <span class="type">forall</span> (<span class="variable-name">A3 A4</span> : obV log) (<span class="variable-name">f3</span> : V(0 A3 |- A4)0), <span class="type">forall</span> A2 (<span class="variable-name">f2</span> : V(0 A2 |- A3)0), <span class="type">forall</span> A1 (<span class="variable-name">f1</span> : V(0 A1 |- A2)0),
                      (f3 &lt;o f2) &lt;o f1 ~~ f3 &lt;o (f2 &lt;o f1).
      <span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">        intros. apply SymV.   About  polyV_relT_unitary_rel_identitary. About monoV_morphism.
        replace ( f3 &lt;o ( f2 &lt;o f1) ) with    ((f2 &lt;o f1) o&gt; f3) by (apply  polyV_relT_unitary_rel_identitary; exact tt).
        replace  (f3 &lt;o f2) with  (f2 o&gt; f3) by (apply  polyV_relT_unitary_rel_identitary; exact tt).
        apply polyV_relT_morphism . </span><span class="comment-delimiter">*)</span>
        <span class="comment-delimiter">(*</span><span class="comment"> OLD DEFINITIONALLY intros. apply SymV, monoV_morphism. </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_unitary_rel_identitary  |].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, polyV_relT_unitary_rel_identitary  ].
        <span class="proof-tactics-name">apply</span> SymV, polyV_relT_morphism.
      <span class="comment-delimiter">(*</span><span class="comment">replace ( f3 &lt;o ( f2 &lt;o f1) ) with    ((f2 &lt;o f1) o&gt; f3) by (apply  polyV_relT_unitary_rel_identitary; exact tt).
  replace  (f3 &lt;o f2) with  (f2 o&gt; f3) by (apply  polyV_relT_unitary_rel_identitary; exact tt). </span><span class="comment-delimiter">*)</span>
        <span class="comment-delimiter">(*</span><span class="comment"> OLD DEFINITIONALLY intros. apply SymV, polyV_relT_morphism. </span><span class="comment-delimiter">*)</span> 
      <span class="keyword">Qed</span>.

      <span class="keyword">Lemma</span> <span class="function-name">Cat1RightV</span> : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV log), <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ f &lt;o 1.
      <span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">        intros. do 1 rewrite &lt;- polyV_relT_unitary_rel_identitary by exact tt. apply polyV_relT_unitV.
        apply ReflV. </span><span class="comment-delimiter">*)</span>
       <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_unitary_rel_identitary |].
        <span class="proof-tactics-name">apply</span> polyV_relT_unitV.
        <span class="proof-tactics-name">apply</span> ReflV.
      <span class="keyword">Qed</span>.
      
      <span class="keyword">Lemma</span> <span class="function-name">Cat1LeftV</span> : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV log), <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ 1 &lt;o f.
      <span class="keyword">Proof</span>.
<span class="comment-delimiter">(*</span><span class="comment">        intros. do 1 rewrite &lt;- polyV_relT_unitary_rel_identitary by exact tt. apply polyV_relT_inputUnitV. </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_unitary_rel_identitary |].
        <span class="proof-tactics-name">apply</span> polyV_relT_inputUnitV. 
      <span class="keyword">Qed</span>.

      <span class="doc">(** later, most of the remaining fields shall be DEFINITIONS and LEMMAS **)</span>
      <span class="keyword">Definition</span> <span class="function-name">DesIn</span> : <span class="type">forall</span> {<span class="variable-name">V</span> : obV log}, <span class="type">forall</span> {<span class="variable-name">U0 U1 W</span> : obV log}, V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 -&gt; V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0.
        <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> Cons. <span class="proof-tactics-name">eapply</span> polyV_relT_identitary. <span class="keyword">Check</span> <span class="constant">@</span>Assoc. 2: <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>Assoc log _ _ _).  <span class="proof-tactics-name">eapply</span> Des.
        <span class="proof-tactics-name">eapply</span> Des. <span class="coq-solve-tactics">exact</span> H.
        <span class="keyword">Defined</span>.
      <span class="keyword">Axiom</span> <span class="variable-name">CongDesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                          v' ~~ v -&gt; DesIn v' ~~ DesIn v.
      <span class="keyword">Parameter</span> <span class="variable-name">ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0 -&gt; V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 .
      <span class="keyword">Axiom</span> <span class="variable-name">CongConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                           v' ~~ v -&gt; ConsIn v' ~~ ConsIn v .
      <span class="keyword">Axiom</span> <span class="variable-name">ConsIn_DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                             ConsIn (DesIn f) ~~ f .
      <span class="keyword">Axiom</span> <span class="variable-name">DesIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV log) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                            (DesIn v) &lt;o i ~~ DesIn( v &lt;o i ) .
      <span class="keyword">Parameter</span> <span class="variable-name">polyV_relV</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U</span> : obV log) (<span class="variable-name">V</span> : obV log),
                               V(0 U |- [0 W ~&gt; V ]0 )0 -&gt;
                               <span class="type">forall</span> <span class="variable-name">X</span> : obV log, V(0 [0 V ~&gt; X ]0  |- [0 U ~&gt; [0 W ~&gt; X ]0 ]0 )0 .
      <span class="keyword">Axiom</span> <span class="variable-name">polyV_relV_polyV_relT</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U</span> : obV log) (<span class="variable-name">V</span> : obV log),
                                    <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 W ~&gt; V ]0 )0), <span class="type">forall</span> <span class="variable-name">X</span> : obV log,
                                      [1 Des v ~&gt; X]0
                                                    ~~ DesIn( polyV_relV v X ) .
      <span class="keyword">Axiom</span> <span class="variable-name">polyV_relV_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV log) (<span class="variable-name">A</span> : obV log) (<span class="variable-name">V</span> : obV log),
                                <span class="type">forall</span> (<span class="variable-name">V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obV log),
                                  polyV_relV (f &lt;o v) X
                                             ~~ [1 v ~&gt; [0 B ~&gt; X ]0 ]0 &lt;o (polyV_relV f  X) .
    <span class="keyword">End</span> <span class="function-name">Context</span>.

    <span class="keyword">Notation</span> <span class="string">"V[0 U ~&gt; V ]0"</span> := ([0 U ~&gt; V ]0) (<span class="type">at</span> level 25, only parsing).
    <span class="keyword">Notation</span> <span class="string">"V[1 v ~&gt; X ]0"</span> := (<span class="constant">@</span>polyV_relV _ _ _ _ v X) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"V[0 X ~&gt; w ]1"</span> := (<span class="constant">@</span>polyV_relV _ _ _ _ 1 X &lt;o w) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"V[0 W ~&gt; - ]1"</span> := (<span class="type">fun</span> <span class="variable-name">V X</span> =&gt; <span class="constant">@</span>polyV_relV _ _ _ _ (<span class="constant">@</span>IdenV _ ([0 W ~&gt; V ]0)) X) (<span class="type">at</span> level 25). 

    <span class="keyword">Section</span> <span class="function-name">Context2</span>.
          Context {<span class="variable-name">log</span> : logic}.

          <span class="keyword">Parameter</span> <span class="variable-name">DesIdenObR</span> : <span class="type">forall</span> {<span class="variable-name">U W</span> : obV log}, V(0 U |- [0 I ~&gt; W ]0 )0 -&gt; V(0 U  |- W )0 .
          <span class="keyword">Axiom</span> <span class="variable-name">CongDesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U |- [0 I ~&gt; W ]0 )0),
                                   v' ~~ v -&gt; DesIdenObR v' ~~ DesIdenObR v .
          <span class="keyword">Axiom</span> <span class="variable-name">DesIdenObR_output</span> : <span class="type">forall</span> (<span class="variable-name">U</span> : obV log) (<span class="variable-name">W W'</span> : obV log) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                      DesIdenObR( [0 I ~&gt; w ]1 &lt;o v ) ~~ w &lt;o DesIdenObR( v ) .
          <span class="keyword">Parameter</span> <span class="variable-name">DesIdenObL</span> : <span class="type">forall</span> {<span class="variable-name">V</span> : obV log}, <span class="type">forall</span> {<span class="variable-name">W</span> : obV log}, V(0 I |- [0 V ~&gt; W ]0 )0 -&gt; V(0 V |- W )0 .
          <span class="keyword">Parameter</span> <span class="variable-name">ConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), V(0 V |- W )0 -&gt; V(0 I |- [0 V ~&gt; W ]0 )0 .
          <span class="keyword">Axiom</span> <span class="variable-name">ConsIdenObL_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0,
                                           v ~~ ConsIdenObL( DesIdenObL v) .
          <span class="keyword">Axiom</span> <span class="variable-name">CongConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 V |- W )0),
                                    v' ~~ v -&gt; ConsIdenObL v' ~~ ConsIdenObL v .
          <span class="keyword">Axiom</span> <span class="variable-name">consV10_functorial</span> : <span class="type">forall</span> (<span class="variable-name">V1' V1</span> : obV log) (<span class="variable-name">v</span> :  V(0 V1' |- V1 )0), <span class="type">forall</span> V1'' (<span class="variable-name">v'</span> : V(0 V1'' |- V1' )0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV log,
                                       [1 v &lt;o v' ~&gt; V2 ]0 ~~  [1 v' ~&gt; V2 ]0 &lt;o  [1 v ~&gt; V2 ]0 .
          <span class="keyword">Axiom</span> <span class="variable-name">consV11_bifunctorial</span> : <span class="type">forall</span> (<span class="variable-name">V1' V1</span> : obV log) (<span class="variable-name">v</span> : V(0 V1' |- V1 )0), <span class="type">forall</span> W1 W1' (<span class="variable-name">w</span> : V(0 W1 |- W1' )0),
                                         [0 V1' ~&gt; w ]1 &lt;o  [1 v ~&gt; W1 ]0 ~~ [1 v ~&gt; W1' ]0 &lt;o [0 V1 ~&gt; w ]1 .
          <span class="keyword">Axiom</span> <span class="variable-name">CongConsV10</span> : <span class="type">forall</span> (<span class="variable-name">V1' V1</span> : obV log) (<span class="variable-name">v v'</span> : V(0 V1' |- V1)0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV log,
                                v' ~~ v -&gt; [1 v' ~&gt; V2 ]0 ~~ [1 v ~&gt; V2 ]0 .
    <span class="keyword">End</span> <span class="function-name">Context2</span>.

    <span class="keyword">Canonical Structure</span> <span class="function-name">logT</span> : logic :=
      <span class="constant">@</span>Logic _
            (<span class="constant">@</span>Extras (Data (polyV_relT00:=polyT_relT00) convT polyT_relT 
                  (<span class="constant">@</span>IdenT) (desV00:=desT00) desT10 (consV00:=consT00) consT01 consT10 DesT
                  ConsT  (<span class="constant">@</span>unitT) (<span class="constant">@</span>AssocT)) ReflT TransT SymT Cong_polyT_relT polyT_relT_arrow
                    polyT_relT_morphism polyT_relT_unitT polyT_relT_inputUnitT CongDesT
                    Des_ConsT Des_OutputT CongConsT Cons_DesT Cons_InputT).
    <span class="keyword">Print</span> logT.
<span class="keyword">End</span> <span class="function-name">LOGIC</span>.

<span class="keyword">Module</span> <span class="function-name">FUNCTOR</span>.
  <span class="keyword">Export</span> LOGIC.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic}.

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">obA</span> : <span class="type">Type</span>;
          polyA00 : obA -&gt; obA -&gt; obV log;
          polyA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A2</span> : obA), <span class="type">forall</span> (<span class="variable-name">A1</span> : obA),
                    V(0 V |- (polyA00 A2 A1) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 (polyA00 A1 X)  |- [0 V ~&gt; (polyA00 A2 X) ]0 )0;
          obB : <span class="type">Type</span>;
          polyB00 : obB -&gt; obB -&gt; obV log;
          polyB : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B2</span> : obB),  <span class="type">forall</span>(<span class="variable-name">B1</span> : obB),
                    V(0 V |- (polyB00 B2 B1) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">Y</span> : obB, V(0 (polyB00 B1 Y)  |- [0 V ~&gt; (polyB00 B2 Y) ]0 )0;
          polyF0 : obA -&gt; obB;
          polyF : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                    V(0 V |- (polyB00 B (polyF0 A)) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 (polyA00 A X)  |- [0 V ~&gt; (polyB00 B (polyF0 X)) ]0 )0;
          unitA : <span class="type">forall</span> {<span class="variable-name">A</span> : obA}, V(0 I |- (polyA00 A A) )0;
        }.
    Existing <span class="keyword">Class</span> <span class="function-name">data</span>.
    
  <span class="keyword">End</span> <span class="function-name">Context</span>.
<span class="comment-delimiter">(*</span><span class="comment">
  Definition obA {log : logic} {obA obB : Type} {polyF0 : obA -&gt; obB} (dat : </span><span class="constant"><span class="comment">@</span></span><span class="comment">data1 log obA obB polyF0) := obA.
  Definition obB {log : logic} {obA obB : Type} {polyF0 : obA -&gt; obB} (dat : </span><span class="constant"><span class="comment">@</span></span><span class="comment">data1 log obA obB polyF0) := obB.
  Definition polyF0 {log : logic} {obA obB : Type} {polyF0 : obA -&gt; obB} (dat : </span><span class="constant"><span class="comment">@</span></span><span class="comment">data1 log obA obB polyF0) := polyF0.
 </span><span class="comment-delimiter">*)</span>

  <span class="keyword">Notation</span> <span class="string">"A[0 A1 ~&gt; A2 ]0"</span> := (<span class="constant">@</span>polyA00 _ _ A1 A2) (<span class="type">at</span> level 25).
<span class="comment-delimiter">(*</span><span class="comment">  Notation "A[0 A1 ~&gt; A2 ]0" := ((_.-A[0 A1 ~&gt; A2 ]0)%mys) (at level 25).</span><span class="comment-delimiter">*)</span>
  <span class="doc">(** therefore "A[1 f ~&gt; X ]0" is similar to ( f o&gt; _ ) **)</span>
  <span class="comment-delimiter">(*</span><span class="comment">  Notation "A[1 f ~&gt; X ]0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA _ _ _ _ _ f X) (at level 25).</span><span class="comment-delimiter">*)</span>
  <span class="keyword">Notation</span> <span class="string">"A[1 f ~&gt; X ]0"</span> := (<span class="constant">@</span>polyA _ _ _ _ _ f X) (<span class="type">at</span> level 25).
  <span class="doc">(** therefore "A[0 X ~&gt; g ]1" is similar to the common ( _ &lt;o g ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"A[0 X ~&gt; g ]1"</span> := (<span class="constant">@</span>polyA _ _ _ _ _ (<span class="constant">@</span>IdenV _ _) X &lt;o (<span class="variable-name">g</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"'uA'"</span> := (<span class="constant">@</span>unitA _ _ _) (<span class="type">at</span> level 0).
  
    <span class="keyword">Notation</span> <span class="string">"B[0 B1 ~&gt; B2 ]0"</span> := (<span class="constant">@</span>polyB00 _ _ B1 B2) (<span class="type">at</span> level 25).
    <span class="doc">(** therefore "B[1 m ~&gt; Y ]0" is similar to ( m o&gt; _ ) **)</span>
    <span class="keyword">Notation</span> <span class="string">"B[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyB _ _ _ _ _ m Y) (<span class="type">at</span> level 25).
    <span class="doc">(** therefore "B[0 Y ~&gt; n ]1" is similar to the common ( _ &lt;o n ) **)</span>
    <span class="keyword">Notation</span> <span class="string">"B[0 Y ~&gt; n ]1"</span> := (<span class="constant">@</span>polyB _ _ _ _ _ (<span class="constant">@</span>IdenV _ _) Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- B[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25).

    <span class="keyword">Module</span> <span class="function-name">Ex_Notations3</span>.
      <span class="keyword">Notation</span> <span class="string">"dat .-A[0 A1 ~&gt; A2 ]0"</span> := (<span class="constant">@</span>polyA00 _ dat A1 A2) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"A[0 A1 ~&gt; A2 ]0"</span> := (_  .-A[0 A1 ~&gt; A2 ]0) (<span class="type">at</span> level 25).
      <span class="comment-delimiter">(*</span><span class="comment">  Notation "A[0 A1 ~&gt; A2 ]0" := ((_.-A[0 A1 ~&gt; A2 ]0)%mys) (at level 25).</span><span class="comment-delimiter">*)</span>
      <span class="doc">(** therefore "A[1 f ~&gt; X ]0" is similar to ( f o&gt; _ ) **)</span>
      <span class="comment-delimiter">(*</span><span class="comment">  Notation "A[1 f ~&gt; X ]0" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA _ _ _ _ _ f X) (at level 25).</span><span class="comment-delimiter">*)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-A[1 f ~&gt; X ]0"</span> := (<span class="constant">@</span>polyA _ dat _ _ _ f X) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"A[1 f ~&gt; X ]0"</span> := (_.-A[1 f ~&gt; X ]0) (<span class="type">at</span> level 25).
      <span class="doc">(** therefore "A[0 X ~&gt; g ]1" is similar to the common ( _ &lt;o g ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-A[0 X ~&gt; g ]1"</span> := (<span class="constant">@</span>polyA _ dat _ _ _ (<span class="constant">@</span>IdenV _ _) X &lt;o (<span class="variable-name">g</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"A[0 X ~&gt; g ]1"</span> := (_.-A[0 X ~&gt; g ]1) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"dat .-uA"</span> := (<span class="constant">@</span>unitA _ dat _) (<span class="type">at</span> level 0).
      
      <span class="keyword">Notation</span> <span class="string">"dat .-B[0 B1 ~&gt; B2 ]0"</span> := (<span class="constant">@</span>polyB00 _ dat B1 B2) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"B[0 B1 ~&gt; B2 ]0"</span> := (_.-B[0 B1 ~&gt; B2 ]0) (<span class="type">at</span> level 25).
      <span class="doc">(** therefore "B[1 m ~&gt; Y ]0" is similar to ( m o&gt; _ ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-B[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyB _ dat _ _ _ m Y) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"B[1 m ~&gt; Y ]0"</span> := (_.-B[1 m ~&gt; Y ]0) (<span class="type">at</span> level 25).
      <span class="doc">(** therefore "B[0 Y ~&gt; n ]1" is similar to the common ( _ &lt;o n ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-B[0 Y ~&gt; n ]1"</span> := (<span class="constant">@</span>polyB _ dat _ _ _ (<span class="constant">@</span>IdenV _ _) Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- B[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"B[0 Y ~&gt; n ]1"</span> := (_.-B[0 Y ~&gt; n ]1) (<span class="type">at</span> level 25).
    <span class="keyword">End</span> <span class="function-name">Ex_Notations3</span>.
    
    <span class="keyword">Section</span> <span class="function-name">Context2</span>.
      Context {<span class="variable-name">log</span> : logic}.
      Context {<span class="variable-name">dat</span> : <span class="constant">@</span>data log}.
      
      <span class="keyword">Definition</span> <span class="function-name">polyA_IdenV</span>  : <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                                                 <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, V(0 A[0 A ~&gt; X ]0  |- [0 A[0 B ~&gt; A ]0 ~&gt; A[0 B ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyA _ _ (A[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV _ (A[0 B ~&gt; A ]0)) X).
      
      <span class="keyword">Definition</span> <span class="function-name">polyB_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obB dat),
                                                 <span class="type">forall</span> <span class="variable-name">X</span> : obB dat, V(0 B[0 A ~&gt; X ]0  |- [0 B[0 B ~&gt; A ]0 ~&gt; B[0 B ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyB _ _ (B[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV _ (B[0 B ~&gt; A ]0)) X).
    <span class="keyword">End</span> <span class="function-name">Context2</span>.

    <span class="keyword">Notation</span> <span class="string">"A[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyA_IdenV _ _ B) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"B[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyB_IdenV _ _ B) (<span class="type">at</span> level 25).
    
    <span class="keyword">Notation</span> <span class="string">"F|0 A"</span> := (<span class="constant">@</span>polyF0 _ _ A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).
    <span class="doc">(** :^) **)</span>
    <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (B[0 B ~&gt; F|0 A ]0) (<span class="type">at</span> level 25).
    <span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to   ( b o&gt; ( F|1 _ ) )   , alternatively   ( b o&gt;F _ )   **)</span>
    <span class="keyword">Notation</span> <span class="string">"F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ _ _ _ _ b X) (<span class="type">at</span> level 25).
    <span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to   ( B[0 B ~&gt; ( F|1 a ) ]1 ) which is ( _ o&gt; ( F|1 a ) )   , alternatively  ( _ o&gt;F a )   **)</span>
    <span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF _ _ _ _ _ (<span class="constant">@</span>IdenV _ _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

    <span class="keyword">Module</span> <span class="function-name">Ex_Notations4</span>.
      <span class="keyword">Export</span> Ex_Notations3.
      <span class="keyword">Notation</span> <span class="string">"dat .-A[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyA_IdenV _ dat B) (<span class="type">at</span> level 25, format  <span class="string">"dat .-A[0  B  ~&gt;  -  ]1"</span>).
      <span class="keyword">Notation</span> <span class="string">"dat .-B[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyB_IdenV _ dat B) (<span class="type">at</span> level 25, format <span class="string">"dat .-B[0  B  ~&gt;  -  ]1"</span>).
      
      <span class="keyword">Notation</span> <span class="string">"dat .-F|0 A"</span> := (<span class="constant">@</span>polyF0 _ dat A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"dat .-F|0  A"</span>).
      <span class="doc">(** :^) **)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-F[0 B ~&gt; A ]0"</span> := (dat.-B[0 B ~&gt; (dat.-F|0 A) ]0) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[0  B  ~&gt;  A  ]0"</span>).
      <span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to   ( b o&gt; ( F|1 _ ) )   , alternatively   ( b o&gt;F _ )   **)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ dat _ _ _ b X) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[1  b  ~&gt;  X  ]0"</span>).
      <span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to   ( B[0 B ~&gt; ( F|1 a ) ]1 ) which is ( _ o&gt; ( F|1 a ) )   , alternatively  ( _ o&gt;F a )   **)</span>
      <span class="keyword">Notation</span> <span class="string">"dat .-F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF _ dat _ _ _ (<span class="constant">@</span>IdenV _ _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[0  X  ~&gt;  a  ]1"</span>).
    <span class="keyword">End</span> <span class="function-name">Ex_Notations4</span>.
    
    <span class="keyword">Section</span> <span class="function-name">Context3</span>.
      Context {<span class="variable-name">log</span> : logic}.
      Context {<span class="variable-name">dat</span> : <span class="constant">@</span>data log}.

      <span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                               <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, V(0 A[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF _ _ (F[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV _ (F[0 B ~&gt; A ]0)) X).
      
    <span class="keyword">End</span> <span class="function-name">Context3</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV _ dat B) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (_.-F[0 B ~&gt; - ]1) (<span class="type">at</span> level 25).

    <span class="keyword">Section</span> <span class="function-name">Context4</span>.
      Context {<span class="variable-name">log</span> : logic}.
      
      <span class="keyword">Record</span> <span class="function-name">extras</span> (<span class="variable-name">dat</span> : <span class="constant">@</span>data log) :=
        Extras <span class="company-coq-featuresXcode-folding-bullet">{</span>
            <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                        <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                          f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, polyA f' X ~~ polyA f X;
            polyA_arrow :  <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                           <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                             A[1 f &lt;o v ~&gt; X ]0
                              ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0;
            polyF_arrow : <span class="type">forall</span> (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                          <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                            F[1 f &lt;o v ~&gt; X ]0
                             ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0;
            polyF_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat),
                             <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA dat) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                             <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                               F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                                ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 );
            CongPolyF : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, polyF f' X ~~ polyF f X;
            polyA_unitA : <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat), <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>unitA _ dat A) ~&gt; X ]0 );
            polyA_inputUnitA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                               <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                                 f  ~~ DesIdenObL( (A[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA _ dat A) );
            polyF_inputUnitA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                               <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                 f ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA _ dat A) )
          }.

      Existing <span class="keyword">Class</span> <span class="function-name">extras</span>. <span class="keyword">About</span> polyA_arrow.
      Global Arguments CongPolyA {_ _} [_ _ _ _ _] _ _  .
      Global Arguments polyA_arrow {_ _} [_ _ _ _] _ _ _ .
      Global Arguments polyF_arrow {_ _} [_ _ _ _] _ _  _ .
      Global Arguments polyF_morphism {_ _} [_ _ _ _ _] _ _ _ .
      Global Arguments CongPolyF {_ _} [_ _ _ _ _] _ _ . <span class="keyword">About</span> polyF_inputUnitA.
      Global Arguments polyA_unitA {_ _} _ _ .
      Global Arguments polyA_inputUnitA {_ _} [_ _ _] _ .
      Global Arguments polyF_inputUnitA {_ _} [_ _ _] _  .

    <span class="keyword">End</span> <span class="function-name">Context4</span>.

    <span class="keyword">Coercion</span> dat {<span class="variable-name">log</span> : logic} {<span class="variable-name">dat</span> : <span class="constant">@</span>data log} (<span class="variable-name">ext</span> : <span class="constant">@</span>extras log dat) := dat.

    <span class="keyword">Section</span> <span class="function-name">Context5</span>.
      <span class="keyword">Variable</span> (<span class="variable-name">log</span> : logic).

      <span class="keyword">Structure</span> <span class="function-name">functor</span> :=
        Functor <span class="company-coq-featuresXcode-folding-bullet">{</span>
            data_of :&gt; <span class="constant">@</span>data log;
            extras_of :&gt; <span class="constant">@</span>extras _ data_of
          }.

      <span class="comment-delimiter">(*</span><span class="comment"> not critical, only for easy proofs without doing (extras_of _) </span><span class="comment-delimiter">*)</span>
      Global <span class="keyword">Existing Instance</span> <span class="function-name">extras_of</span>. 
    <span class="keyword">End</span> <span class="function-name">Context5</span>.

    <span class="keyword">Section</span> <span class="function-name">Context8</span>.
      Context {<span class="variable-name">log</span> : logic}.
      Context {<span class="variable-name">dat_</span> : <span class="constant">@</span>data log}.
      Context {<span class="variable-name">func</span> : <span class="constant">@</span>extras _ dat_}.

      <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
      <span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func),
                            <span class="type">forall</span> (<span class="variable-name">V W V'</span> : obV log) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                            <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA func),
                              F[1 f &lt;o (Des v) ~&gt; X ]0
                               ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
        <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> polyF_arrow ]. 
        <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_relV_polyV_relT. 
      <span class="keyword">Qed</span>.

      <span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                            <span class="type">forall</span> (<span class="variable-name">C X</span> : obA func),
                              ( [0 A[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                                &lt;o A[0 A ~&gt; - ]1 C X )
                                ~~ ( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                     &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .
      <span class="keyword">Proof</span>.
        <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
        <span class="proof-tactics-name">apply</span> CongConsIn.

        <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0
                         ~~ DesIn( [0 A[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[0 A ~&gt; - ]1 C X ) )
          <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

        <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV _ (F[0 B ~&gt; A ]0)) &lt;o f ~&gt; C ]0 ) ~&gt; X ]0
                         ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; C ]0)) ]1 ) ~&gt; X ]0 )
          <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
               <span class="proof-tactics-name">apply</span> polyF_arrow ).

        <span class="comment-delimiter">(*</span><span class="comment"> convert right hand side : outer polyV_relV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV _ (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X )
                             ~~ DesIn( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) )
          <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
               <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
               <span class="proof-tactics-name">apply</span> polyV_relV_arrow ).

        <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV _ (F[0 B ~&gt; C ]0)) &lt;o Des( (<span class="constant">@</span>IdenV _ (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ) ~&gt; X ]0 )
                          ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV _ (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X ) )
          <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

        <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

        <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
        <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
        
        <span class="proof-tactics-name">apply</span> ReflV.
      <span class="keyword">Qed</span>.

    <span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#946;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
      <span class="type">forall</span> (<span class="variable-name">C X</span> : obA func),
        ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
          &lt;o A[0 A ~&gt; - ]1 C X )
          ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

      <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                                   natural &#966; -&gt;
                                   <span class="type">forall</span> (<span class="variable-name">X</span> : obA func),
                                     DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitA _ func A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                               ~~ ( &#966; X ) .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_arrow ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyA, SymV, Cat1LeftV ].  
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_unitA ].
    <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
  <span class="keyword">Qed</span>.
  
  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                          natural &#966; -&gt; natural &#966;' -&gt;
                          &#966;' A &lt;o (<span class="constant">@</span>unitA _ func A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitA _ func A) -&gt;
                          <span class="type">forall</span> <span class="variable-name">X</span> : obA func, &#966;' X ~~ &#966; X.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                             <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
    <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
    <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Qed</span>.

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                   natural &#966; -&gt;
                   <span class="type">forall</span> <span class="variable-name">X</span> : obA func, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA _ func A) ) ~&gt; X ]0 .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitA _ func A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA _ func A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitA _ func A) ).
    <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
    <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
    
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
    <span class="proof-tactics-name">apply</span> CongConsIdenObL.
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitA |  <span class="proof-tactics-name">apply</span> ReflV ].
  <span class="keyword">Qed</span>.

  
    <span class="keyword">End</span> <span class="function-name">Context8</span>.
  
    <span class="keyword">Check</span> <span class="type">fun</span> <span class="variable-name">log</span> =&gt; <span class="type">fun</span> <span class="variable-name">ff</span> : <span class="constant">@</span>functor log  =&gt;  polyF_arrowIn (func:=ff).
<span class="comment-delimiter">(*</span><span class="comment">    Check fun log =&gt; fun cc : </span><span class="constant"><span class="comment">@</span></span><span class="comment">category log  =&gt;  polyF_arrowIn (func:=cc).
    Check fun log =&gt; fun cc : </span><span class="constant"><span class="comment">@</span></span><span class="comment">category log  =&gt;  polyF_morphism (e:= cc).</span><span class="comment-delimiter">*)</span>


<span class="comment-delimiter">(*</span><span class="comment">
          Record data :=
            Data {
        obV : Type;
        polyV_relT00 : obV -&gt; obV -&gt; obT;
        polyV_relT : forall (T : obT), forall B : obV,  forall (A : obV),
                       T(0 T |- (polyV_relT00 B A) )0 -&gt;
                       forall (X : obV), T(0 (polyV_relT00 A X) |-  T(0 T |- (polyV_relT00 B X) )0 )0;
         IdenV : forall {V : obV}, (polyV_relT00 V V);
         desV00 : forall V2 : obV, forall V1 : obV, obV;
         desV10 : forall V2 : obV, forall V1 V1', (polyV_relT00 V1 V1') -&gt; (polyV_relT00 (desV00 V2 V1) (desV00 V2 V1'));
         consV00 : obV -&gt; obV -&gt; obV;
         consV01 : forall V1 : obV, forall V2 V2', (polyV_relT00 V2 V2') -&gt; (polyV_relT00 (consV00 V1 V2)  (consV00 V1 V2'));
         consV10 : forall V1' V1, (polyV_relT00 V1' V1) -&gt; forall V2 : obV, (polyV_relT00 (consV00 V1 V2) (consV00 V1' V2));
         Des : forall V : obV, forall (U W : obV), (polyV_relT00 U (consV00 V W)) -&gt; (polyV_relT00 (desV00 V U) W);
         Cons : forall V : obV, forall (U W : obV), (polyV_relT00 (desV00 V U) W) -&gt; (polyV_relT00 U (consV00 V W));
         IdenObV : obV;
         unitV : forall {A : obV}, (polyV_relT00 IdenObV (consV00 A A) )
        }.
 </span><span class="comment-delimiter">*)</span>

<span class="keyword">End</span> <span class="function-name">FUNCTOR</span>.

<span class="keyword">Module</span> <span class="function-name">CATEGORY</span>.
  <span class="keyword">Import</span> FUNCTOR.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.

    <span class="keyword">Section</span> <span class="function-name">Context6</span>.
      Context {<span class="variable-name">log</span> : logic}.

      <span class="keyword">Record</span> <span class="function-name">data</span> :=
        Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
            <span class="variable-name">obA</span> : <span class="type">Type</span>;
            polyA00 : obA -&gt; obA -&gt; obV log;
            polyA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A2</span> : obA), <span class="type">forall</span> (<span class="variable-name">A1</span> : obA),
                      V(0 V |- (polyA00 A2 A1) )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 (polyA00 A1 X)  |- [0 V ~&gt; (polyA00 A2 X) ]0 )0;
            unitA : <span class="type">forall</span> <span class="variable-name">A</span> : obA, V(0 I |- polyA00 A A )0;
          }.
      Existing <span class="keyword">Class</span> <span class="function-name">data</span>.

      <span class="keyword">Coercion</span> dataFun_of_dataCat (<span class="variable-name">d</span> : data)
      : <span class="constant">@</span>FUNCTOR.data log := {|
                      FUNCTOR.obA := obA d;
                      FUNCTOR.polyA00 := <span class="constant">@</span>polyA00 d;
                      FUNCTOR.polyA := <span class="constant">@</span>polyA d;
                      FUNCTOR.obB := obA d;
                      FUNCTOR.polyB00 := <span class="constant">@</span>polyA00 d;
                      FUNCTOR.polyB := <span class="constant">@</span>polyA d;
                      FUNCTOR.polyF0 := (<span class="constant">@</span>idT (obA d));
                      FUNCTOR.polyF := <span class="constant">@</span>polyA d;
                      FUNCTOR.unitA := <span class="constant">@</span>unitA d|}.

      Global Arguments dataFun_of_dataCat : <span class="proof-tactics-name">simpl</span> never.

      <span class="keyword">Record</span> <span class="function-name">extras</span> {<span class="variable-name">dat</span> : data} :=
        Extras <span class="company-coq-featuresXcode-folding-bullet">{</span>
            <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> : FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : FUNCTOR.obA dat),
                        <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                          f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : FUNCTOR.obA dat, polyA f' X ~~ polyA f X;
            polyA_arrow :  <span class="type">forall</span> (<span class="variable-name">B</span> : FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : FUNCTOR.obA dat),
                           <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> :  FUNCTOR.obA dat),
                             A[1 f &lt;o v ~&gt; X ]0
                              ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0;
            polyF_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> :  FUNCTOR.obB dat),
                             <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> :  FUNCTOR.obA dat) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                             <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                               F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                                ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 );
            polyA_unitA : <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat), <span class="type">forall</span> <span class="variable-name">X</span> :  FUNCTOR.obA dat, (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>FUNCTOR.unitA _ dat A) ~&gt; X ]0 );
            polyA_inputUnitA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> :  FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat),
                               <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                                 f  ~~ DesIdenObL( (A[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>FUNCTOR.unitA _ dat A) );
          }.

      Existing <span class="keyword">Class</span> <span class="function-name">extras</span>.
      Global Arguments CongPolyA {_ _} [_ _ _ _ _] _ _  .
      Global Arguments polyA_arrow {_ _} [_ _ _ _] _ _ _ .
      Global Arguments polyF_morphism {_ _} [_ _ _ _ _] _ _ _ .
      Global Arguments polyA_unitA {_ _} _ _ .
      Global Arguments polyA_inputUnitA {_ _} [_ _ _] _ .

      <span class="keyword">Coercion</span> extrasFun_of_extrasCat (<span class="variable-name">d</span> : data) (<span class="variable-name">e</span> : <span class="constant">@</span>extras  d)
      : <span class="constant">@</span>FUNCTOR.extras log (dataFun_of_dataCat d) := 
        {|
          FUNCTOR.CongPolyA := CongPolyA;
          FUNCTOR.polyA_arrow := polyA_arrow;
          FUNCTOR.polyF_arrow := polyA_arrow;
          FUNCTOR.polyF_morphism := polyF_morphism;
          FUNCTOR.CongPolyF := CongPolyA;
          FUNCTOR.polyA_unitA := polyA_unitA;
          FUNCTOR.polyA_inputUnitA := polyA_inputUnitA;
          FUNCTOR.polyF_inputUnitA := polyA_inputUnitA |}.

      Global Arguments extrasFun_of_extrasCat : <span class="proof-tactics-name">simpl</span> never.
      
    <span class="keyword">End</span> <span class="function-name">Context6</span>.

    <span class="keyword">Section</span> <span class="function-name">Context6'</span>.
      <span class="keyword">Structure</span> <span class="function-name">category</span> (<span class="variable-name">log</span> : logic) :=
        Category <span class="company-coq-featuresXcode-folding-bullet">{</span>
            data_of :&gt; <span class="constant">@</span>data log;
            extras_of :&gt; <span class="constant">@</span>extras  log (data_of)
          }.

      <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
      Global <span class="keyword">Existing Instance</span> <span class="function-name">extras_of</span>.

      <span class="keyword">Coercion</span> functor_of_category {<span class="variable-name">log</span> : logic} (<span class="variable-name">c</span> : <span class="constant">@</span>category log)
      : <span class="constant">@</span>FUNCTOR.functor log :=  {| FUNCTOR.data_of := data_of c; FUNCTOR.extras_of := extras_of c |}.
      <span class="comment-delimiter">(*</span><span class="comment"> false ambiguity : new coercion produce same output as old coercion ; the new coercion will be used to coerce but also the notational hiddenness/implicitness of old coercion is kept for printing </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Canonical Structure</span> <span class="function-name">functor_of_category</span>.
      
    <span class="keyword">End</span> <span class="function-name">Context6'</span>.

    <span class="keyword">Export</span> FUNCTOR.
<span class="keyword">End</span> <span class="function-name">CATEGORY</span>.

<span class="keyword">Module</span> <span class="function-name">FUNCTORTOCAT</span>.
  <span class="keyword">Export</span> CATEGORY.
  <span class="keyword">Import</span> Ex_Notations4.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">from</span> : <span class="constant">@</span>category log) (<span class="variable-name">to</span> : <span class="constant">@</span>category log).
    
    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
        <span class="variable-name">polyF0</span> : obA from -&gt; obA to;
        polyF :   <span class="type">forall</span> {<span class="variable-name">V</span> : obV log}{<span class="variable-name">B</span> : obA to} {<span class="variable-name">A</span> : obA from},
                    V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA from,
                      V(0 from .-A[0 A ~&gt; X ]0 |- [0V ~&gt; to .-A[0 B ~&gt; polyF0 X ]0 ]0 )0;
        }.

    Existing <span class="keyword">Class</span> <span class="function-name">data</span>.

    <span class="keyword">Record</span> <span class="function-name">extras</span> {<span class="variable-name">dat</span> : data} :=
      Extras <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">polyF_arrow</span> :    <span class="type">forall</span> {<span class="variable-name">B</span> : obA to} {<span class="variable-name">A</span> : obA from} {<span class="variable-name">V V'</span> : obV log} 
                           (<span class="variable-name">v</span> : V(0 V' |- V )0) (<span class="variable-name">f</span> : V(0 V |- to .-A[0 B ~&gt; polyF0 dat A ]0 )0)
                           (<span class="variable-name">X</span> : obA from),
                           polyF  (f &lt;o v) X ~~
                                 [1v ~&gt; to .-A[0 B ~&gt; polyF0 dat X ]0 ]0 &lt;o polyF f X ;
          polyF_morphism :    <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA to) (<span class="variable-name">A</span> : obA from) 
                                (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA from) (<span class="variable-name">g</span> : V(0 W |- from .-A[0 A ~&gt; A' ]0 )0)
                                (<span class="variable-name">f</span> : V(0 V |- to .-A[0 B ~&gt; polyF0 dat A ]0 )0) (<span class="variable-name">X</span> : obA from),
                                polyF 
                                      (Des
                                         ([1f ~&gt; to .-A[0 B ~&gt; polyF0 dat A' ]0 ]0 &lt;o
                                                                                  polyF  1 A' &lt;o g)) X ~~
                                      DesIn ([0W ~&gt; polyF  f X ]1 &lt;o from .-A[1 g ~&gt; X ]0) ;
          CongPolyF :    <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA to) (<span class="variable-name">A</span> : obA from)
                           (<span class="variable-name">f f'</span> : V(0 V |- to .-A[0 B ~&gt; polyF0 dat A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA from, polyF  f' X ~~ polyF f X;
          polyF_inputUnitA :    <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA to) (<span class="variable-name">A</span> : obA from)
                                  (<span class="variable-name">f</span> : V(0 V |- to .-A[0 B ~&gt; polyF0 dat A ]0 )0),
                                  f ~~ DesIdenObL (polyF  f A &lt;o (from) .-uA)
        }.

    Existing <span class="keyword">Class</span> <span class="function-name">extras</span>.

    <span class="keyword">Coercion</span> dataFun_of_dataFuntoCat (<span class="variable-name">d</span> : data)
      : <span class="constant">@</span>FUNCTOR.data log :=  {|
                    FUNCTOR.obA := <span class="constant">@</span>obA _ from;
                    FUNCTOR.polyA00 := <span class="constant">@</span>polyA00 _ from;
                    FUNCTOR.polyA := <span class="constant">@</span>polyA _ from;
                    FUNCTOR.obB := <span class="constant">@</span>obA _ to;
                    FUNCTOR.polyB00 := <span class="constant">@</span>polyA00 _ to;
                    FUNCTOR.polyB := <span class="constant">@</span>polyA _ to;
                    FUNCTOR.polyF0 := polyF0 d;
                    FUNCTOR.polyF := <span class="constant">@</span>polyF d;
                    FUNCTOR.unitA := <span class="constant">@</span>unitA _ from |}.

    Global Arguments dataFun_of_dataFuntoCat : <span class="proof-tactics-name">simpl</span> never.

    <span class="keyword">Coercion</span> extrasFun_of_extrasFuntoCat (<span class="variable-name">dat</span> : data) (<span class="variable-name">ext</span> : extras)  :  <span class="constant">@</span>FUNCTOR.extras log dat :=
      FUNCTOR.Extras (dat:=dat) (<span class="constant">@</span>CongPolyA _ _ from) (<span class="constant">@</span>polyA_arrow _ _ from) (<span class="constant">@</span>polyF_arrow dat ext)
                     (<span class="constant">@</span>polyF_morphism _ ext) (<span class="constant">@</span>CongPolyF _ ext) (<span class="constant">@</span>polyA_unitA _ _ from) (<span class="constant">@</span>polyA_inputUnitA _ _ from)
                     (<span class="constant">@</span>polyF_inputUnitA _ ext).

    Global Arguments extrasFun_of_extrasFuntoCat : <span class="proof-tactics-name">simpl</span> never.
    
    <span class="keyword">Structure</span> <span class="function-name">functorToCat</span> :=
      FunctorToCat <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; data;
          extras_of :&gt; <span class="constant">@</span>extras (data_of)
        }.

      <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
      Global <span class="keyword">Existing Instance</span> <span class="function-name">extras_of</span>.

      <span class="keyword">Coercion</span> functor_of_functorToCat (<span class="variable-name">func</span> : functorToCat)
      : <span class="constant">@</span>FUNCTOR.functor log :=  {| FUNCTOR.data_of := data_of func; FUNCTOR.extras_of := extras_of func |}.
      <span class="comment-delimiter">(*</span><span class="comment"> false ambiguity : new coercion produce same output as old coercion ; the new coercion will be used to coerce but also the notational hiddenness/implicitness of old coercion is kept for printing </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Canonical Structure</span> <span class="function-name">functor_of_functorToCat</span>.

      <span class="keyword">Definition</span> <span class="function-name">polyF_unitB</span> {<span class="variable-name">func</span> : functorToCat} : <span class="type">forall</span> (<span class="variable-name">A</span> : obA from),
                               <span class="type">forall</span> <span class="variable-name">X</span> : obA from, V(0 from.-A[0 A ~&gt; X ]0  |- to.-A[0 func.-F|0 A ~&gt; func.-F|0 X ]0 )0.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">apply</span> DesIdenObR.
        <span class="proof-tactics-name">eapply</span> polyF.
        <span class="proof-tactics-name">apply</span> (<span class="constant">@</span>unitA _ to).
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
        <span class="comment-delimiter">(*</span><span class="comment"> (fun (func : functorToCat) (A X : obA from) =&gt;
 DesIdenObR (polyF (d:=func) (to) .-uA X)) </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

  <span class="keyword">End</span> <span class="function-name">Context</span>.
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations6</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-F|1"</span> := (<span class="constant">@</span>polyF_unitB _ _ _ dat) (<span class="type">at</span> level 0, format <span class="string">"dat .-F|1"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations6</span>.
  <span class="keyword">Import</span> Ex_Notations6.
  <span class="keyword">Notation</span> <span class="string">"F|1"</span> := (_ .-F|1) (<span class="type">at</span> level 0).
  
  <span class="comment-delimiter">(*</span><span class="comment">
     Variables (d : data) (e : </span><span class="constant"><span class="comment">@</span></span><span class="comment">extras  d).
      Definition functor_fromto (*
                 (polyF0 : obA from -&gt; obA to)
                 (polyF :   forall (V : obV log) (B : obA to) (A : obA from),
   V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0 -&gt;
   forall X : obA from,
     V(0 from .-A[0 A ~&gt; X ]0 |- [0V ~&gt; to .-A[0 B ~&gt; polyF0 X ]0 ]0 )0)
                 (polyF_arrow :    forall (B : obA to) (A : obA from) (V V' : obV log) 
     (v : V(0 V' |- V )0) (f : V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0)
     (X : obA from),
   polyF V' B A (f &lt;o v) X ~~
         [1v ~&gt; to .-A[0 B ~&gt; polyF0 X ]0 ]0 &lt;o polyF V B A f X )
                 (polyF_morphism :    forall (V : obV log) (B : obA to) (A : obA from) 
     (W : obV log) (A' : obA from) (g : V(0 W |- from .-A[0 A ~&gt; A' ]0 )0)
     (f : V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0) (X : obA from),
   polyF ((0W * V )0) B A'
     (Des
        ([1f ~&gt; to .-A[0 B ~&gt; polyF0 A' ]0 ]0 &lt;o
         polyF (to .-A[0 B ~&gt; polyF0 A ]0) B A 1 A' &lt;o g)) X ~~
     DesIn ([0W ~&gt; polyF V B A f X ]1 &lt;o from .-A[1 g ~&gt; X ]0) )
                 (CongPolyF :    forall (V : obV log) (B : obA to) (A : obA from)
     (f f' : V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0),
                                   f' ~~ f -&gt; forall X : obA from, polyF V B A f' X ~~ polyF V B A f X)
                 (polyF_inputUnitA :    forall (V : obV log) (B : obA to) (A : obA from)
     (f : V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0),
                                          f ~~ DesIdenObL (polyF V B A f A &lt;o (from) .-uA))
                 *)
      : </span><span class="constant"><span class="comment">@</span></span><span class="comment">FUNCTOR.functor log.
        econstructor; cycle 1. Unshelve. Focus 2.
        econstructor.
        eexact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA _ from).
        eexact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA _ to).
        Unshelve. Focus 3.  eexact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF0 d). Show Proof. exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF d). exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitA _ from).
        
        econstructor;   cbn. Show Proof. exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">CongPolyA _ _ from).
        Show Proof. exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA_arrow _ _ from).
        Show Proof. 
        exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF_arrow _ e).
        Show Proof.
        exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF_morphism _ e).
        Show Proof.
        exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">CongPolyF _ e).
        exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA_unitA _ _ from).
        exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyA_inputUnitA _ _ from).
        Show. exact (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF_inputUnitA _ e). Show Proof.
      Defined.
</span><span class="comment-delimiter">*)</span>

<span class="comment-delimiter">(*</span><span class="comment">
    Definition cst {T : Type} : T -&gt; unit := fun x : T =&gt; tt.
    
    Section Context7.
      Context {log : logic}.
      
      Record data'' :=
        Data'' {
            obA_'' : Type;
            data1_of'' :&gt; </span><span class="constant"><span class="comment">@</span></span><span class="comment">data1 log obA_'' unit (</span><span class="constant"><span class="comment">@</span></span><span class="comment">cst obA_'')
          }.
      
      Structure metafunctor :=
        Metafunctor {
            data_of'' :&gt; data'';
            extras_of'' :&gt; </span><span class="constant"><span class="comment">@</span></span><span class="comment">extras _ _ _ _ (</span><span class="constant"><span class="comment">@</span></span><span class="comment">data1_of'' data_of'')
          }.

    End Context7.
    </span><span class="comment-delimiter">*)</span>



  <span class="comment-delimiter">(*</span><span class="comment">TO REDO
        (*            Open Scope Ex_scope. *)
      Import Ex_Notations.
      Import Ex_Notations2.
Axiom      functional_extensionality_dep : forall {A} {B : A -&gt; Type},
  forall (f g : forall x : A, B x),
  (forall x, f x = g x) -&gt; f = g.
      Definition catV (logV : logic ) (pf : </span><span class="constant"><span class="comment">@</span></span><span class="comment">convV logV = fun V1 V2 =&gt; (eq : V(0 V1 |- V2 )0 -&gt; V(0 V1 |- V2 )0 -&gt; Prop) )
      (pf2: forall (V : obT) (B A : obV logV) (f f' : T(0 V |- V(0 B |- A )0 )0),
(forall _v : V,   f' _v ~~ f _v) -&gt;
forall (X : obV logV) (a1 a2 : V(0 A |- X )0),
a1 ~~ a2 -&gt;
(forall _v : V,  (V(1 f' |- X )0) a1 _v ~~ (V(1 f |- X )0) a2 _v) -&gt;
 (V(1 f' |- X )0) = (V(1 f |- X )0)
 ) : </span><span class="constant"><span class="comment">@</span></span><span class="comment">category logT.
      econstructor.
      Unshelve.
      Focus 2.
      econstructor.
      Unshelve. Focus 3. eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">obV logV).
      Focus 3. eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT00 logV).
      
      eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT logV).
      intros. intro. eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV logV). 

      econstructor;simpl. Show Proof. Show.

      simpl.    generalize (</span><span class="constant"><span class="comment">@</span></span><span class="comment">Cong_polyV_relT (LOGIC.data_of logV) (LOGIC.extras_of logV)) .
      intros. simpl in H.  Check convV.   Eval unfold convV in H. Check H.  erewrite  !pf in *.
      Check  V(1 f' |- X )0.  eapply pf2. rewrite H0. reflexivity. reflexivity.
      apply H. rewrite H0. reflexivity. reflexivity.

      simpl.  generalize (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_arrow (LOGIC.data_of logV) (LOGIC.extras_of logV)) .
      intros.  erewrite  !pf in *.
      simpl. unfold polyT_relT. unfold consT10. simpl.
      apply functional_extensionality_dep. intro.
      apply functional_extensionality_dep. intro. apply H.
Show Proof.
      simpl.  generalize (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_morphism (LOGIC.data_of logV) (LOGIC.extras_of logV)) .
      intros.  erewrite  !pf in *.
      simpl. unfold polyT_relT. unfold consT10, consT01. 
      apply functional_extensionality_dep. intro.
      apply functional_extensionality_dep. intro. simpl. unfold DesT. simpl.  unfold DesIn.  unfold Cons. unfold Des. simpl.
      unfold DesT. simpl. unfold ConsT. simpl. unfold polyT_relT. simpl.   unfold polyV_relT_unitary in *. unfold polyV_relT_identitary in *.   simpl in *.  eapply   H. erewrite &lt;- H. 

      simpl.
      eapply H in pf2. About Cong_polyV_relT. unfold polyV_relT. 
      shelve.
      simpl.
      shelve.
      simpl. Show Proof. Print extras. intros. intro.  Check polyV_relT_arrow. Show Proof. eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_arrow (LOGIC.data_of logV) (LOGIC.extras_of logV) ). .  intro.  eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_arrow logV).
      </span><span class="comment-delimiter">*)</span>

  <span class="keyword">Export</span> FUNCTOR.
<span class="keyword">End</span> <span class="function-name">FUNCTORTOCAT</span>.
                                                                                                                                                                                    

<span class="keyword">Module</span> <span class="function-name">TRANSFORMATION</span>.
  <span class="keyword">Import</span> FUNCTORTOCAT.
  <span class="keyword">Import</span> Ex_Notations4.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : category log} {<span class="variable-name">catB</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funG</span> : functorToCat catA catB).

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">poly&#946;</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">A</span> : obA catA),
                        V(0 V |- funF.-F[0 B ~&gt; A ]0 )0 -&gt;
                        V(0 V |- funG.-F[0 B ~&gt; A ]0 )0
        }.

  <span class="keyword">End</span> <span class="function-name">Context</span>.

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations5</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-&#946;|1 f"</span> := (<span class="constant">@</span>poly&#946; _ _ _ _ _ dat _ _ _ f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"dat .-&#946;|1  f"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-&#946;|0 A"</span> := (<span class="constant">@</span>poly&#946; _ _ _ _ _ dat _ _ A (<span class="constant">@</span>IdenV _)) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"dat .-&#946;|0  A"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations5</span>.

  <span class="keyword">Import</span> Ex_Notations5.
  <span class="keyword">Notation</span> <span class="string">"&#946;|1 f"</span> := (_.-&#946;|1 f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity).
  <span class="keyword">Notation</span> <span class="string">"&#946;|0 A"</span> := (_.-&#946;|0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : category log} {<span class="variable-name">catB</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funG</span> : functorToCat catA catB).
  

    <span class="keyword">Record</span> <span class="function-name">extras</span> {<span class="variable-name">dat</span> : data funF funG} :=
      Extras <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">poly&#946;_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">A</span> : obA catA),
                        <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
                           dat.-&#946;|1 (f &lt;o v)
                              ~~ dat.-&#946;|1 f &lt;o v;
          <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
          poly&#946;_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA catB),
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obA catA) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA catA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
                             dat.-&#946;|1 (Des( [1 f ~&gt; funF.-F[0 B ~&gt; A' ]0 ]0 &lt;o funF.-F[0 A' ~&gt; a ]1 ))
                                 ~~ (Des( [1 dat.-&#946;|1 f ~&gt; funG.-F[0 B ~&gt; A' ]0 ]0 &lt;o funG.-F[0 A' ~&gt; a ]1 )) ;
          poly&#946;_morphism_codomain : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log),
                                    <span class="type">forall</span> (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">B'</span> : obA catB) (<span class="variable-name">b</span> : V(0 W |- catB.-A[0 B' ~&gt; B]0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA catA),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-funF.-F[0 B ~&gt; A ]0 )0),
                                      dat.-&#946;|1 (Des( catB.-A[1 b ~&gt; funF.-F|0 A ]0 &lt;o f ))
                                          ~~  Des( catB.-A[1 b ~&gt; funG.-F|0 A ]0 &lt;o dat.-&#946;|1 f );
        }.

    Existing <span class="keyword">Class</span> <span class="function-name">extras</span>.

    <span class="keyword">Structure</span> <span class="function-name">transformation</span> :=
      Transf <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; data funF funG;
          extras_of :&gt; <span class="constant">@</span>extras (data_of)
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">extras_of</span>.

  <span class="keyword">End</span> <span class="function-name">Context2</span>.
<span class="keyword">End</span> <span class="function-name">TRANSFORMATION</span>.

<span class="keyword">Module</span> <span class="function-name">FUNCOMP</span>.
  <span class="keyword">Import</span> FUNCTORTOCAT.
  <span class="keyword">Import</span> Ex_Notations4.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : category log} {<span class="variable-name">catB</span> : category log} {<span class="variable-name">catC</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funF'</span> : functorToCat catB catC).

    <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F</span> :
      <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">A</span> : obA catA),
      <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 V |- catB.-A[0 B ~&gt; funF.-F|0 A ]0 )0),
      <span class="type">forall</span> (<span class="variable-name">W</span> : obV log) (<span class="variable-name">C</span> : obA catC),
      <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- catC.-A[0 C ~&gt; funF'.-F|0 B]0 )0),
      <span class="type">forall</span> <span class="variable-name">X</span> : obA catA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; [0 W ~&gt; catC.-A[0 C ~&gt; funF'.-F|0 funF.-F|0 X ]0 ]0 ]0 )0.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">eapply</span> <span class="constant">@</span>polyV_relT_identitary <span class="comment-delimiter">(*</span><span class="comment"> _ &lt;o _ </span><span class="comment-delimiter">*)</span>. <span class="proof-tactics-name">apply</span> consV01.
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>FUNCTOR.polyF log funF' _ _ _ c).
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>FUNCTOR.polyF log funF _ _ _ b).
    <span class="keyword">Defined</span>.

    <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F_simple</span> :
      <span class="type">forall</span>  (<span class="variable-name">A</span> : obA catA),
      <span class="type">forall</span> (<span class="variable-name">W</span> : obV log) (<span class="variable-name">C</span> : obA catC),
      <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- catC.-A[0 C ~&gt; funF'.-F|0 funF.-F|0 A ]0 )0),
      <span class="type">forall</span> <span class="variable-name">X</span> : obA catA, V(0 A[0 A ~&gt; X ]0  |- [0 W ~&gt; catC.-A[0 C ~&gt; funF'.-F|0 funF.-F|0 X ]0 ]0 )0.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">apply</span> DesIdenObR.
      <span class="proof-tactics-name">eapply</span> composition_F'_after_F.
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>unitA _ catB).
      <span class="coq-solve-tactics">exact</span> c.
    <span class="keyword">Defined</span>.

     Unset Printing Implicit Defensive.
     <span class="keyword">Definition</span> <span class="function-name">data_of_funComp</span> : FUNCTORTOCAT.data catA catC :=
       {|
         FUNCTORTOCAT.polyF0 := <span class="type">fun</span> <span class="variable-name">A</span>  =&gt; funF'.-F|0 funF.-F|0 A;
         FUNCTORTOCAT.polyF := <span class="type">fun</span> <span class="variable-name">V C A c X</span> =&gt;  composition_F'_after_F_simple c X |}.
     <span class="comment-delimiter">(*</span><span class="comment"> econstructor.
     Unshelve. 2: intro A; exact (funF'.-F|0 funF.-F|0 A).
     intros; eapply composition_F'_after_F_simple. assumption.
     </span><span class="comment-delimiter">*)</span>
     <span class="keyword">Definition</span> <span class="function-name">extras_of_funComp</span> : <span class="constant">@</span>FUNCTORTOCAT.extras _ _ _ data_of_funComp.
       <span class="coq-cheat">Admitted</span>.

     <span class="keyword">Definition</span> <span class="function-name">funComp</span> : functorToCat catA catC :=
       {|
         FUNCTORTOCAT.data_of := data_of_funComp;
         FUNCTORTOCAT.extras_of := extras_of_funComp |}.

     <span class="keyword">Lemma</span> <span class="function-name">composition_F'_after_F_identitary_polyF'_identitary_polyF_unitary</span> :    <span class="type">forall</span> (<span class="variable-name">C</span> : obA catC) (<span class="variable-name">A X</span> : obA catA),
                                                                                    (funF'.-F[0 C ~&gt; - ]1) funF.-F|0 A funF.-F|0 X &lt;o F|1 A X ~~ (funComp.-F[0 C ~&gt; - ]1) A X.
     <span class="keyword">Proof</span>.
       <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> SymV, DesIdenObR_output.
     <span class="keyword">Qed</span>.
  <span class="keyword">End</span> <span class="function-name">Context</span>.
<span class="keyword">End</span> <span class="function-name">FUNCOMP</span>.


    <span class="comment-delimiter">(*</span><span class="comment">            &gt;&gt;&gt;---   NEXT IS WHY : ALL THIS WORK OF INTERFACING FOR INSTANCES WAS DONE  ---&lt;&lt;&lt;   

apply this to unfold this as identitary (external-structural) of composition of polyfunctors ( polyV_relV o (poly_of_meta F[0 B ~&gt; - ]1) ) .. ( polyV_relV o (poly_of_meta metaFB) )  ...  show before that
1. NEXT1 some metafunctor metaFB into catV on top of F[0 B ~&gt; - ]1  by polyF which becomes  metaFB := meta_of_poly F at B,
2. then get derived polyfunctor from this metafunctor, 
3. then unitary( |1 ) of this derived polyfunctor is  identitary( ||1 ) of the metafunctor metaFB on top of F[0 B ~&gt; - ]1 
4. NEXT2 which is  identitary ( [B ~&gt; - ]1 ) of original polyfunctor F
 
all: ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A' X   
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (meta_of_poly F at B)||1 A' X    
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o FB||1 A' X    
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (poly_of_meta metaFB)|1 A' X
       (polyV_relV o (poly_of_meta metaFB))[0 V ~&gt; - ]1 A' X
       (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X

  Definition natural (V : obV) (B : obB) (A : obA) (&#946; : forall X : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
                        forall (C X : obA),
                          ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
                            &lt;o A[0 A ~&gt; - ]1 C X )
                            ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

  Definition natural (V : obV) (B : obB) (A : obA) 
                        (&#946; : forall X : obA, V(0 (meta_of_poly polyA at A)|0 X  |- (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X )0) :=
                        forall (A' X : obA),
                          ( [0 (meta_of_poly polyA at A)|0 A' ~&gt; &#946; X ]1
                            &lt;o (meta_of_poly polyA at A)||1 A' X )
                            ~~ ( [1 &#946; A' ~&gt; (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X ]0
                                 &lt;o (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X ) .
      ... == natural_metatransformation from (meta_of_poly polyA at A) to (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V) by &#946; at A' at X

NEXT3: naturality of any metatransformation of any metafunctors &lt;-&gt; polymorphism of coresp polytransformation of coresp polyfuntors
NEXT4: rewrite natural as above

     </span><span class="comment-delimiter">*)</span>




     


<span class="doc">(** SOURCE SCRATCH DRAFT BELOW **)</span>
      
<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put functional monoidal logic onto V</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">desV00</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> <span class="variable-name">V1</span> : obV, obV.
<span class="keyword">Notation</span>  <span class="string">"(0 V1 * V2 )0"</span> := (desV00 V2 V1) (<span class="type">at</span> level 30, V1 <span class="type">at</span> next level).
<span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">V2 V1</span> =&gt; (0 V1 *  V2 )0  ).
<span class="keyword">Variable</span> <span class="variable-name">desV10</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> V1 V1' (<span class="variable-name">v</span> : V(0 V1 |- V1' )0),  V(0 (0 V1* V2 )0 |- (0 V1' * V2 )0 )0.
<span class="keyword">Notation</span>  <span class="string">"(1 v * V2 )0"</span> := (desV10 V2 v) (<span class="type">at</span> level 30, v <span class="type">at</span> next level).
<span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">V2 v</span> =&gt; (1 v *  V2 )0  ).

<span class="keyword">Variable</span> <span class="variable-name">consV00</span> : obV -&gt; obV -&gt; obV.
<span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; V2 ]0"</span> := (consV00 V1 V2) (<span class="type">at</span> level 30).
<span class="keyword">Variable</span> <span class="variable-name">consV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : V(0 V2 |- V2' )0), V(0 [0 V1 ~&gt; V2 ]0 |- [0 V1 ~&gt; V2' ]0 )0.
<span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; v ]1"</span> := (consV01 V1 v) (<span class="type">at</span> level 30).
<span class="keyword">Variable</span> <span class="variable-name">consV10</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : V(0 V1' |- V1)0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV, V(0 [0 V1 ~&gt; V2 ]0 |- [0 V1' ~&gt; V2 ]0 )0.
<span class="keyword">Notation</span> <span class="string">"[1 v ~&gt; V2 ]0"</span> := (consV10 v V2) (<span class="type">at</span> level 30).

<span class="keyword">Variable</span> <span class="variable-name">Des</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 U |- [0 V ~&gt; W ]0 )0 -&gt; V(0 (0 U * V )0  |- W )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongDes</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 U |- [0 V ~&gt; W ]0 )0),
                       f' ~~ f -&gt; Des f' ~~ Des f.
<span class="keyword">Variable</span> <span class="variable-name">DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 -&gt; V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0.
<span class="keyword">Variable</span> <span class="variable-name">CongDesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                       v' ~~ v -&gt; DesIn v' ~~ DesIn v.
<span class="keyword">Variable</span> <span class="variable-name">ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0 -&gt; V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                          v' ~~ v -&gt; ConsIn v' ~~ ConsIn v.
<span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                            ConsIn (DesIn f) ~~ f.
<span class="keyword">Hypothesis</span> <span class="variable-name">DesIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                           (DesIn v) &lt;o i ~~ DesIn( v &lt;o i ).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get the definition of polymorph category F</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">obF</span> : <span class="type">Type</span>.
<span class="keyword">Variable</span> <span class="variable-name">polyF00</span> : obF -&gt; obF -&gt; obV.
<span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (polyF00 B A) (<span class="type">at</span> level 25).

<span class="keyword">Parameter</span> <span class="variable-name">polyF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                    V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0.

<span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to ( b o&gt; _ ) **)</span>
<span class="keyword">Notation</span> <span class="string">"F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ _ _ b X) (<span class="type">at</span> level 25).

<span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to the common ( _ o&gt; a ) ,   more precisely ( (id _) o&gt; a )   **)</span>
<span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- F[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).
<span class="doc">(** memo: may attempt  "F[1 b ~&gt; a ]1" ,  shall be similar to the common ( (b _i) o&gt; a ) 
therefore "F[1 _1 ~&gt; _2 ]1 _3 shall be ( (_1 _3) o&gt; _2 ) **)</span>

<span class="doc">(** related to correspondence with the common representation **)</span>
<span class="keyword">Variable</span> <span class="variable-name">polyF_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">A</span> : obF),
                        <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                          F[1 f &lt;o v ~&gt; X ]0
                           ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 .

<span class="doc">(** related to associativity, polyF_morphism says that, put the parameter f and the modifier argument g, then get
xxERASE        (outer modification)    ( g &lt;o f ) o&gt; _  =  f o&gt; ( g o&gt; _ )    (inner modification)
           (outer modification)    ( (f ) o&gt; g ) o&gt; _  =  f o&gt; ( g o&gt; _ )    (inner modification)
which is, holding only f as parameter and running all the arguments,
xxERASE        (outer modification)    ( _1 &lt;o f ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
           (outer modification)    ( (f ) o&gt; _1 ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
 **)</span>
<span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
<span class="keyword">Variable</span> <span class="variable-name">polyF_morphism</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obF) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obF) (<span class="variable-name">g</span> : V(0 W |- F[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                             F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                              ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[1 g ~&gt; X ]0 ).

<span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                       <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                         f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obF, polyF f' X ~~ polyF f X.

<span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">A</span> : obF),
                         <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
  := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF B (F[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) X).
<span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV B) (<span class="type">at</span> level 25).


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the logical category V is polymorph</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">polyV_relV</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">V</span> : obV),
                   V(0 U |- [0 W ~&gt; V ]0 )0 -&gt;
                   <span class="type">forall</span> <span class="variable-name">X</span> : obV, V(0 [0 V ~&gt; X ]0  |- [0 U ~&gt; [0 W ~&gt; X ]0 ]0 )0.

<span class="keyword">Notation</span> <span class="string">"V[0 U ~&gt; V ]0"</span> := ([0 U ~&gt; V ]0) (<span class="type">at</span> level 25, only parsing).
<span class="keyword">Notation</span> <span class="string">"V[1 v ~&gt; X ]0"</span> := (<span class="constant">@</span>polyV_relV _ _ _ v X) (<span class="type">at</span> level 25).
<span class="keyword">Notation</span> <span class="string">"V[0 X ~&gt; w ]1"</span> := (<span class="constant">@</span>polyV_relV _ _ _ 1 X &lt;o w) (<span class="type">at</span> level 25).
<span class="keyword">Notation</span> <span class="string">"V[0 W ~&gt; - ]1"</span> := (<span class="type">fun</span> <span class="variable-name">V X</span> =&gt; <span class="constant">@</span>polyV_relV _ _ _ (<span class="constant">@</span>IdenV ([0 W ~&gt; V ]0)) X) (<span class="type">at</span> level 25). 

<span class="keyword">Hypothesis</span> <span class="variable-name">polyV_relV_polyV_relT</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">V</span> : obV),
                         <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 W ~&gt; V ]0 )0), <span class="type">forall</span> <span class="variable-name">X</span> : obV,
                           [1 Des v ~&gt; X]0
                                         ~~ DesIn( V[1 v ~&gt; X ]0 ) .

<span class="keyword">Hypothesis</span> <span class="variable-name">polyV_relV_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obV) (<span class="variable-name">V</span> : obV),
                          <span class="type">forall</span> (<span class="variable-name">V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obV),
                            V[1 f &lt;o v ~&gt; X ]0
                             ~~ [1 v ~&gt; V[0 B ~&gt; X ]0 ]0 &lt;o V[1 f ~&gt; X ]0 .


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF are contained in natural transformations</span></span><span class="doc"> **)</span>

<span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">A</span> : obF) (<span class="variable-name">V</span> : obV),
                       <span class="type">forall</span> (<span class="variable-name">W V'</span> : obV) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obF),
                         F[1 f &lt;o (Des v) ~&gt; X ]0
                          ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> polyF_arrow ].
  <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_relV_polyV_relT.
<span class="keyword">Qed</span>.

<span class="doc">(** polyF_natural (sym) says that, put the parameter f, then get
xxERASE        (outer modification)    _1 &lt;o ( f o&gt; _2 )  =  f o&gt; ( _1 &lt;o _2 )    (inner modification)
           (outer modification)    ( f o&gt; _2 ) o&gt; _1  =  f o&gt; ( _2 o&gt; _1 )    (inner modification)
and this is codeductible with polyF_morphism above which says that, put the parameter f, then get
xxERASE       (outer modification)    ( _1 &lt;o f ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
          (outer modification)    ( (f ) o&gt; _1 ) o&gt; _2  =  f o&gt; ( _1 o&gt; _2 )    (inner modification)
xxERASE now memo that in the left hand sides there is mirroring of whole and permutation of inputs, and that in the right hand sides there is mirroring of block and permutation of inputs,
xxnow memo that in the left hand sides there is permutation of inputs, and that in the right hand sides there is mirroring of block and permutation of inputs,
now memo that in the left hand sides there is permutation of inputs, and that in the right hand sides there is permutation of inputs,  **)</span>
<span class="doc">(** written here :   (inner modification) ~~ (outer modification) **)</span>
<span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                      <span class="type">forall</span> (<span class="variable-name">C X</span> : obF),
                        ( [0 F[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                          &lt;o F[0 A ~&gt; - ]1 C X )
                          ~~ ( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .
<span class="keyword">Proof</span>.
  <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
  <span class="proof-tactics-name">apply</span> CongConsIn.

  <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (F[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0
                   ~~ DesIn( [0 F[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o F[0 A ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) &lt;o f  ~&gt; C ]0 ) ~&gt; X ]0
                   ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (F[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0 )
    <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
         <span class="proof-tactics-name">apply</span> polyF_arrow ).

  <span class="comment-delimiter">(*</span><span class="comment"> convert right hand side : outer polyV_relV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X )
                       ~~ DesIn( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
         <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
         <span class="proof-tactics-name">apply</span> polyV_relV_arrow ).

  <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; C ]0)) &lt;o Des( (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ) ~&gt; X ]0 )
                    ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X ) )
    <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

  <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

  <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
  
  <span class="proof-tactics-name">apply</span> ReflV.
<span class="keyword">Qed</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF contains all natural transformations</span></span><span class="doc"> **)</span>

<span class="keyword">Variable</span> <span class="variable-name">IdenObV</span> : obV.
<span class="keyword">Notation</span>  <span class="string">"'I'"</span> := (IdenObV) (<span class="type">at</span> level 0).

<span class="keyword">Parameter</span> <span class="variable-name">unitF</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obF}, V(0 I |- F[0 A ~&gt; A ]0 )0.
<span class="keyword">Notation</span> <span class="string">"'u'"</span> := (<span class="constant">@</span>unitF _) (<span class="type">at</span> level 0).

<span class="keyword">Variable</span> <span class="variable-name">DesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 U |- [0 I ~&gt; W ]0 )0 -&gt; V(0 U  |- W )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">CongDesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U |- [0 I ~&gt; W ]0 )0),
                              v' ~~ v -&gt; DesIdenObR v' ~~ DesIdenObR v.
<span class="keyword">Hypothesis</span> <span class="variable-name">DesIdenObR_output</span> : <span class="type">forall</span> (<span class="variable-name">U</span> : obV) (<span class="variable-name">W W'</span> : obV) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                 DesIdenObR( [0 I ~&gt; w ]1 &lt;o v ) ~~ w &lt;o DesIdenObR( v ).

<span class="keyword">Variable</span> <span class="variable-name">DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), V(0 I |- [0 V ~&gt; W ]0 )0 -&gt; V(0 V |- W )0.
<span class="keyword">Variable</span> <span class="variable-name">ConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), V(0 V |- W )0 -&gt; V(0 I |- [0 V ~&gt; W ]0 )0.
<span class="keyword">Hypothesis</span> <span class="variable-name">ConsIdenObL_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0,
                                      v ~~ ConsIdenObL( DesIdenObL v).
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 V |- W )0),
                               v' ~~ v -&gt; ConsIdenObL v' ~~ ConsIdenObL v.

<span class="keyword">Hypothesis</span> <span class="variable-name">consV10_functorial</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> :  V(0 V1' |- V1 )0), <span class="type">forall</span> V1'' (<span class="variable-name">v'</span> : V(0 V1'' |- V1' )0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                                  [1 v &lt;o v' ~&gt; V2 ]0 ~~  [1 v' ~&gt; V2 ]0 &lt;o  [1 v ~&gt; V2 ]0 .
<span class="keyword">Hypothesis</span> <span class="variable-name">consV11_bifunctorial</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v</span> : V(0 V1' |- V1 )0), <span class="type">forall</span> W1 W1' (<span class="variable-name">w</span> : V(0 W1 |- W1' )0),
                                    [0 V1' ~&gt; w ]1 &lt;o  [1 v ~&gt; W1 ]0 ~~ [1 v ~&gt; W1' ]0 &lt;o [0 V1 ~&gt; w ]1 .
<span class="keyword">Hypothesis</span> <span class="variable-name">CongConsV10</span> : <span class="type">forall</span> V1' V1 (<span class="variable-name">v v'</span> : V(0 V1' |- V1)0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                           v' ~~ v -&gt; [1 v' ~&gt; V2 ]0 ~~ [1 v ~&gt; V2 ]0 .

<span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">polyF_unitF</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obF), <span class="type">forall</span> <span class="variable-name">X</span> : obF, (<span class="constant">@</span>IdenV (F[0 A ~&gt; X ]0)) ~~ DesIdenObR( F[1 (<span class="constant">@</span>unitF A) ~&gt; X ]0 ) .

<span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyF is injective **)</span>
<span class="keyword">Hypothesis</span> <span class="variable-name">polyF_inputUnitF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                f  ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitF A) ).

<span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ) :=
  <span class="type">forall</span> (<span class="variable-name">C X</span> : obF),
    ( [0 F[0 A ~&gt; C ]0 ~&gt; &#966; X ]1
      &lt;o F[0 A ~&gt; - ]1 C X )
      ~~ ( [1 &#966; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
           &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

<span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                                 natural &#966; -&gt;
                                 <span class="type">forall</span> (<span class="variable-name">X</span> : obF),
                                   DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitF A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                             ~~ ( &#966; X ) .
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyF_arrow ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyF, SymV, Cat1LeftV ].  
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyF_unitF ].
  <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                        natural &#966; -&gt; natural &#966;' -&gt;
                        &#966;' A &lt;o (<span class="constant">@</span>unitF A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitF A) -&gt;
                        <span class="type">forall</span> <span class="variable-name">X</span> : obF, &#966;' X ~~ &#966; X.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                           <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
  <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
  <span class="coq-solve-tactics">assumption</span>.
<span class="keyword">Qed</span>.

<span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obF) (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obF) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obF, V(0 F[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0 ),
                 natural &#966; -&gt;
                 <span class="type">forall</span> <span class="variable-name">X</span> : obF, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitF A) ) ~&gt; X ]0.
<span class="keyword">Proof</span>.
  <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitF A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitF A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitF A) ).
  <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
  <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
  
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
  <span class="proof-tactics-name">apply</span> CongConsIdenObL.
  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitF |  <span class="proof-tactics-name">apply</span> ReflV ].
<span class="keyword">Qed</span>.


<span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">polymorph functor</span></span><span class="doc"> **)</span>

<span class="keyword">Module</span> <span class="function-name">Functor</span>.
  
  <span class="doc">(** short : instead of describing F : catA --&gt; catB  then (contrast yoneda structures) describe catV[ V , catB[ B , F - ] ] : catA --&gt; catV **)</span>

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put some polymorph category A , note that unitA is lacked later</span></span><span class="doc">**)</span>

  <span class="keyword">Variable</span> <span class="variable-name">obA</span> : <span class="type">Type</span>.
  <span class="keyword">Variable</span> <span class="variable-name">polyA00</span> : obA -&gt; obA -&gt; obV.
  <span class="keyword">Notation</span> <span class="string">"A[0 A1 ~&gt; A2 ]0"</span> := (polyA00 A1 A2) (<span class="type">at</span> level 25).

  <span class="keyword">Parameter</span> <span class="variable-name">polyA</span> : <span class="type">forall</span> (<span class="variable-name">A2</span> : obA), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A1</span> : obA),
                      V(0 V |- A[0 A2 ~&gt; A1 ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A1 ~&gt; X ]0  |- [0 V ~&gt; A[0 A2 ~&gt; X ]0 ]0 )0.

  <span class="doc">(** therefore "A[1 f ~&gt; X ]0" is similar to ( f o&gt; _ ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"A[1 f ~&gt; X ]0"</span> := (<span class="constant">@</span>polyA _ _ _ f X) (<span class="type">at</span> level 25).

  <span class="doc">(** therefore "A[0 X ~&gt; g ]1" is similar to the common ( _ &lt;o g ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"A[0 X ~&gt; g ]1"</span> := (<span class="constant">@</span>polyA _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">g</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

  <span class="keyword">Definition</span> <span class="function-name">polyA_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 A[0 B ~&gt; A ]0 ~&gt; A[0 B ~&gt; X ]0 ]0 )0
    := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyA B (A[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (A[0 B ~&gt; A ]0)) X).
  <span class="keyword">Notation</span> <span class="string">"A[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyA_IdenV B) (<span class="type">at</span> level 25).

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put some polymorph category B , note that unitB is not lacked</span></span><span class="doc">  **)</span>

  <span class="keyword">Variable</span> <span class="variable-name">obB</span> : <span class="type">Type</span>.
  <span class="keyword">Variable</span> <span class="variable-name">polyB00</span> : obB -&gt; obB -&gt; obV.
  <span class="keyword">Notation</span> <span class="string">"B[0 B1 ~&gt; B2 ]0"</span> := (polyB00 B1 B2) (<span class="type">at</span> level 25).

  <span class="keyword">Parameter</span> <span class="variable-name">polyB</span> : <span class="type">forall</span> (<span class="variable-name">B2</span> : obB), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B1</span> : obB),
                      V(0 V |- B[0 B2 ~&gt; B1 ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">Y</span> : obB, V(0 B[0 B1 ~&gt; Y ]0  |- [0 V ~&gt; B[0 B2 ~&gt; Y ]0 ]0 )0.

  <span class="doc">(** therefore "B[1 m ~&gt; Y ]0" is similar to ( m o&gt; _ ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"B[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyB _ _ _ m Y) (<span class="type">at</span> level 25).

  <span class="doc">(** therefore "B[0 Y ~&gt; n ]1" is similar to the common ( _ &lt;o n ) **)</span>
  <span class="keyword">Notation</span> <span class="string">"B[0 Y ~&gt; n ]1"</span> := (<span class="constant">@</span>polyB _ _ _ (<span class="constant">@</span>IdenV _) Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- B[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25).

  <span class="keyword">Definition</span> <span class="function-name">polyB_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB), <span class="type">forall</span> (<span class="variable-name">A</span> : obB),
                           <span class="type">forall</span> <span class="variable-name">X</span> : obB, V(0 B[0 A ~&gt; X ]0  |- [0 B[0 B ~&gt; A ]0 ~&gt; B[0 B ~&gt; X ]0 ]0 )0
    := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyB B (B[0 B ~&gt; A ]0) A (<span class="constant">@</span>IdenV (B[0 B ~&gt; A ]0)) X).
  <span class="keyword">Notation</span> <span class="string">"B[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyB_IdenV B) (<span class="type">at</span> level 25).

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get some polymorph funtor F</span></span><span class="doc"> **)</span>

  <span class="keyword">Variable</span> <span class="variable-name">polyF0</span> : obA -&gt; obB.
  <span class="keyword">Notation</span> <span class="string">"F|0 A"</span> := (polyF0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

  <span class="comment-delimiter">(*</span><span class="comment"> want B[ B , F A1] -&gt; forall A2, A[ A1 , A2] -&gt; B[ B , F A2 ] </span><span class="comment-delimiter">*)</span>
  <span class="comment-delimiter">(*</span><span class="comment">       (F|1 _2 ) &lt;o _1   ...   _1 o&gt; (F|1 _2)      </span><span class="comment-delimiter">*)</span>

  <span class="keyword">Parameter</span> <span class="variable-name">polyF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                      V(0 V |- B[0 B ~&gt; F|0 A ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; B[0 B ~&gt; F|0 X ]0 ]0 )0.

  <span class="doc">(** :^) **)</span>
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (B[0 B ~&gt; F|0 A ]0) (<span class="type">at</span> level 25).
  
  <span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to   ( b o&gt; ( F|1 _ ) )   , alternatively   ( b o&gt;F _ )   **)</span>
  <span class="keyword">Notation</span> <span class="string">"F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ _ _ b X) (<span class="type">at</span> level 25).

  <span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to   ( B[0 B ~&gt; ( F|1 a ) ]1 ) which is ( _ o&gt; ( F|1 a ) )   , alternatively  ( _ o&gt;F a )   **)</span>
  <span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

  <span class="doc">(** NOT LACKED, may attempt
  (* for now, unitB for this notation only *)
  Parameter unitB : forall {B : obB}, V(0 I |- B[0 B ~&gt; B ]0 )0.
  Notation "'uB'" := (</span><span class="constant"><span class="doc">@</span></span><span class="doc">unitB _) (at level 0).
  (* approximative notation, may require input (g : V(0 I |- A[0 A ~&gt; X ]0 )0) but not really more progress,
      and may transform output to cancel ( [0 I ~&gt;  _ ]0 ) and now more progress *)
  Notation "F|1 a" := (DesIdenObR ([1 uB ~&gt; _ ]0 &lt;o F[0 _ ~&gt; a ]1)) (at level 5, right associativity) .
  Check (fun (W : obV) (A X : obA) (a : V(0 W |- A[0 A ~&gt; X ]0 )0) =&gt; F|1 a).
   **)</span>
  
  <span class="doc">(** related to correspondence with the common representation **)</span>
  <span class="keyword">Variable</span> <span class="variable-name">polyF_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                           F[1 f &lt;o v ~&gt; X ]0
                            ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 .

  <span class="doc">(** related to associativity, polyF_morphism says that, put the parameter f and the modifier argument g, then get
           (outer modification)    ( (f ) o&gt;F g ) o&gt;F _  =  f o&gt;F ( g o&gt; _ )    (inner modification)
which is, holding only f as parameter and running all the arguments,
           (outer modification)    ( (f ) o&gt;F _1 ) o&gt;F _2  =  f o&gt;F ( _1 o&gt; _2 )    (inner modification)
   **)</span>
  <span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
  <span class="keyword">Variable</span> <span class="variable-name">polyF_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB),
                            <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                            <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                              F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                               ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 ).

  <span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
    := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF (F[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) X).
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV B) (<span class="type">at</span> level 25).

  <span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, polyF f' X ~~ polyF f X.

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF are contained in natural transformations</span></span><span class="doc"> **)</span>

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                        <span class="type">forall</span> (<span class="variable-name">V W V'</span> : obV) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                          F[1 f &lt;o (Des v) ~&gt; X ]0
                           ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> polyF_arrow ].
    <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_relV_polyV_relT.
  <span class="keyword">Qed</span>.

  <span class="doc">(** polyF_natural (sym) says that, put the parameter f, then get
           (outer modification)    ( f o&gt;F _2 ) o&gt;F _1  =  f o&gt;F ( _2 o&gt; _1 )    (inner modification)
and this is codeductible with polyF_morphism above which says that, put the parameter f, then get
           (outer modification)    ( (f ) o&gt;F _1 ) o&gt;F _2  =  f o&gt;F ( _1 o&gt; _2 )    (inner modification)
now memo that in the left hand sides there is permutation of inputs, and that in the right hand sides there is permutation of inputs,  **)</span>
  <span class="doc">(** written here :   (inner modification) ~~ (outer modification) **)</span>
  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                        <span class="type">forall</span> (<span class="variable-name">C X</span> : obA),
                          ( [0 A[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                            &lt;o A[0 A ~&gt; - ]1 C X )
                            ~~ ( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .
  <span class="keyword">Proof</span>.
    <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
    <span class="proof-tactics-name">apply</span> CongConsIn.

    <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (A[0 A ~&gt; C]0)) ]1 ) ~&gt; X ]0
                     ~~ DesIn( [0 A[0 A ~&gt; C ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[0 A ~&gt; - ]1 C X ) )
      <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; A ]0)) &lt;o f ~&gt; C ]0 ) ~&gt; X ]0
                     ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; C ]0 ]0 &lt;o F[0 C ~&gt; (<span class="constant">@</span>IdenV (A[0 A ~&gt; C ]0)) ]1 ) ~&gt; X ]0 )
      <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
           <span class="proof-tactics-name">apply</span> polyF_arrow ).

    <span class="comment-delimiter">(*</span><span class="comment"> convert right hand side : outer polyV_relV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X )
                         ~~ DesIn( [1 F[1 f ~&gt; C ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) )
      <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
           <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
           <span class="proof-tactics-name">apply</span> polyV_relV_arrow ).

    <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV (F[0 B ~&gt; C ]0)) &lt;o Des( (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ) ~&gt; X ]0 )
                      ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV (V[0 V ~&gt; (F[0 B ~&gt; C ]0) ]0)) &lt;o (F[1 f ~&gt; C ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 C X ) )
      <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

    <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

    <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
    
    <span class="proof-tactics-name">apply</span> ReflV.
  <span class="keyword">Qed</span>.

  <span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#946;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
    <span class="type">forall</span> (<span class="variable-name">C X</span> : obA),
      ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
        &lt;o A[0 A ~&gt; - ]1 C X )
        ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
             &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

  <span class="keyword">Lemma</span> <span class="function-name">polyF_natural_folded</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                                 natural (<span class="type">fun</span> <span class="variable-name">X</span> : obA =&gt; F[1 b ~&gt; X ]0).
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">unfold</span> natural.
    <span class="coq-solve-tactics">exact</span> polyF_natural.
  <span class="keyword">Qed</span>.

  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get that the image of polyF contains all natural transformations</span></span><span class="doc"> **)</span>

  <span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, polyA f' X ~~ polyA f X.

  <span class="keyword">Variable</span> <span class="variable-name">polyA_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                          <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                            A[1 f &lt;o v ~&gt; X ]0
                             ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0 .

  <span class="keyword">Parameter</span> <span class="variable-name">unitA</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obA}, V(0 I |- A[0 A ~&gt; A ]0 )0.
  <span class="keyword">Notation</span> <span class="string">"'uA'"</span> := (<span class="constant">@</span>unitA _) (<span class="type">at</span> level 0).

  <span class="keyword">Hypothesis</span> <span class="variable-name">polyA_unitA</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA), <span class="type">forall</span> <span class="variable-name">X</span> : obA, (<span class="constant">@</span>IdenV (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>unitA A) ~&gt; X ]0 ) .

  <span class="keyword">Hypothesis</span> <span class="variable-name">polyA_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                                  f  ~~ DesIdenObL( (A[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                                   natural &#966; -&gt;
                                   <span class="type">forall</span> (<span class="variable-name">X</span> : obA),
                                     DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitA A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                               ~~ ( &#966; X ) .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_arrow ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyA, SymV, Cat1LeftV ].  
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_unitA ].
    <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
  <span class="keyword">Qed</span>.

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                          natural &#966; -&gt; natural &#966;' -&gt;
                          &#966;' A &lt;o (<span class="constant">@</span>unitA A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitA A) -&gt;
                          <span class="type">forall</span> <span class="variable-name">X</span> : obA, &#966;' X ~~ &#966; X.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                             <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
    <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
    <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Qed</span>.

  <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;F 1 ) ~~ (f _i)  , 
       therefore polyF is injective **)</span>
  <span class="keyword">Hypothesis</span> <span class="variable-name">polyF_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                  f ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).

  <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                   natural &#966; -&gt;
                   <span class="type">forall</span> <span class="variable-name">X</span> : obA, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA A) ) ~&gt; X ]0 .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitA A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitA A) ).
    <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
    <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
    
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
    <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
    <span class="proof-tactics-name">apply</span> CongConsIdenObL.
    <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitA |  <span class="proof-tactics-name">apply</span> ReflV ].
  <span class="keyword">Qed</span>.


  <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">polymorph polytransformation</span></span><span class="doc"> **)</span>

  <span class="keyword">Module</span> <span class="function-name">Transformation</span>.

    <span class="doc">(** short : instead of describing &#966; A : G A -&gt; H A  then a-la-dosen (contrast weighted colimiting Kan extension) describe &#966; _f : catV( V , catB[ B , G A ] ) -&gt;  catV( V , catB[ B , H A ] ) **)</span>

    <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">put some polymorph funtor G</span></span><span class="doc"> **)</span>

    <span class="keyword">Variable</span> <span class="variable-name">polyG0</span> : obA -&gt; obB.
    <span class="keyword">Notation</span> <span class="string">"G|0 A"</span> := (polyG0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

    <span class="keyword">Parameter</span> <span class="variable-name">polyG</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                        V(0 V |- B[0 B ~&gt; G|0 A ]0 )0 -&gt;
                        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; B[0 B ~&gt; G|0 X ]0 ]0 )0.

    <span class="keyword">Notation</span> <span class="string">"G[0 B ~&gt; A ]0"</span> := (B[0 B ~&gt; G|0 A ]0) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"G[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyG _ _ _ b X) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"G[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyG _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

    <span class="keyword">Variable</span> <span class="variable-name">polyG_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- G[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                             G[1 f &lt;o v ~&gt; X ]0
                              ~~ [1 v ~&gt; G[0 B ~&gt; X ]0 ]0 &lt;o G[1 f ~&gt; X ]0 .

    <span class="keyword">Variable</span> <span class="variable-name">polyG_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">V</span> : obV),
                              <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-G[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                G[1 Des( [1 f ~&gt; G[0 B ~&gt; A' ]0 ]0 &lt;o G[0 A' ~&gt; g ]1 ) ~&gt; X]0
                                 ~~  DesIn( [0 W ~&gt; G[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 ).

    <span class="keyword">Definition</span> <span class="function-name">polyG_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                             <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 G[0 B ~&gt; A ]0 ~&gt; G[0 B ~&gt; X ]0 ]0 )0
      := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyG (G[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (G[0 B ~&gt; A ]0)) X).
    <span class="keyword">Notation</span> <span class="string">"G[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyG_IdenV B) (<span class="type">at</span> level 25).

    <span class="keyword">Hypothesis</span> <span class="variable-name">CongPolyG</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- G[0 B ~&gt; A ]0 )0),
                             f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, polyG f' X ~~ polyG f X.
    
    <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get some polymorph polytransformation &#946;</span></span><span class="doc"> **)</span>
    
    <span class="keyword">Parameter</span> <span class="variable-name">poly&#946;</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                        V(0 V |- F[0 B ~&gt; A ]0 )0 -&gt;
                        V(0 V |- G[0 B ~&gt; A ]0 )0 .

    <span class="doc">(** :^) **)</span>
    <span class="keyword">Notation</span> <span class="string">"&#946;|1 f"</span> := (<span class="constant">@</span>poly&#946; _ _ _ f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity).
    <span class="keyword">Notation</span> <span class="string">"&#946;|0 A"</span> := (<span class="constant">@</span>poly&#946; _ _ A (<span class="constant">@</span>IdenV _)) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

    <span class="keyword">Variable</span> <span class="variable-name">poly&#946;_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                           <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                             &#946;|1 (f &lt;o v)
                                 ~~ &#946;|1 f &lt;o v .

    <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
    <span class="keyword">Variable</span> <span class="variable-name">poly&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB),
                              <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                                &#946;|1 (Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; a ]1 ))
                                    ~~ (Des( [1 &#946;|1 f ~&gt; G[0 B ~&gt; A' ]0 ]0 &lt;o G[0 A' ~&gt; a ]1 )) .

    <span class="keyword">Variable</span> <span class="variable-name">poly&#946;_morphism_codomain</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">B</span> : obB) (<span class="variable-name">W</span> : obV) (<span class="variable-name">B'</span> : obB) (<span class="variable-name">b</span> : V(0 W |- B[0 B' ~&gt; B]0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0),
                                         &#946;|1 (Des( B[1 b ~&gt; F|0 A ]0 &lt;o f ))
                                             ~~  Des( B[1 b ~&gt; G|0 A ]0 &lt;o &#946;|1 f ).

    <span class="doc">(** next :
     1. define naturality of any transformation of polymorph functors into catV
     2. show codeductibility of naturality for this transformation in catV with polymorphism (polymorph in V , B is easy) for the corresponding polytransformation
     3. define composition of polymorph functors, view [0 V0 ~&gt; F[0 B0 ~&gt; - ]0 ]0 as coming from composite polymorph functors
     4. confirm old naturality signify new naturality of the transformation F[1 (f0 : V(0 V0 |- F[0 B0 ~&gt; A0 ]0 )0) ~&gt; - ]0 between these polymorph functors on top of A[0 A0 ~&gt; - ]0 (which is polyA) and on top of [0 V0 ~&gt; F[0 B0 ~&gt; - ]0 ]0 (which is composite of polyV_relV with polyF)
     5. rewrite the yoneda lemma as saying that the image is precisely any transformation whose corresponding polytransformation is polymorph
     **)</span>

    <span class="doc">(** alternatively, more immediately and particularly, show that poly_of_this_transf below satisfies poly&#946;_arrow (easy) and poly&#946;_morphism_codomain (easy) and poly&#946;_morphism (from old naturality) **)</span>
    <span class="keyword">Definition</span> <span class="function-name">poly_of_this_transf</span> : <span class="type">forall</span> (<span class="variable-name">A0</span> : obA) (<span class="variable-name">V0</span> : obV) (<span class="variable-name">B0</span> : obB) (<span class="variable-name">f0</span> : V(0 V0 |- F[0 B0 ~&gt; A0 ]0 )0),
                                     <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">U</span> : obV) (<span class="variable-name">A</span> : obA),
                                       V(0 V |- V[0 U ~&gt; A[0 A0 ~&gt; A ]0 ]0 )0 -&gt;
                                       V(0 V |- V[0 U ~&gt; [0 V0 ~&gt; F[0 B0 ~&gt; A ]0 ]0 ]0 )0
      := <span class="type">fun</span> (<span class="variable-name">A0</span> : obA) (<span class="variable-name">V0</span> : obV) (<span class="variable-name">B0</span> : obB) (<span class="variable-name">f0</span> : V(0 V0 |- F[0 B0 ~&gt; A0 ]0 )0)
         =&gt; <span class="type">fun</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">U</span> : obV) (<span class="variable-name">A</span> : obA)
           =&gt; <span class="type">fun</span> (<span class="variable-name">f</span> : V(0 V |- V[0 U ~&gt; A[0 A0 ~&gt; A ]0 ]0 )0)
             =&gt; [0 U ~&gt; F[1 f0 ~&gt; A ]0 ]1 &lt;o f .


    <span class="keyword">Section</span> <span class="function-name">FunctorComposition</span>.

      <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">composition of two polyfunctors,</span></span><span class="doc"> 
                  now put some polymorph category C , note that unitB is lacked  **)</span>

      <span class="keyword">Variable</span> <span class="variable-name">obC</span> : <span class="type">Type</span>.
      <span class="keyword">Variable</span> <span class="variable-name">polyC00</span> : obC -&gt; obC -&gt; obV.
      <span class="keyword">Notation</span> <span class="string">"C[0 C1 ~&gt; C2 ]0"</span> := (polyC00 C1 C2) (<span class="type">at</span> level 25).

      <span class="keyword">Parameter</span> <span class="variable-name">polyC</span> : <span class="type">forall</span> (<span class="variable-name">C2</span> : obC), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">C1</span> : obC),
                          V(0 V |- C[0 C2 ~&gt; C1 ]0 )0 -&gt;
                          <span class="type">forall</span> <span class="variable-name">Y</span> : obC, V(0 C[0 C1 ~&gt; Y ]0  |- [0 V ~&gt; C[0 C2 ~&gt; Y ]0 ]0 )0.

      <span class="doc">(** therefore "C[1 m ~&gt; Y ]0" is similar to ( m o&gt; _ ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"C[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyC _ _ _ m Y) (<span class="type">at</span> level 25).

      <span class="doc">(** therefore "C[0 Y ~&gt; n ]1" is similar to the common ( _ &lt;o n ) **)</span>
      <span class="keyword">Notation</span> <span class="string">"C[0 Y ~&gt; n ]1"</span> := (<span class="constant">@</span>polyC _ _ _ (<span class="constant">@</span>IdenV _) Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- C[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">polyC_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">D</span> : obC), <span class="type">forall</span> (<span class="variable-name">C</span> : obC),
                               <span class="type">forall</span> <span class="variable-name">X</span> : obC, V(0 C[0 C ~&gt; X ]0  |- [0 C[0 D ~&gt; C ]0 ~&gt; C[0 D ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">D C X</span> =&gt; <span class="constant">@</span>polyC D (C[0 D ~&gt; C ]0) C (<span class="constant">@</span>IdenV (C[0 D ~&gt; C ]0)) X).
      <span class="keyword">Notation</span> <span class="string">"C[0 C ~&gt; - ]1"</span> := (<span class="constant">@</span>polyC_IdenV C) (<span class="type">at</span> level 25).

      <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">get some polymorph funtor F'</span></span><span class="doc"> **)</span>

      <span class="keyword">Variable</span> <span class="variable-name">polyF'0</span> : obB -&gt; obC.
      <span class="keyword">Notation</span> <span class="string">"F'|0 B"</span> := (polyF'0 B) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).
      <span class="keyword">Notation</span> <span class="string">"F'[0 C ~&gt; B ]0"</span> := (C[0 C ~&gt; F'|0 B ]0) (<span class="type">at</span> level 25).
      <span class="keyword">Parameter</span> <span class="variable-name">polyF'</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">C</span> : obC) (<span class="variable-name">B</span> : obB),
                           V(0 V |- F'[0 C ~&gt; B ]0 )0 -&gt;
                           <span class="type">forall</span> <span class="variable-name">X</span> : obB, V(0 B[0 B ~&gt; X ]0  |- [0 V ~&gt; F'[0 C ~&gt; X ]0 ]0 )0.
      <span class="keyword">Notation</span> <span class="string">"F'[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF' _ _ _ b X) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"F'[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>polyF' _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- B[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">polyF'_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">C</span> : obC) (<span class="variable-name">B</span> : obB),
                                <span class="type">forall</span> <span class="variable-name">X</span> : obB, V(0 B[0 B ~&gt; X ]0  |- [0 F'[0 C ~&gt; B ]0 ~&gt; F'[0 C ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">C B X</span> =&gt; <span class="constant">@</span>polyF' (F'[0 C ~&gt; B ]0) C B (<span class="constant">@</span>IdenV (F'[0 C ~&gt; B ]0)) X).
      <span class="keyword">Notation</span> <span class="string">"F'[0 C ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF'_IdenV C) (<span class="type">at</span> level 25).
      
      <span class="doc">(**             c o&gt;F'F a  =  c o&gt;F' (1 o&gt;F a)   ...   c o&gt;F' (b o&gt;F a) = (c o&gt;F' b) o&gt;F'F a ,       b : _ -&gt; F _              
                         d o&gt;F'' (c o&gt;F' (b o&gt;F a))              catA -&gt; catB -&gt; catC -&gt; catD         **)</span>
      <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F</span> :
        <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
        <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 V |- B[0 B ~&gt; F|0 A ]0 )0),
        <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">C</span> : obC),
        <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- C[0 C ~&gt; F'|0 B]0 )0),
        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; [0 W ~&gt; C[0 C ~&gt; F'|0 F|0 X ]0 ]0 ]0 )0.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>.
        <span class="comment-delimiter">(*</span><span class="comment">eapply ComV. ... not anymore that unitary is definationally same as identitary </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">eapply</span> polyV_relT_identitary <span class="comment-delimiter">(*</span><span class="comment"> _ &lt;o _ </span><span class="comment-delimiter">*)</span>. <span class="proof-tactics-name">apply</span> consV01. <span class="proof-tactics-name">apply</span> (polyF' c).
        <span class="proof-tactics-name">apply</span> (polyF b).
<span class="comment-delimiter">(*</span><span class="comment">        apply consV01.
        apply (polyF' c). </span><span class="comment-delimiter">*)</span>
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
      <span class="comment-delimiter">(*</span><span class="comment">
(fun (V : obV) (B : obB) (A : obA) (b : V(0 V |- F[0 B ~&gt; A ]0 )0) 
   (W : obV) (C : obC) (c : V(0 W |- F'[0 C ~&gt; B ]0 )0) 
   (X : obA) =&gt; [0V ~&gt; F'[1 c ~&gt; F|0 X ]0 ]1 &lt;o F[1 b ~&gt; X ]0) </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

      <span class="doc">(************
       b : V( V |- B[ B ~&gt; FA] )  -&gt;
      a : B[ B ~&gt; A[ A ~&gt; X ] ] -&gt; [V ~&gt; B[ B ~&gt; F X ]]

      _ o&gt;B ((B[ b ~&gt; FX ] &lt;o F|1 A X) a)

      _ o&gt;B  (b o&gt;F a)

     (b' _j) o&gt;B  ((b _i) o&gt;F a)

                  _j |&gt; ( (b _i) o&gt; F (a _j) )  ....  (b _i) o&gt;F a

      catA -&gt; F: catB -&gt; F': catC , and catA enriched in catB, and catB enriched in catC enriched in catV
      b : V(V |- C[ C |- B[ B ~&gt; F A] ] )  -&gt;
      a : C[ C ~&gt; B[ B ~&gt; A[ A ~&gt; X ] ] ] -&gt; [V ~&gt; C[ C ~&gt; B[ B ~&gt; F X ]]]                                                                 
                 _j |&gt; ( (b _i _i') o&gt; F (a _i' _j) )  ....  (b _i _i') o&gt;F a

      c : V( W |- C[ C' ~&gt; F' B] )  -&gt;
      b' : C[ C' ~&gt; B[ B ~&gt; Y ] ] -&gt; [W ~&gt; C[ C' ~&gt; F' Y ]]

      given only map on objects F|0, F'|0, define any polyMorphism named polyG :
      b : V(V |- C[ C |- B[ B ~&gt; F|0 A] ] )  -&gt;
      c : V( W |- C[ C ~&gt; F'|0 B] )  -&gt;
      a : V( C[ C ~&gt; B[ B ~&gt; A[ A ~&gt; X ] ] ] |- [V ~&gt; [W ~&gt; C[ C ~&gt; F'|0 F|0 X ] ] ] )

       *****)</span>                                              
      
      
      <span class="keyword">Parameter</span> <span class="variable-name">unitB</span> : <span class="type">forall</span> {<span class="variable-name">B</span> : obB}, V(0 I |- B[0 B ~&gt; B ]0 )0.
      <span class="keyword">Notation</span> <span class="string">"'uB'"</span> := (<span class="constant">@</span>unitB _) (<span class="type">at</span> level 0).

      <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F_simple</span> :
        <span class="type">forall</span>  (<span class="variable-name">A</span> : obA),
        <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">C</span> : obC),
        <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- C[0 C ~&gt; F'|0 F|0 A ]0 )0),
        <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 W ~&gt; C[0 C ~&gt; F'|0 F|0 X ]0 ]0 )0.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">apply</span> DesIdenObR.
        <span class="proof-tactics-name">eapply</span> composition_F'_after_F.
        <span class="proof-tactics-name">eapply</span> unitB.
        <span class="coq-solve-tactics">exact</span> c.
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
      <span class="comment-delimiter">(*</span><span class="comment">
(fun (A : obA) (W : obV) (C : obC) (c : V(0 W |- F'[0 C ~&gt; F|0 A ]0 )0)
   (X : obA) =&gt; DesIdenObR (composition_F'_after_F uB c X))
       </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

      <span class="keyword">Notation</span> <span class="string">"F'F|0 B"</span> := (F'|0 F|0 B) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).
      <span class="keyword">Notation</span> <span class="string">"F'F[0 C ~&gt; A ]0"</span> := (C[0 C ~&gt; F'F|0 A ]0) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"F'F[1 c ~&gt; X ]0"</span> := (<span class="constant">@</span>composition_F'_after_F _ _ _ c X) (<span class="type">at</span> level 25).
      <span class="keyword">Notation</span> <span class="string">"F'F[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>composition_F'_after_F _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">C</span> : obC) (<span class="variable-name">A</span> : obA),
                                                <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 F'F[0 C ~&gt; A ]0 ~&gt; F'F[0 C ~&gt; X ]0 ]0 )0
        := (<span class="type">fun</span> <span class="variable-name">C A X</span> =&gt; <span class="constant">@</span>composition_F'_after_F_simple A (F'F[0 C ~&gt; A ]0) C (<span class="constant">@</span>IdenV (F'F[0 C ~&gt; A ]0)) X).
      <span class="keyword">Notation</span> <span class="string">"F'F[0 C ~&gt; - ]1"</span> := (<span class="constant">@</span>composition_F'_after_F_IdenV C) (<span class="type">at</span> level 25).

      <span class="keyword">Definition</span> <span class="function-name">polyF_unitB</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- B[0 F|0 A ~&gt; F|0 X ]0 )0.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">apply</span> DesIdenObR.
        <span class="proof-tactics-name">apply</span> polyF.
        <span class="proof-tactics-name">apply</span> unitB.
        <span class="keyword">Show</span> <span class="keyword">Proof</span>.
        <span class="comment-delimiter">(*</span><span class="comment"> (fun A X : obA =&gt; DesIdenObR (F[1 uB ~&gt; X ]0))  </span><span class="comment-delimiter">*)</span>
      <span class="keyword">Defined</span>.

      <span class="comment-delimiter">(*</span><span class="comment"> F|1 is internal structural arrow , but F[0 B ~&gt; - ]1 are external structural arrows</span><span class="comment-delimiter">*)</span>
      <span class="keyword">Notation</span> <span class="string">"F|1"</span> := (<span class="constant">@</span>polyF_unitB) (<span class="type">at</span> level 0).

      <span class="keyword">Lemma</span> <span class="function-name">composition_F'_after_F_identitary_polyF'_identitary_polyF_unitary</span> :    <span class="type">forall</span> (<span class="variable-name">C</span> : obC) (<span class="variable-name">A X</span> : obA),
                                                                                     (F'[0 C ~&gt; - ]1) F|0 A F|0 X &lt;o F|1 A X ~~ (F'F[0 C ~&gt; - ]1) A X.
      <span class="keyword">Proof</span>.
        <span class="proof-tactics-name">intros</span>.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_IdenV.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_simple.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F.
        <span class="proof-tactics-name">unfold</span> polyF'_IdenV.
        <span class="proof-tactics-name">unfold</span> polyF_unitB.
        <span class="proof-tactics-name">apply</span> SymV, DesIdenObR_output.
      <span class="keyword">Qed</span>.
    <span class="comment-delimiter">(*</span><span class="comment"> apply this to unfold this as identitary (external-structural) of composition of polyfunctors ( polyV_relV o (poly_of_meta F[0 B ~&gt; - ]1) ) .. ( polyV_relV o (poly_of_meta metaFB) )  ...  show before that
1. NEXT1 some metafunctor metaFB into catV on top of F[0 B ~&gt; - ]1  by polyF which becomes  metaFB := meta_of_poly F at B,
2. then get derived polyfunctor from this metafunctor, 
3. then unitary( |1 ) of this derived polyfunctor is  identitary( ||1 ) of the metafunctor metaFB on top of F[0 B ~&gt; - ]1 
4. NEXT2 which is  identitary ( [B ~&gt; - ]1 ) of original polyfunctor F
 
all: ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A' X   
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (meta_of_poly F at B)||1 A' X    
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o FB||1 A' X    
       ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (poly_of_meta metaFB)|1 A' X
       (polyV_relV o (poly_of_meta metaFB))[0 V ~&gt; - ]1 A' X
       (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X

  Definition natural (V : obV) (B : obB) (A : obA) (&#946; : forall X : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
                        forall (C X : obA),
                          ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
                            &lt;o A[0 A ~&gt; - ]1 C X )
                            ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

  Definition natural (V : obV) (B : obB) (A : obA) 
                        (&#946; : forall X : obA, V(0 (meta_of_poly polyA at A)|0 X  |- (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X )0) :=
                        forall (A' X : obA),
                          ( [0 (meta_of_poly polyA at A)|0 A' ~&gt; &#946; X ]1
                            &lt;o (meta_of_poly polyA at A)||1 A' X )
                            ~~ ( [1 &#946; A' ~&gt; (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X ]0
                                 &lt;o (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X ) .
      ... == natural_metatransformation from (meta_of_poly polyA at A) to (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V) by &#946; at A' at X

NEXT3: naturality of any metatransformation of any metafunctors &lt;-&gt; polymorphism of coresp polytransformation of coresp polyfuntors
NEXT4: rewrite natural as above

     </span><span class="comment-delimiter">*)</span>

      
      
    <span class="keyword">End</span>  <span class="function-name">FunctorComposition</span>.
    
    <span class="keyword">Section</span> <span class="function-name">MetaTransformation</span>.

      <span class="keyword">Section</span> <span class="function-name">Meta_of_poly</span>.
        
        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">meta_of_polyF_at_B , metafunctor FB on top of F[0 B ~&gt; - ]1</span></span><span class="doc"> **)</span>

        <span class="keyword">Variable</span> <span class="variable-name">B</span> : obB.

        <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B0</span> : obA -&gt; obV
          := <span class="type">fun</span> <span class="variable-name">A</span> : obA =&gt; F[0 B ~&gt; A ]0 .
        <span class="keyword">Notation</span> <span class="string">"FB|0 A"</span> := (meta_of_polyF_at_B0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)  (<span class="variable-name">A</span> : obA),
                                          V(0 V |- FB|0 A )0 -&gt;
                                          <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; FB|0 X ]0 )0
          := (<span class="type">fun</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0) (<span class="variable-name">X</span> : obA) =&gt;
                <span class="constant">@</span>polyF V B A f X <span class="comment-delimiter">(*</span><span class="comment"> F[1 f ~&gt; X ]0 </span><span class="comment-delimiter">*)</span> ) .
        <span class="comment-delimiter">(*</span><span class="comment"> intros. unfold meta_of_polyF_at_B0. apply polyF. assumption.
        Show Proof. </span><span class="comment-delimiter">*)</span>

        <span class="keyword">Notation</span> <span class="string">"FB[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>meta_of_polyF_at_B _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">meta_of_polyF_at_B_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 FB|0 A ~&gt; FB|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>meta_of_polyF_at_B _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"FB||1"</span> := (<span class="constant">@</span>meta_of_polyF_at_B_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Lemma</span>  <span class="function-name">Cong_meta_of_polyF_at_B</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- FB|0 A )0),
                                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, FB[1I f' ~&gt; X ]0 ~~ FB[1I f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">apply</span> CongPolyF. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0) (<span class="variable-name">X</span> : obA),
                                           FB[1I f &lt;o v ~&gt; X ]0
                                             ~~ [1 v ~&gt; FB|0 X ]0 &lt;o FB[1I f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">apply</span> polyF_arrow.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                            <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                            <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-FB|0 A )0) (<span class="variable-name">X</span> : obA),
                                              FB[1I Des( [1 f ~&gt; FB|0 A' ]0 &lt;o (FB||1 &lt;o g) ) ~&gt; X]0
                                                ~~  DesIn( [0 W ~&gt; FB[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B.  <span class="proof-tactics-name">intros</span>.
          <span class="comment-delimiter">(*</span><span class="comment">TODO ERASE this line later </span><span class="comment-delimiter">*)</span> <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, DesIn_Input|];
          <span class="proof-tactics-name">apply</span> polyF_morphism.
        <span class="keyword">Qed</span>.

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;FB 1 ) ~~ (f _i)  , 
       therefore metaFB is injective **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- FB|0 A )0),
                                        f ~~ DesIdenObL( (FB[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">apply</span> polyF_inputUnitA.
        <span class="keyword">Qed</span>.
                    
        <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_B_identitary_polyF_identitary</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                                               <span class="type">forall</span> <span class="variable-name">X</span> : obA,  FB||1 ~~ F[0 B ~&gt; - ]1 A X .
        <span class="keyword">Proof</span>. 
          <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B_IdenV. <span class="proof-tactics-name">unfold</span> meta_of_polyF_at_B. <span class="proof-tactics-name">unfold</span> polyF_IdenV .
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> ReflV.
        <span class="keyword">Qed</span>.

      <span class="keyword">End</span> <span class="function-name">Meta_of_poly</span>.

      <span class="keyword">Section</span> <span class="function-name">Poly_of_meta</span>.

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">poly_of_metaP of metaP</span></span><span class="doc"> **)</span>
        
        <span class="keyword">Parameter</span> <span class="variable-name">metaP0</span> : obA -&gt; obV.
        <span class="keyword">Notation</span> <span class="string">"P|0 A"</span> := (metaP0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Parameter</span> <span class="variable-name">metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                            V(0 V |- P|0 A )0 -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; P|0 X ]0 )0.

        <span class="keyword">Notation</span> <span class="string">"P[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>metaP _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">metaP_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 P|0 A ~&gt; P|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>metaP _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"P||1"</span> := (<span class="constant">@</span>metaP_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongMetaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- P|0 A )0),
                                 f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, P[1I f' ~&gt; X ]0 ~~ P[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaP_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                 <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P|0 A )0) (<span class="variable-name">X</span> : obA),
                                   P[1I f &lt;o v ~&gt; X ]0
                                    ~~ [1 v ~&gt; P|0 X ]0 &lt;o P[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaP_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P|0 A )0) (<span class="variable-name">X</span> : obA),
                                      P[1I Des( [1 f ~&gt; P|0 A' ]0 &lt;o (P||1 &lt;o g) ) ~&gt; X]0
                                       ~~  DesIn( [0 W ~&gt; P[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 .

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;P 1 ) ~~ (f _i)  , 
       therefore metaP is injective **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">metaP_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P|0 A )0),
                                        f ~~ DesIdenObL( (P[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
        <span class="comment-delimiter">(*</span><span class="comment">      (** ??? this is extra for metafunctor than polyfunctor : related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h     ....     ( 1 o&gt; # ) ~~ #  ??? **)
      Hypothesis metaP_unitB : forall (B : obB), forall X : obA, (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV (P[0 B ~&gt; X ]0)) ~~ DesIdenObR( P[1I (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitB B) ~&gt; X ]0 ) .         </span><span class="comment-delimiter">*)</span>
        <span class="keyword">Notation</span> <span class="string">"P[0 B ~&gt; A ]0"</span> := (V[0 B ~&gt; P|0 A ]0) (<span class="type">at</span> level 25).
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- P[0 B ~&gt; A ]0 )0 -&gt;
                                     <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; P[0 B ~&gt; X ]0 ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA) =&gt;
               ConsIn (P[1I Des b ~&gt; X ]0). 

        <span class="keyword">Notation</span> <span class="string">"P[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>poly_of_metaP _ _ _ b X) (<span class="type">at</span> level 25).
        <span class="keyword">Notation</span> <span class="string">"P[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>poly_of_metaP _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Input</span> : <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">V W</span> : obV) (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), 
                                 Des( v &lt;o w ) ~~ Des( v ) &lt;o desV10 V w .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV), <span class="type">forall</span> (<span class="variable-name">U1 U1'</span> : obV) (<span class="variable-name">u1</span> : V(0 U1' |- U1 )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                     ConsIn( [1 (1 u1 * V )0 ~&gt; W ]0 &lt;o v ) ~~ [1 u1 ~&gt; [0 V ~&gt; W ]0 ]0 &lt;o ConsIn( v ) .
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      P[1 f &lt;o v ~&gt; X ]0
                                       ~~ [1 v ~&gt; P[0 B ~&gt; X ]0 ]0 &lt;o P[1 f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">apply</span> ConsIn_Output.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">Cong_poly_of_metaP</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                   <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                     f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, P[1 f' ~&gt; X ]0 ~~ P[1 f ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.  <span class="proof-tactics-name">apply</span> CongConsIn, CongMetaP, CongDes. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongConsV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> (<span class="variable-name">V2 V2'</span> : obV) (<span class="variable-name">v v'</span> : V(0 V2 |- V2' )0),
                                   v' ~~ v -&gt; [0 V1 ~&gt; v' ]1 ~~ [0 V1 ~&gt; v ]1 .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                                    ConsIn( v &lt;o i ) ~~ (ConsIn v) &lt;o i .
        <span class="keyword">Hypothesis</span> <span class="variable-name">consV01_functorial</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : V(0 V2 |- V2' )0), <span class="type">forall</span> V2'' (<span class="variable-name">v'</span> : V(0 V2' |- V2'' )0),
                                          [0 V1 ~&gt; v' &lt;o v ]1 ~~  [0 V1 ~&gt; v' ]1 &lt;o  [0 V1  ~&gt; v ]1 .
        <span class="keyword">Parameter</span> <span class="variable-name">Cons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), V(0 (0 U * V )0 |-  W )0 -&gt; V(0 U |-  [0 V ~&gt; W ]0 )0.
        <span class="keyword">Hypothesis</span> <span class="variable-name">CongCons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 (0 U * V )0 |- W )0 ),
                                v' ~~ v -&gt; Cons v' ~~ Cons v.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Des</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U |-  [0 V ~&gt; W ]0 )0),
                                Cons (Des f) ~~ f.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV) (<span class="variable-name">v</span> : V(0 (0 U * V )0 |- W )0),
                                  Cons(v &lt;o desV10 V w)  ~~ Cons( v ) &lt;o w .
        <span class="keyword">Hypothesis</span> <span class="variable-name">DesIn_ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                    DesIn (ConsIn f) ~~ f.

        <span class="keyword">Parameter</span> <span class="variable-name">Assoc</span> : <span class="type">forall</span> {<span class="variable-name">V W</span> : obV}, <span class="type">forall</span> {<span class="variable-name">U</span>: obV}, V(0 (0 U * (0 V * W )0 )0 |- (0 ((0 U * V )0) * W )0 )0.
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_Iso</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U</span>: obV),
                               <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV) (<span class="variable-name">f g</span> : V(0 Y |-  [0 (0 ((0 U * V )0) * W )0 ~&gt; X ]0 )0 ), 
                                 [1 Assoc ~&gt; X ]0 &lt;o f ~~ [1 Assoc  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_nat0</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV), <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV) (<span class="variable-name">f</span> : V(0 U |- U' )0 ),
                                  Assoc &lt;o (1 f * (0 V * W )0 )0 ~~ (1 ((1 f * V )0) * W )0 &lt;o Assoc .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0) ,
                                              (Des ([1 Des (g &lt;o f) ~&gt; PA' ]0 ))
                                                ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))) ) &lt;o Assoc
                                                     : V(0 (0 ([0 QA ~&gt; PA' ]0) * (0V * B )0 )0 |- PA' )0 ).
        <span class="doc">(** Hypothesis Assoc_Des_Des_old : forall V B PA PA' (f : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                     ( (Des ([1 Des f ~&gt; PA' ]0 )) : V(0 (0 ([0 PA ~&gt; PA' ]0) * (0V * B )0 )0 |- PA' )0 )
                                       ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (</span><span class="constant"><span class="doc">@</span></span><span class="doc">IdenV ([0 B ~&gt; PA ]0)) ~&gt; PA' ]0))) ) &lt;o Assoc ). **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">Assoc_DesIn_DesIn</span> :  <span class="type">forall</span> <span class="variable-name">W PX</span>, <span class="type">forall</span>  V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                          DesIn ([0 W ~&gt;  ([1 Des f ~&gt; PX ]0) ]1)
                                                ~~ [1 Assoc ~&gt; PX ]0 &lt;o DesIn( DesIn ([0 W ~&gt;  ConsIn([1 Des f ~&gt; PX ]0) ]1) ) .

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                         P[1 Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; g ]1 ) ~&gt; X ]0
                                          ~~  DesIn( [0 W ~&gt; P[1 f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="comment-delimiter">(*</span><span class="comment"> enough (  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ~~  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ) </span><span class="comment-delimiter">*)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
          <span class="proof-tactics-name">apply</span> CongConsIn, Assoc_Iso.

          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_ConsIn].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Cat1LeftV | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ConsIn_Input | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> Cat2V  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, SymV, Cat2V  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> SymV, Assoc_nat0 ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, SymV, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, Des_consV10_functorial  | <span class="proof-tactics-name">eapply</span> ReflV] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsV10, CongDes, SymV, Cat1LeftV ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaP, SymV, Des_Input ] .

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, CongMetaP, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, SymV, metaP_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, SymV, ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, SymV, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> Assoc_DesIn_DesIn  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, metaP_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, CongMetaP, Cat1LeftV  |].

          <span class="proof-tactics-name">eapply</span> metaP_morphism.
        <span class="keyword">Qed</span>.
        
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 P[0 B ~&gt; A ]0 ~&gt; P[0 B ~&gt; X ]0 ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>poly_of_metaP (P[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (P[0 B ~&gt; A ]0)) X).
        <span class="keyword">Notation</span> <span class="string">"P[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>poly_of_metaP_IdenV B) (<span class="type">at</span> level 25).

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">unit part of above get that the logical category V is polymorph</span></span><span class="doc"> **)</span>

        <span class="keyword">Parameter</span> <span class="variable-name">unitV</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obV}, V(0 I |- V[0 A ~&gt; A ]0 )0.
        <span class="keyword">Notation</span> <span class="string">"'uV'"</span> := (<span class="constant">@</span>unitV _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">unitV_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A</span> : obV,  (<span class="constant">@</span>IdenV A) ~~ DesIdenObL (<span class="constant">@</span>unitV A).

        <span class="keyword">Hypothesis</span> <span class="variable-name">polyV_relV_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV), <span class="type">forall</span> <span class="variable-name">X</span> : obV, (<span class="constant">@</span>IdenV (V[0 A ~&gt; X ]0)) ~~ DesIdenObR( V[1 (<span class="constant">@</span>unitV A) ~&gt; X ]0 ) .

        <span class="keyword">Hypothesis</span> <span class="variable-name">polyV_relV_inputUnitV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV), <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obV),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0),
                                        f  ~~ DesIdenObL( (V[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitV A) ).

        <span class="doc">(** already ConsIn_Input above **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">DesIdenObR_Input</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV) (<span class="variable-name">U'</span> : obV) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                        DesIdenObR( v &lt;o w ) ~~ DesIdenObR( v ) &lt;o w .

        <span class="keyword">Hypothesis</span> <span class="variable-name">consV10_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">U</span> : obV, <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0), 
                                          [1 DesIdenObL  v ~&gt; U ]0  ~~ DesIdenObR( ConsIn( [1 Des v ~&gt; U ]0 ) ) .

        <span class="keyword">Hypothesis</span> <span class="variable-name">consV10_functorial_fun1</span> : <span class="type">forall</span> <span class="variable-name">V1</span>, <span class="type">forall</span> <span class="variable-name">V2</span> : obV,
                                               (<span class="constant">@</span>IdenV _) ~~    [1 (<span class="constant">@</span>IdenV V1) ~&gt; V2 ]0 .

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">continue poly_of_metaP of metaP</span></span><span class="doc"> **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaP_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 P|0 A ~&gt; P|0 X ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; DesIdenObR(<span class="constant">@</span>poly_of_metaP I (P|0 A) A (<span class="constant">@</span>unitV _) X)).
        <span class="keyword">Notation</span> <span class="string">"P|1"</span> := (<span class="constant">@</span>poly_of_metaP_unitV _ _) (<span class="type">at</span> level 0).
        
        <span class="doc">(** poly_of_metaP_unitV_metaP_IdenV : forall A X : obA, P|1 ~~ P||1 **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaP_unitV_metaP_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, 
                                                  <span class="constant">@</span>poly_of_metaP_unitV A X ~~ <span class="constant">@</span>metaP_IdenV A X .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_metaP_unitV. <span class="proof-tactics-name">unfold</span> poly_of_metaP.
          <span class="proof-tactics-name">unfold</span> metaP_IdenV.
          <span class="proof-tactics-name">eapply</span> TransV; cycle 1.
          <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaP, Cat1LeftV .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> SymV, consV10_DesIdenObL | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> SymV, Cat1LeftV.
        <span class="keyword">Qed</span>.

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">poly_of_metaQ of metaQ</span></span><span class="doc"> **)</span>

        <span class="keyword">Parameter</span> <span class="variable-name">metaQ0</span> : obA -&gt; obV.
        <span class="keyword">Notation</span> <span class="string">"Q|0 A"</span> := (metaQ0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Parameter</span> <span class="variable-name">metaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                            V(0 V |- Q|0 A )0 -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; Q|0 X ]0 )0.

        <span class="keyword">Notation</span> <span class="string">"Q[1I b ~&gt; X ]0"</span> := (<span class="constant">@</span>metaQ _ _ b X) (<span class="type">at</span> level 25).

        <span class="keyword">Definition</span> <span class="function-name">metaQ_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, V(0 A[0 A ~&gt; X ]0 |- [0 Q|0 A ~&gt; Q|0 X ]0 )0
          :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>metaQ _ A (<span class="constant">@</span>IdenV _) X).
        <span class="keyword">Notation</span> <span class="string">"Q||1"</span> := (<span class="constant">@</span>metaQ_IdenV _ _) (<span class="type">at</span> level 0).

        <span class="keyword">Hypothesis</span> <span class="variable-name">CongMetaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV)(<span class="variable-name">A</span> : obA),
                               <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- Q|0 A )0),
                                 f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, Q[1I f' ~&gt; X ]0 ~~ Q[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaQ_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                 <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- Q|0 A )0) (<span class="variable-name">X</span> : obA),
                                   Q[1I f &lt;o v ~&gt; X ]0
                                    ~~ [1 v ~&gt; Q|0 X ]0 &lt;o Q[1I f ~&gt; X ]0 .

        <span class="keyword">Hypothesis</span> <span class="variable-name">metaQ_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-Q|0 A )0) (<span class="variable-name">X</span> : obA),
                                      Q[1I Des( [1 f ~&gt; Q|0 A' ]0 &lt;o (Q||1 &lt;o g) ) ~&gt; X]0
                                       ~~  DesIn( [0 W ~&gt; Q[1I f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0 .

        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt;Q 1 ) ~~ (f _i)  , 
       therefore metaQ is injective **)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">metaQ_inputUnitA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">A</span> : obA),
                                      <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- Q|0 A )0),
                                        f ~~ DesIdenObL( (Q[1I f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA A) ).
        <span class="comment-delimiter">(*</span><span class="comment">      (** ??? this is extra for metafunctor than polyfunctor : related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h     ....     ( 1 o&gt; # ) ~~ #  ??? **)
      Hypothesis metaQ_unitB : forall (B : obB), forall X : obA, (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV (Q[0 B ~&gt; X ]0)) ~~ DesIdenObR( Q[1I (</span><span class="constant"><span class="comment">@</span></span><span class="comment">unitB B) ~&gt; X ]0 ) .         </span><span class="comment-delimiter">*)</span>
        <span class="keyword">Notation</span> <span class="string">"Q[0 B ~&gt; A ]0"</span> := (V[0 B ~&gt; Q|0 A ]0) (<span class="type">at</span> level 25).
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- Q[0 B ~&gt; A ]0 )0 -&gt;
                                     <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; Q[0 B ~&gt; X ]0 ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- Q[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA) =&gt;
               ConsIn (Q[1I Des b ~&gt; X ]0). 

        <span class="keyword">Notation</span> <span class="string">"Q[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>poly_of_metaQ _ _ _ b X) (<span class="type">at</span> level 25).
        <span class="keyword">Notation</span> <span class="string">"Q[0 X ~&gt; a ]1"</span> := (<span class="constant">@</span>poly_of_metaQ _ _ _ (<span class="constant">@</span>IdenV _) X &lt;o (<span class="variable-name">a</span> : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25).

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaQ_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- Q[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      Q[1 f &lt;o v ~&gt; X ]0
                                       ~~ [1 v ~&gt; Q[0 B ~&gt; X ]0 ]0 &lt;o Q[1 f ~&gt; X ]0 .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaQ, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, metaQ_arrow ].
          <span class="proof-tactics-name">apply</span> ConsIn_Output.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">Cong_poly_of_metaQ</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                   <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- Q[0 B ~&gt; A ]0 )0),
                                     f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA, Q[1 f' ~&gt; X ]0 ~~ Q[1 f ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.  <span class="proof-tactics-name">apply</span> CongConsIn, CongMetaQ, CongDes. <span class="coq-solve-tactics">assumption</span>.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaQ_morphism</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">V</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-Q[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                         Q[1 Des( [1 f ~&gt; Q[0 B ~&gt; A' ]0 ]0 &lt;o Q[0 A' ~&gt; g ]1 ) ~&gt; X ]0
                                          ~~  DesIn( [0 W ~&gt; Q[1 f ~&gt; X ]0 ]1 ) &lt;o A[1 g ~&gt; X ]0.
        <span class="keyword">Proof</span>.
          <span class="comment-delimiter">(*</span><span class="comment"> enough (  [1Assoc ~&gt; Q|0 X ]0 &lt;o DesIn ( _ ) ~~  [1Assoc ~&gt; Q|0 X ]0 &lt;o DesIn ( _ ) ) </span><span class="comment-delimiter">*)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
          <span class="proof-tactics-name">apply</span> CongConsIn, Assoc_Iso.

          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_ConsIn].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, metaQ_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaQ, Cat1LeftV | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, metaQ_arrow | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ConsIn_Input | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> Cat2V  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, SymV, Cat2V  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> SymV, Assoc_nat0 ] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, SymV, Cat2V ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, Des_consV10_functorial  | <span class="proof-tactics-name">eapply</span> ReflV] ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsV10, CongDes, SymV, Cat1LeftV ] .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaQ, SymV, Des_Input ] .

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, CongMetaQ, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, SymV, metaQ_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, SymV, ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, SymV, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> Assoc_DesIn_DesIn  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, consV01_functorial  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, metaQ_arrow  |].
          <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, CongMetaQ, Cat1LeftV  |].

          <span class="proof-tactics-name">eapply</span> metaQ_morphism.
        <span class="keyword">Qed</span>.
        
        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaQ_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 Q[0 B ~&gt; A ]0 ~&gt; Q[0 B ~&gt; X ]0 ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>poly_of_metaQ (Q[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV (Q[0 B ~&gt; A ]0)) X).
        <span class="keyword">Notation</span> <span class="string">"Q[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>poly_of_metaQ_IdenV B) (<span class="type">at</span> level 25).

        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">continue poly_of_metaQ of metaQ</span></span><span class="doc"> **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_metaQ_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                         <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 A[0 A ~&gt; X ]0  |- [0 Q|0 A ~&gt; Q|0 X ]0 )0
          := (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; DesIdenObR(<span class="constant">@</span>poly_of_metaQ I (Q|0 A) A (<span class="constant">@</span>unitV _) X)).
        <span class="keyword">Notation</span> <span class="string">"Q|1"</span> := (<span class="constant">@</span>poly_of_metaQ_unitV _ _) (<span class="type">at</span> level 0).
        
        <span class="doc">(** poly_of_metaQ_unitV_metaQ_IdenV : forall A X : obA, Q|1 ~~ Q||1 **)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaQ_unitV_metaQ_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA, 
                                                  <span class="constant">@</span>poly_of_metaQ_unitV A X ~~ <span class="constant">@</span>metaQ_IdenV A X .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_metaQ_unitV. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">unfold</span> metaQ_IdenV.
          <span class="proof-tactics-name">eapply</span> TransV; cycle 1.
          <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaQ, Cat1LeftV .
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaQ_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> SymV, consV10_DesIdenObL | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1  | <span class="proof-tactics-name">eapply</span> ReflV] ].
          <span class="proof-tactics-name">eapply</span> SymV, Cat1LeftV.
        <span class="keyword">Qed</span>.

        
        <span class="doc">(** ** </span><span class="company-coq-coqdoc-h2"><span class="doc">now natural metatransformation</span></span><span class="doc"> **)</span>

        <span class="keyword">Parameter</span> <span class="variable-name">meta&#946;</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                            V(0 P|0 A |- Q|0 A )0.

        <span class="keyword">Notation</span> <span class="string">"&#946;||0 A"</span> := (<span class="constant">@</span>meta&#946; A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
        <span class="keyword">Hypothesis</span> <span class="variable-name">meta&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA)  (<span class="variable-name">A'</span> : obA),
                                      [0 P|0 A ~&gt;  &#946;||0 A' ]1 &lt;o P||1
                                                                ~~ [1 &#946;||0 A ~&gt; Q|0 A' ]0 &lt;o Q||1.

        <span class="doc">(** Cons et al was here , Des_Input was here **)</span>

        <span class="keyword">Definition</span> <span class="function-name">poly_of_meta&#946;</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                     V(0 V |- P[0 B ~&gt; A ]0 )0 -&gt;
                                     V(0 V |- Q[0 B ~&gt; A ]0 )0
          := <span class="type">fun</span> (<span class="variable-name">V B</span> : obV) (<span class="variable-name">A</span> : obA) (<span class="variable-name">b</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) =&gt;
               Cons (&#946;||0 A &lt;o Des b) .
        
        <span class="doc">(** :^) **)</span>
        <span class="keyword">Notation</span> <span class="string">"&#946;|1 f"</span> := (<span class="constant">@</span>poly_of_meta&#946; _ _ _ f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity).
        <span class="doc">(** this Notation "&#946;|0 A" is not held below **)</span>
        <span class="keyword">Notation</span> <span class="string">"&#946;|0 A"</span> := (<span class="constant">@</span>poly_of_meta&#946; _ _ A (<span class="constant">@</span>IdenV _)) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">A</span> : obA),
                                    <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA),
                                      &#946;|1 (f &lt;o v)
                                          ~~ &#946;|1 f &lt;o v .
        <span class="keyword">Proof</span>.
          <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">unfold</span> poly_of_meta&#946;.
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cons_Input  |] .
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCons; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |] .
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCons; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV |  <span class="proof-tactics-name">eapply</span> Des_Input  ] |] .
          <span class="proof-tactics-name">eapply</span> ReflV.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">Cons_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> :  V(0 (0 U * V )0 |-  W )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                                   [0 V ~&gt; w ]1 &lt;o Cons( v ) ~~ Cons( w &lt;o v ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                                  Des( [0 V ~&gt; w ]1 &lt;o v ) ~~ w &lt;o Des( v ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_Output2</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV), <span class="type">forall</span> (<span class="variable-name">U1</span> : obV) , <span class="type">forall</span> (<span class="variable-name">W W'</span> : obV) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 * V )0 ~&gt; W ]0 )0),
                                      ConsIn( [0 (0 U1 * V )0 ~&gt; w ]1 &lt;o v ) ~~ [0 U1 ~&gt; [0 V ~&gt; w ]1 ]1 &lt;o ConsIn( v ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">ConsIn_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0),
                                                 ( ConsIn (([1 Des (g &lt;o f) ~&gt; PA' ]0)) )
                                                   ~~ ( ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))
                                                        : V(0 [0 QA ~&gt; PA' ]0 |- [0 V ~&gt; [0 B ~&gt; PA' ]0 ]0 )0 ) .
        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_Cons</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 (0 U * V )0 |-  W )0),
                                Des (Cons f) ~~ f.
        
        <span class="doc">(** ?? may change def of funtor into V because now extra decoding while already in V ?? **)</span>
        <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
        <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                         &#946;|1 (Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; a ]1 ))
                                             ~~ (Des( [1 &#946;|1 f ~&gt; Q[0 B ~&gt; A' ]0 ]0 &lt;o Q[0 A' ~&gt; a ]1 )) .
        <span class="keyword">Proof</span>.
          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_meta&#946;. <span class="proof-tactics-name">unfold</span> poly_of_metaP. <span class="proof-tactics-name">unfold</span> poly_of_metaQ.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV| <span class="proof-tactics-name">eapply</span> Cons_Des] ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaP, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, ConsIn_consV10_functorial ].        
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Des_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  SymV, Des_Output ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, SymV, Cat2V].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2 ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> CongConsIn, consV11_bifunctorial ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|] ; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|] ; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> meta&#946;_morphism   ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDes; <span class="proof-tactics-name">eapply</span> SymV, Cat2V]. 
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V].

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> CongDes. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |]. <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn , CongMetaQ, SymV, Cat1LeftV |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn , SymV, metaQ_arrow |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |].
          <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV].

          <span class="doc">(** more pure logic *)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10, CongDes, SymV, Cat1LeftV].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn; <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10,  SymV, Des_Cons ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10,  CongDes, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> ConsIn_consV10_functorial.
        <span class="keyword">Qed</span>.

        <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_morphism_codomain</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV),
                                                <span class="type">forall</span> (<span class="variable-name">B</span> : obV) (<span class="variable-name">W</span> : obV) (<span class="variable-name">B'</span> : obV) (<span class="variable-name">b</span> : V(0 W |- V[0 B' ~&gt; B]0 )0),
                                                <span class="type">forall</span> (<span class="variable-name">A</span> : obA),
                                                <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-P[0 B ~&gt; A ]0 )0),
                                                  &#946;|1 (Des( V[1 b ~&gt; P|0 A ]0 &lt;o f ))
                                                      ~~  Des( V[1 b ~&gt; Q|0 A ]0 &lt;o &#946;|1 f ).
        <span class="keyword">Proof</span>.
          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">unfold</span> poly_of_meta&#946;.
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
          <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV| <span class="proof-tactics-name">eapply</span> Cons_Des] ].

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> Cons_Output |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cons_Des |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_DesIn |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, polyV_relV_polyV_relT |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, Cat2V |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, consV11_bifunctorial |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, Cat1RightV |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2 |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> SymV, Des_Output  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, Cat2V |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, Cat1LeftV  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, polyV_relV_polyV_relT  |].
          <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_DesIn  |].

          <span class="proof-tactics-name">eapply</span> ReflV.
        <span class="keyword">Qed</span>.

        <span class="keyword">Hypothesis</span> <span class="variable-name">Des_I_Iso</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                               <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV) (<span class="variable-name">f g</span> : V(0 Y |-  [0  A ~&gt; X ]0 )0 ), 
                                 [1 Des (<span class="constant">@</span>IdenV ([0 I ~&gt; A ]0)) ~&gt; X ]0 &lt;o f ~~ [1  Des (<span class="constant">@</span>IdenV ([0 I ~&gt; A ]0))  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .

        <span class="keyword">Lemma</span> <span class="function-name">meta_morphism_of_poly_of_meta&#946;</span> : ( <span class="type">forall</span> (<span class="variable-name">V</span> : obV) (<span class="variable-name">B</span> : obV),
                                                 <span class="type">forall</span> (<span class="variable-name">A</span> : obA) (<span class="variable-name">W</span> : obV) (<span class="variable-name">A'</span> : obA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- P[0 B ~&gt; A ]0 )0),
                                                   &#946;|1 (Des( [1 f ~&gt; P[0 B ~&gt; A' ]0 ]0 &lt;o P[0 A' ~&gt; a ]1 ))
                                                       ~~ (Des( [1 &#946;|1 f ~&gt; Q[0 B ~&gt; A' ]0 ]0 &lt;o Q[0 A' ~&gt; a ]1 )) )
                                               -&gt; ( <span class="type">forall</span> (<span class="variable-name">A</span> : obA)  (<span class="variable-name">A'</span> : obA),
                                                     [0 P|0 A ~&gt;  &#946;||0 A' ]1 &lt;o P||1
                                                                               ~~ [1 &#946;||0 A ~&gt; Q|0 A' ]0 &lt;o Q||1 ) .
        <span class="keyword">Proof</span>.
          <span class="doc">(** LHS **)</span>
          <span class="proof-tactics-name">intro</span> H_poly_morphism. <span class="proof-tactics-name">intros</span>.
          <span class="proof-tactics-name">specialize</span> H_poly_morphism <span class="type">with</span> (B := I) (A := A) (A' := A') (a := 1) (f := 1).
          <span class="proof-tactics-name">unfold</span> poly_of_meta&#946; <span class="type">in</span> H_poly_morphism. <span class="proof-tactics-name">unfold</span> poly_of_metaP <span class="type">in</span> H_poly_morphism. <span class="proof-tactics-name">unfold</span> poly_of_metaQ <span class="type">in</span> H_poly_morphism.
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cons_Des ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1 ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat1RightV ]. 
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsIn, CongMetaP, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsIn, metaP_arrow ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, ConsIn_Input ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Des_Output ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2   ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, SymV, ConsIn_Input   ].

          <span class="doc">(** RHS **)</span>
          <span class="proof-tactics-name">eapply</span> CongCons <span class="type">in</span> H_poly_morphism.
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> Cons_Des]. <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> Cons_Des].
          <span class="proof-tactics-name">eapply</span>  TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat1RightV ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaQ, Cat1LeftV ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn, metaQ_arrow].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> ConsIn_Input].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_consV10_functorial ].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input].
          <span class="proof-tactics-name">eapply</span> CongDesIn <span class="type">in</span> H_poly_morphism.
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> DesIn_ConsIn]. <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> DesIn_ConsIn].        
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> CongConsV10, CongDes, SymV, Cat1LeftV].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> CongConsV10, Des_Cons].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> consV10_functorial].
          <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> Cat2V].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> consV11_bifunctorial ].
          <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> Cat2V ].
          <span class="proof-tactics-name">eapply</span> Des_I_Iso <span class="type">in</span> H_poly_morphism.

          <span class="coq-solve-tactics">exact</span> H_poly_morphism.
        <span class="keyword">Qed</span>.
        
      <span class="keyword">End</span> <span class="function-name">Poly_of_meta</span>.

    <span class="keyword">End</span> <span class="function-name">MetaTransformation</span>.

    <span class="keyword">Module</span> <span class="function-name">NaturalityIsPolymorphic</span>.


      
    <span class="keyword">End</span> <span class="function-name">NaturalityIsPolymorphic</span>.

    <span class="keyword">Module</span> <span class="function-name">PolymorphismIsNaturalitywithinGallina</span>.

    <span class="keyword">End</span>  <span class="function-name">PolymorphismIsNaturalitywithinGallina</span>.
      
    <span class="keyword">End</span> <span class="function-name">NaturalityIsPolymorphic</span>.

  <span class="keyword">End</span> <span class="function-name">Transformation</span>.

<span class="keyword">End</span> <span class="function-name">Functor</span>.
</pre>
  </body>
</html>
