<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.47 in css mode. -->
<html>
  <head>
    <title>borceuxSolution4.v</title>
    <style type="text/css">
    <!--
      body {
        color: #000000;
        background-color: #ffffff;
      }
      .comment {
        /* font-lock-comment-face */
        color: #b22222;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #b22222;
      }
      .company-coq-comment-h2 {
        /* company-coq-comment-h2-face */
        color: #8b2252;
        font-size: 180%;
      }
      .company-coq-featuresXcode-folding-bullet {
        /* company-coq-features/code-folding-bullet-face */
        color: #3a5fcd;
        text-decoration: underline;
      }
      .company-coq-featuresXsmart-subscripts {
      }
      .constant {
        /* font-lock-constant-face */
        color: #008b8b;
      }
      .coq-cheat {
        /* coq-cheat-face */
        background-color: #ff0000;
      }
      .coq-solve-tactics {
        /* coq-solve-tactics-face */
        color: #ff0000;
      }
      .doc {
        /* font-lock-doc-face */
        color: #8b2252;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #0000ff;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #a020f0;
      }
      .proof-tacticals-name {
        /* proof-tacticals-name-face */
        color: #b452cd;
      }
      .proof-tactics-name {
        /* proof-tactics-name-face */
        color: #00008b;
      }
      .string {
        /* font-lock-string-face */
        color: #8b2252;
      }
      .type {
        /* font-lock-type-face */
        color: #228b22;
      }
      .variable-name {
        /* font-lock-variable-name-face */
        color: #a0522d;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="company-coq-comment-h2">(*+ borceuxSolution.v +*)</span>

<span class="doc">(**_____________________________________________________________________________

Proph,

https://github.com/1337777/borceux/blob/master/borceuxSolution2.v

___MATHCOMP___

5. Some possible timed-tutoring sequence for the mathcomp

[1] &lt;&lt;Canonical Structures for the working Coq user&gt;&gt; , https://hal.inria.fr/hal-00816703/
[2] &lt;&lt;A Modular Formalisation of Finite Group Theory&gt;&gt; , https://hal.inria.fr/inria-00139131/ 
[3] &lt;&lt;Canonical Big Operators&gt;&gt; , https://hal.inria.fr/inria-00331193/
[4] &lt;&lt;Packaging Mathematical Structures&gt;&gt; , https://hal.inria.fr/inria-00368403/
[5] &lt;&lt;Point-Free, Set-Free Concrete Linear Algebra&gt;&gt; , https://hal.inria.fr/hal-00805966/
[6] &lt;&lt;A Machine-Checked Proof of the Odd Order Theorem&gt;&gt; , https://hal.inria.fr/hal-00816699/
[7] &lt;&lt;A Small Scale Reflection Extension for the Coq system&gt;&gt; , https://hal.inria.fr/inria-00258384/

Also the public may now stake for the nondependent Solution Programme Reviews , which has motivation to publish reviews, by the publishers-own-motion, which may be held as timed-tutoring tools; and the MATHCOMP database is best start for such reviews :
    paypal 1337777.OOO@gmail.com , wechatpay 2796386464@qq.com , irc #OOO1337777

Initial review : mathcomp motivation is to finding the good coordinates to describe mathematical things. One common tool is the notations technique for infix notations and for hiding or showing arguments which may or may not be implicit. Another common tool is the &lt;&lt;data-class interfaces&gt;&gt;  and the &lt;&lt;sharings constraints&gt;&gt; and the &lt;&lt;automatic declassifications&gt;&gt;  ("inheritance", "coercion")  and the automatic classification ("canonical structures") of data.
    Maybe Gonthier's initial enabling angle of view is : constrast from numeric motivations into recursive-logical motivations. For example instead of inverse of matrix (numeric) motivation, then get adjugate of matrix (purely recursive) and determinant (purely logical) motivations. For example instead of the Gauss LUP encoding (numeric) motivation, then get Gonthier CrR encoding (purely recursive) and rank (purely logical) motivations.
    Most things interact with 3 themes : the numeric (for example, integers Z/nZ) and the combinatorial (for example, permutations Sym_n) and the geometric characterization/representation (for example, isometries of n-polygon)  ...

___POLYMORPHISM___

6. Now [8] is successor of some earlier text which describes how to program &lt;&lt;polymorphism&gt;&gt; ("enriched categories"). The finding is that some functor or category (identity functor) is given by the data

polyF : forall (log : logic) (dat : data log) (V : obV log) (B : obB dat) (A : obA dat),
log.-V(0 V |- dat.-F[0 B ~&gt; A ]0 )0 -&gt;
forall X : obA dat, log.-V(0 dat.-A[0 A ~&gt; X ]0 |- log.-[0 V ~&gt; dat.-F[0 B ~&gt; X ]0 ]0 )0 

, where dat.-F[0 B ~&gt; A ]0  denotes  dat.-B[0 B ~&gt; dat.-F|0 A ]0 , which is polymorph in the variable V and polymorph in the variable A . And the Coq meta logic and the functors logic and the yoneda lemma are now described fully only within this new polymorphism terminology .

7. TL;DR: solves some question of &#3589;( &#819;&#8226; &#9697; &#8226; &#819;)&#3589;-Ye [11] which is how thought is affected by the new notation ( ( _1 _3 ) o&gt;F _2 ) for functors, which is not reality. Now polymorph/commuting/natural/associativity in variable A says
( ((b _v) o&gt;F (a _w)) o&gt;F a' )   ~~   ( (b _v) o&gt;F ((a _w) o&gt;A a') )

8. This solution may be viewed as continuing the programme of Gentzen natural (=polymorphic) deduction and Dosen cut elimination for adjunctions, where Dosen critically did replace the counit by the primitive ( _ o&gt; counit ) .
    Therefore this solution also shows &lt;&lt;cut elimination/desintegration for these polymorph functors/categories&gt;&gt; and eventually for polymorph adjunctions and polymorph monads . 

9. And that any category is some identity functor is precisely mirrored in the &lt;&lt;data-class interfaces&gt;&gt;  and the &lt;&lt;sharings constraints&gt;&gt; and the &lt;&lt;automatic declassifications&gt;&gt;  ("packaging  interfaces and their inheritance coercions", "structure vs property") .

10. And this new polymorphism thing is better for the  &lt;&lt;semi-programmed semi-automatic classification of data&gt;&gt; (Coq "canonical structures" or Matita "unification hints", "garbage collector") .
    Also remember that the purely-logical non-polymorphism parts of in the deductions in this Coq text shall be automatically solved by some small-scale reflection into the decision-dissolvers enabled by the Dosen cut elimination in adjunctions technique [9] and the Maclane associativity coherence technique and any other coherence technique [10].
    Also, eventually one shall get some alternative presentation of the logic which is mostly functional instead of being in the common monoidal form, for example, always hold the ( U |- [ I ~&gt; U] ) arrow data instead of the common ( U &amp; I |- U ) arrow data. And eventually one may extend this presentation with some monad on the collection of objects of the functor ...

___QUESTION___ ( friday 11:25 AM collocated near CT2016 and irc #OOO1337777 )

11. One question which is unresolved is how to describe that any functor's polymorphism is actually some (more common) polymorphism of some metatransformation inside the Coq meta logic. This question is related to the question of how to really define functor and composition of functors, while knowing that the yoneda lemma does not require polymorphism in the variable B and does not require composition of functors .
    ? How does this fully-general data ( (c _w) o&gt;F' ( (b _v) o&gt;F a ) ) define any single-functor or composition-of-functors thing, without assuming [ polymorphism in variable B and post-unit for form catB ] ?

___WEBCITATIONS/REVIEWS/TIMEDTUTORING___

[8] 1337777.OOO , https://web.archive.org/web/*/github.com/1337777/borceux/blob/master/borceuxSolution2.v
[9] &lt;&lt;Cut Elimination in Categories&gt;&gt; , https://books.google.com/books?isbn=9401712077
[10] &lt;&lt;Proof-net Categories&gt;&gt; , https://books.google.com/books?isbn=8876990801
[11] &#3589;( &#819;&#8226; &#9697; &#8226; &#819;)&#3589;-Ye , https://github.com/hypotext/notation

* use this webcitations/reviews tool and this authorizing-geolocated-timed-tutoring tool to play these links as TV !
http://1337777.link/ooo/guJAHkwRZYYyuhrh4GyYWv7BPOwNEF-jSeQcYN9WxLk!Zw1GYSFfr6cheRhkPhTPCnsog7DFPZQUCcv7ZEKh22s/2016/1/1/1/1/1/1

_____________________________________________________________________________**)</span>

<span class="doc">(**_____________________________________________________________________________

___USER MANUAL___

____(1) notation for polyF says

(f _v) o&gt;F g    ... f logical-indexing in the codomain ... g change of morphism-index in the domain

____(2) polymorph in V says

((f &lt;&lt;o v) _v')) o&gt;F g  ~~  (f (v _v')) o&gt;F g   /!\ argument _v' is inputed only later /!\

____(3) polymorph in A says

((f _v) o&gt;F (a _w)) o&gt;F g ~~  (f _v) o&gt;F ((a _w) o&gt;A g)

____(4) functor unit

(f _v) o&gt;F unitA ~~ (f _v)

____(5) form unit

unitA o&gt;A g ~~ g

____(6) polymorph in B says

( (b _w) o&gt;B (f _v) ) o&gt;F g   ~~   (b _w) o&gt;B ( (f _v) o&gt;F g )

_____(6.1) and particular when f is unitB constance and polyB_inputUnitB is present

(b _w) o&gt;B ( unitB o&gt;F g )   ~~   ( (b _w) o&gt;B unitB ) o&gt;F g   ~~   (b _w) o&gt;F g

then get B[B ~&gt; -] &lt;o F|1 A X ~~ F[B ~&gt; -] A X

____(7) composition of functors says

(f' _w) o&gt;F' ( (f _v) o&gt;F g )

_____(7.1)  (f' _w) o&gt;F'Fnew ( (f _v) ; g ) assuming some associativity axiom(s) which is polymorph in B and polyB_inputUnitB (for example when B is category), then can do the generality above by only right inputing into F and left-right-inputing into F' :
(f' _w) o&gt;F' ( (f _v) o&gt;F g )  ~~ (f' _w) o&gt;F' ( (f _v) o&gt;B (unitB o&gt;F g) ) 
~~ ( (f' _w) o&gt;F' (f _v) ) o&gt;F' (unitB o&gt;F g)  =: ( (f' _w) o&gt;F' (f _v) ) o&gt;F'Fold g

now yoneda does not require these extra associativity axiom(s): polymorphism in B and does not require composition of functors. 
therefore may be some new notion of functor or composition of functor

____(8) cut desintegration

primo, memo that polymorphisms in V is not really useful

_____(8.1) functor o&gt;F cut desintegration

(f _v) o&gt;F g

+ (f _v) o&gt;F 1  ~~  (f _v)  ... o&gt;F not linked
+ (f _v) o&gt;F (g'' o&gt;A g')  ~~  ((f _v) o&gt;F g'') o&gt;A g'  ... o&gt;F linked to o&gt;F
+ g generative
++ 1 o&gt;F ggen  ... atomic
++ ((f _v) o&gt;F g') o&gt;F ggen  ~~ (f _v) o&gt;F (g o&gt;A ggen)  ...  o&gt;F linked to o&gt;A
++ (fgen _v) o&gt;F ggen  ... atomic

_____(8.2) category o&gt;A cut desintegration

g1 o&gt;A g2  ... cut desintegration of o&gt;F only for now, if want cut desintegration of o&gt;A then require more properties on catA than polyA_unitA, for example polyA_morphism

+ g1 o&gt;A 1   ???
+ g1 o&gt;A (g2'' o&gt;A g2')  ???
+ g2 generative
++ 1 o&gt;A g2gen  ~~ g2gen   ... atomic
++ (g1' o&gt;A g1'') o&gt;A g2gen  ???
++ g1gen o&gt;A g2gen  ... atomic
_____________________________________________________________________________**)</span>


<span class="keyword">Module</span> <span class="function-name">METALOGIC</span>.
  Global <span class="type">Set</span> Universe Polymorphism.
  Global <span class="keyword">Set Implicit Arguments</span>.
  Global <span class="keyword">Unset Strict Implicit</span>.
  Global Unset Printing Implicit Defensive.
  
  <span class="doc">(** ultimate meta logic (Coq type theory) T , which enrich all the subject logics instances of the interface V ... 

now T is on top of Type is instance of meta/logical category with interface V , 
++    any instance of interface V is enriched in T , 
++   T is both ordinary (in T) and enriched in itself T where ordinary (0 _ |- _ )0 coincide with enriched [0 _  ~&gt; _ ]0  ,
++    TODO NEXT: show polymorphicity (polyF_morphism or polyF_arrow) of category or functor  is naturality (meta&#945;_morphism or meta&#965;_morphism) of meta transformation polyF (in index A or index V) where the logic is the T instance of interface V; Also is it necessary, for efficient semi-automatic semi-programmed canonical resolution/synthesis of the polymorphicity class,  that one shall express polymorphicity as naturality in the ultimate Coq meta logic T ? Or is polymorphicity-as-is workable ?

later, top interface is  polyfunctor, get category by putting F is identity : obA -&gt; obB := obA   and now polyF_morphism becomes the wanted polyA_morphism ,   get metafunctor by putting  obB := obV   and now polyF_morphism becomes the wanted metaF_morphism  **)</span>

  <span class="keyword">Definition</span> <span class="function-name">obT</span> : <span class="type">Type</span> := <span class="type">Type</span>. 
  <span class="keyword">Definition</span> <span class="function-name">polyT_relT00</span> : obT -&gt; obT -&gt; obT := <span class="type">fun</span> <span class="variable-name">T1 T2</span> =&gt; T1 -&gt; T2.
  <span class="keyword">Notation</span> <span class="string">"T(0 B |- A )0"</span> := (polyT_relT00 B A) (<span class="type">at</span> level 35, format <span class="string">"T(0  B  |-  A  )0"</span>).

  <span class="doc">(** TODO: how to define conversion such to avoid functional extensionality for T ?
comprehended as conversion on the enriched data **)</span>
  <span class="comment-delimiter">(*</span><span class="comment">Inductive convT : forall T1 T2, T(0 T1 |- T2)0 -&gt; T(0 T1 |- T2 )0 -&gt; Prop :=
  convT_Base : forall T1 T2 f g,  (forall t1, f t1 = g t1) -&gt; </span><span class="constant"><span class="comment">@</span></span><span class="comment">convT T1 T2 f g
| convT_Step : forall T1 T21 T22 f g,  (forall t1 ,  (</span><span class="constant"><span class="comment">@</span></span><span class="comment">convT T21 T22 (f t1) (g t1))) -&gt; </span><span class="constant"><span class="comment">@</span></span><span class="comment">convT T1 (T21 -&gt; T22) f g.
   </span><span class="comment-delimiter">*)</span>
  <span class="keyword">Definition</span> <span class="function-name">convT</span> : <span class="type">forall</span> <span class="variable-name">T1 T2</span>, T(0 T1 |- T2)0 -&gt; T(0 T1 |- T2 )0 -&gt; <span class="type">Prop</span> := <span class="type">fun</span> <span class="variable-name">T1 T2</span> =&gt; eq . <span class="comment-delimiter">(*</span><span class="comment">forall t1, f t1 = g t1.</span><span class="comment-delimiter">*)</span>
  <span class="keyword">Notation</span> <span class="string">"v2 ~~T v1"</span> := (convT v2 v1)  (<span class="type">at</span> level 70).

  <span class="keyword">Definition</span> <span class="function-name">polyT_relT</span> : <span class="type">forall</span> (<span class="variable-name">T</span> : obT), <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                            ( T -&gt; T(0 B |- A )0 ) -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obT, T(0 A |- X )0  -&gt;  ( T -&gt; T(0 B |- X )0 )
    := (<span class="type">fun</span> (<span class="variable-name">T</span> : obT) (<span class="variable-name">B</span> : obT)  (<span class="variable-name">A</span> : obT) (<span class="variable-name">f</span> : T -&gt; T(0 B |- A )0) 
          (<span class="variable-name">X</span> : obT) (<span class="variable-name">g</span> : T(0 A |- X )0) (<span class="variable-name">t</span> : T) (<span class="variable-name">b</span> : B) =&gt;   g (f t b)) .
  <span class="comment-delimiter">(*</span><span class="comment">Arguments polyT_relT : simpl never.</span><span class="comment-delimiter">*)</span>

  <span class="keyword">Definition</span> <span class="function-name">cstT</span> : <span class="type">forall</span> {<span class="variable-name">T2</span> : <span class="type">Type</span>}, T2 -&gt; <span class="type">forall</span> {<span class="variable-name">T1</span> : <span class="type">Type</span>}, T1 -&gt; T2 := <span class="type">fun</span> T2 (<span class="variable-name">t2</span> : T2) =&gt; <span class="type">fun</span> T1 (_ : T1) =&gt; t2.
  <span class="comment-delimiter">(*</span><span class="comment">Arguments cstT : simpl never.</span><span class="comment-delimiter">*)</span>

  <span class="doc">(** almost same as the common constant .. but no unit-picking mentionned **)</span>
  <span class="keyword">Definition</span> <span class="function-name">polyT_relT_constant</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                                     T(0 B |- A )0 -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obT, T(0 A |- X )0  -&gt; T(0 B |- X )0
    := (<span class="type">fun</span> (<span class="variable-name">B A</span> : obT) (<span class="variable-name">f</span> : T(0 B |- A )0) (<span class="variable-name">X</span> : obT) (<span class="variable-name">g</span> : T(0 A |- X )0) =&gt;
          polyT_relT (cstT f) g tt) .
  <span class="comment-delimiter">(*</span><span class="comment">Arguments polyT_relT_constant : simpl never.</span><span class="comment-delimiter">*)</span>

  <span class="keyword">Definition</span> <span class="function-name">idT</span> {<span class="variable-name">T</span> : <span class="type">Type</span>} : T -&gt; T := <span class="type">fun</span> <span class="variable-name">x</span> : T =&gt; x .
  Arguments idT : <span class="proof-tactics-name">simpl</span> never.

  <span class="keyword">Definition</span> <span class="function-name">polyT_relT_identitary</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                                     <span class="type">forall</span> <span class="variable-name">X</span> : obT, T(0 A |- X )0  -&gt; T(0 B |- A )0 -&gt; T(0 B |- X )0
    :=  <span class="type">fun</span> (<span class="variable-name">B</span> : obT) =&gt; <span class="type">fun</span> (<span class="variable-name">A</span> : obT) =&gt;
                        <span class="type">fun</span> <span class="variable-name">X</span> : obT =&gt;  <span class="type">fun</span> (<span class="variable-name">a</span> : T(0 A |- X )0) =&gt; <span class="type">fun</span> (<span class="variable-name">b</span> : T(0 B |- A )0) =&gt;
                                                              <span class="constant">@</span>polyT_relT (T(0 B |- A )0) B A idT X a b .
  <span class="comment-delimiter">(*</span><span class="comment">Arguments polyT_relT_identitary : simpl never.</span><span class="comment-delimiter">*)</span>

  <span class="keyword">Definition</span> <span class="function-name">IdenT</span> {<span class="variable-name">T</span> : obT} : T(0 T |- T )0 := <span class="constant">@</span>idT T .
  <span class="keyword">Notation</span> <span class="string">"'1T"</span> := (<span class="constant">@</span>IdenT _) (<span class="type">at</span> level 0).

  <span class="keyword">Notation</span> <span class="string">"T(1 b |- X )0"</span> := (<span class="constant">@</span>polyT_relT _ _ _ b X) (<span class="type">at</span> level 35, format <span class="string">"T(1  b  |-  X  )0"</span>).

  <span class="keyword">Notation</span> <span class="string">"T(1I b |- X )0"</span> := (<span class="constant">@</span>polyT_relT_constant _ _ b X) (<span class="type">at</span> level 35, format <span class="string">"T(1I  b  |-  X  )0"</span>).
  <span class="keyword">Notation</span> <span class="string">"b o&gt;&gt; a"</span> := (<span class="constant">@</span>polyT_relT_constant _ _ b _ a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
  <span class="keyword">Eval</span> <span class="proof-tactics-name">compute</span> <span class="type">in</span>  <span class="type">fun</span> <span class="variable-name">b a</span> =&gt; b o&gt;&gt; a .

  <span class="keyword">Notation</span> <span class="string">"T(0 X |- - )1"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ X) (<span class="type">at</span> level 35, format <span class="string">"T(0  X  |-  -  )1"</span>).
  <span class="keyword">Notation</span> <span class="string">"T(0 X |- a )1"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ X a) (<span class="type">at</span> level 35, format <span class="string">"T(0  X  |-  a  )1"</span>).
  <span class="keyword">Notation</span> <span class="string">"a &lt;&lt;o b"</span> := (<span class="constant">@</span>polyT_relT_identitary _ _ _ a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
  <span class="keyword">Eval</span> <span class="proof-tactics-name">compute</span> <span class="type">in</span>  <span class="type">fun</span> <span class="variable-name">b a</span> =&gt; a &lt;&lt;o b .

  <span class="keyword">Definition</span> <span class="function-name">consT00</span> : obT -&gt; obT -&gt; obT.
    <span class="proof-tactics-name">intros</span> V1 V2. <span class="coq-solve-tactics">exact</span> ( (V1 -&gt; V2) % type). <span class="keyword">Defined</span>.
  <span class="keyword">Definition</span> <span class="function-name">consT01</span> : <span class="type">forall</span> {<span class="variable-name">V1</span> : obT}, <span class="type">forall</span> <span class="variable-name">V2 V2'</span>, (polyT_relT00 V2 V2') -&gt; (polyT_relT00 (consT00 V1 V2)  (consT00 V1 V2')).
    <span class="proof-tactics-name">intros</span> ? ? ? v2 v12.  <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _v1 =&gt; v2 ( v12 _v1 ) ). <span class="keyword">Defined</span>.
  <span class="comment-delimiter">(*</span><span class="comment"> (consT01In U v2) is    outgetting (consT01 v2),   ALT innerly/contextually in the contextU,  is action of (consT01 v2) </span><span class="comment-delimiter">*)</span>
  <span class="keyword">Definition</span> <span class="function-name">consT01In</span> : <span class="type">forall</span> <span class="variable-name">U</span> : obT, <span class="type">forall</span> <span class="variable-name">V1</span> : obT, <span class="type">forall</span> <span class="variable-name">V2 V2'</span>, (polyT_relT00 V2 V2') -&gt;
                                                          (polyT_relT00 U (consT00 V1 V2)) -&gt;  (polyT_relT00 U  (consT00 V1 V2'))  .
    <span class="proof-tactics-name">intros</span> ? ? ? ? v2.
    <span class="proof-tactics-name">intros</span> u'v1'v2. <span class="coq-solve-tactics">exact</span> ( (consT01 v2) &lt;&lt;o u'v1'v2 ) || <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> __u =&gt;  consT01 v2 (u'v1'v2 __u) ). <span class="keyword">Defined</span>.
  <span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">U</span> : obT =&gt;  <span class="type">fun</span> <span class="variable-name">V1</span> : obT =&gt; <span class="type">fun</span> <span class="variable-name">V2 V2'</span> =&gt; <span class="type">fun</span> <span class="variable-name">v2</span> : (polyT_relT00 V2 V2') =&gt;
                                                 <span class="type">fun</span> <span class="variable-name">u'v1'v2</span> : (polyT_relT00 U (consT00 V1 V2)) =&gt; <span class="type">fun</span> __u =&gt;
                                                                                                  <span class="type">fun</span> _v1 =&gt; eq_refl :  ( (consT01In v2 u'v1'v2 __u) _v1 = (v2 &lt;&lt;o (u'v1'v2 __u)) _v1 ) ) .
  <span class="keyword">Definition</span> <span class="function-name">consT10</span> : <span class="type">forall</span> <span class="variable-name">V1' V1</span>, (polyT_relT00 V1' V1) -&gt; <span class="type">forall</span> {<span class="variable-name">V2</span> : obT}, (polyT_relT00 (consT00 V1 V2) (consT00 V1' V2)).
    <span class="proof-tactics-name">intros</span> ? ? v1 ? v12 .  <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _v1' =&gt; v12 (v1 _v1') ). <span class="keyword">Defined</span>.
  <span class="keyword">Definition</span> <span class="function-name">consT10In</span> : <span class="type">forall</span> <span class="variable-name">U</span> : obT, <span class="type">forall</span> <span class="variable-name">V1' V1</span>, (polyT_relT00 V1' V1) -&gt; <span class="type">forall</span> <span class="variable-name">V2</span> : obT, (polyT_relT00 U (consT00 V1 V2)) -&gt;  (polyT_relT00 U (consT00 V1' V2) ) .
    <span class="proof-tactics-name">intros</span> ? ? ? v1 ? .
    <span class="proof-tactics-name">intros</span> u'v1'v2. <span class="coq-solve-tactics">exact</span> ( (consT10 v1) &lt;&lt;o u'v1'v2  ) || <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> __u =&gt; consT10 v1 (u'v1'v2 __u) ) . <span class="keyword">Defined</span>.
  <span class="keyword">Check</span> ( <span class="type">fun</span> <span class="variable-name">U</span> : obT =&gt; <span class="type">fun</span> <span class="variable-name">V1' V1</span> =&gt; <span class="type">fun</span> <span class="variable-name">v1</span> : (polyT_relT00 V1' V1) =&gt; <span class="type">fun</span> <span class="variable-name">V2</span> : obT =&gt;
                                                                  <span class="type">fun</span> <span class="variable-name">u'v1'v2</span> : (polyT_relT00 U (consT00 V1 V2)) =&gt; <span class="type">fun</span> __u =&gt;
                                                                                                                   <span class="type">fun</span> _v1' =&gt; eq_refl : ( (consT10In v1 u'v1'v2 __u) _v1'  = (v1 o&gt;&gt; (u'v1'v2 __u)) _v1' ) ) .
  <span class="keyword">Definition</span> <span class="function-name">desT00</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obT, <span class="type">forall</span> <span class="variable-name">V1</span> : obT, obT.
    <span class="proof-tactics-name">intros</span> ? ? . <span class="coq-solve-tactics">exact</span> (prod V1 V2). <span class="keyword">Defined</span>.
  <span class="keyword">Definition</span> <span class="function-name">desT10</span> : <span class="type">forall</span> <span class="variable-name">V2</span> : obT, <span class="type">forall</span> <span class="variable-name">V1 V1'</span>, (polyT_relT00 V1 V1') -&gt; (polyT_relT00 (desT00 V2 V1) (desT00 V2 V1')).
    <span class="proof-tactics-name">intros</span> ? ? ? v (_v1, _v2). <span class="coq-solve-tactics">exact</span> (v _v1, _v2). <span class="keyword">Defined</span>.
  <span class="keyword">Definition</span> <span class="function-name">ConsT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), (polyT_relT00 (desT00 V U) W) -&gt; (polyT_relT00 U (consT00 V W)).
    <span class="proof-tactics-name">intros</span> ? ? ? uv'w. <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _u =&gt; <span class="type">fun</span> _v =&gt; uv'w (_u, _v) ). <span class="keyword">Defined</span>. 
  <span class="keyword">Definition</span> <span class="function-name">DesT</span>: <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), (polyT_relT00 U (consT00 V W)) -&gt; (polyT_relT00 (desT00 V U) W) .
    <span class="proof-tactics-name">intros</span> ? ? ? u'v'w. <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> _u_v =&gt; <span class="type">let</span> (_u, _v) := _u_v <span class="type">in</span> u'v'w _u _v ). <span class="keyword">Defined</span>.

  <span class="keyword">Definition</span> <span class="function-name">IdenObT</span> : obT.
    <span class="coq-solve-tactics">exact</span> unit. <span class="keyword">Defined</span>.
  <span class="keyword">Definition</span> <span class="function-name">unitT</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obT}, (polyT_relT00 IdenObT (consT00 A A) ).
    <span class="proof-tactics-name">intros</span> ? ?. <span class="coq-solve-tactics">exact</span> (<span class="type">fun</span> <span class="variable-name">a</span> =&gt; a). <span class="keyword">Defined</span>.

  <span class="keyword">Definition</span> <span class="function-name">AssocT</span> : <span class="type">forall</span> {<span class="variable-name">V W</span> :obT }, <span class="type">forall</span> {<span class="variable-name">U</span>: obT }, T(0 (desT00 (desT00 W V )  U ) |- (desT00 W ( (desT00 V  U))  ) )0.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intro</span>. <span class="proof-tactics-name">destruct</span> X. <span class="proof-tactics-name">destruct</span> d. <span class="coq-solve-tactics">exact</span> ((u,v ),w).
  <span class="keyword">Defined</span>.

  <span class="keyword">Definition</span> <span class="function-name">unitT_relT</span> : <span class="type">forall</span> {<span class="variable-name">A</span> : obT}, (polyT_relT00 IdenObT (polyT_relT00 A A) ) .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intro</span>. <span class="proof-tactics-name">eapply</span> IdenT.
  <span class="keyword">Defined</span>.
  <span class="keyword">Print</span> Grammar <span class="proof-tactics-name">pattern</span>.
  <span class="keyword">Notation</span>  <span class="string">"(0T V1 &amp; V2 )0"</span> := (desT00 V2 V1) (<span class="type">at</span> level 30, format <span class="string">"(0T  V1  &amp;  V2  )0"</span>).
  <span class="keyword">Notation</span>  <span class="string">"(1T v &amp; V2 )0"</span> := (<span class="constant">@</span>desT10 V2 _ _ v) (<span class="type">at</span> level 30, format <span class="string">"(1T  v  &amp;  V2  )0"</span>).
  <span class="keyword">Notation</span> <span class="string">"[0T V1 ~&gt; V2 ]0"</span> := (consT00 V1 V2) (<span class="type">at</span> level 30, format <span class="string">"[0T  V1  ~&gt;  V2  ]0"</span>).
  <span class="keyword">Notation</span> <span class="string">"[0T V1 ~&gt; v ]1"</span> := (<span class="constant">@</span>consT01 V1 _ _ v) (<span class="type">at</span> level 30, format <span class="string">"[0T  V1  ~&gt;  v  ]1"</span>).
  <span class="keyword">Notation</span> <span class="string">"[1T v ~&gt; V2 ]0"</span> := (<span class="constant">@</span>consT10 _ _ v V2) (<span class="type">at</span> level 30, format <span class="string">"[1T  v  ~&gt;  V2  ]0"</span>).
  <span class="keyword">Notation</span>  <span class="string">"'IT'"</span> := (IdenObT) (<span class="type">at</span> level 0).
  <span class="keyword">Notation</span> <span class="string">"'uT'"</span> := (<span class="constant">@</span>unitT _) (<span class="type">at</span> level 0).

  <span class="doc">(**  for T, class properties of data **)</span>
  <span class="keyword">Axiom</span>  <span class="variable-name">functional_extensionality_T</span> : <span class="type">forall</span> {<span class="variable-name">A B</span> : obT}, <span class="type">forall</span> (<span class="variable-name">f g</span> : T(0 A |- B )0),  (<span class="type">forall</span> <span class="variable-name">x</span>, f x = g x) -&gt; f = g.

  <span class="keyword">Lemma</span> <span class="function-name">ReflT</span> : <span class="type">forall</span> A1 A2 (<span class="variable-name">f</span> : T(0 A1 |- A2 )0), f ~~T f.
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">SymT</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>,  <span class="type">forall</span> (<span class="variable-name">f' f</span> : T(0 A1 |- A2)0), f ~~T f' -&gt; f' ~~T f.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">symmetry</span>. <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">TransT</span> : <span class="type">forall</span> <span class="variable-name">A1 A2</span>, <span class="type">forall</span> (<span class="variable-name">uTrans f</span> : T(0 A1 |- A2)0), uTrans ~~T f -&gt; <span class="type">forall</span> (<span class="variable-name">f'</span> : T(0 A1 |- A2)0), f' ~~T uTrans -&gt; f' ~~T f.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> eq_trans; <span class="coq-solve-tactics">eassumption</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">Cong_polyT_relT</span> :   <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obT) (<span class="variable-name">f f'</span> : T(0 V |- T(0 B |- A )0 )0),
                              (<span class="type">forall</span> _v : V, f' _v ~~T f _v) -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obT,  <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~T a2 -&gt; <span class="type">forall</span> _v, T(1 f' |- X )0 a1 _v ~~T T(1 f |- X )0 a2 _v .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">compute</span>. <span class="proof-tactics-name">rewrite</span> H, H0. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">CongDesT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">f f'</span> : T(0 U |- [0T V ~&gt; W ]0 )0),
                     f' ~~T f -&gt; DesT f' ~~T DesT f .
    <span class="proof-tactics-name">intros</span> ? ? ? ? ? H .
    <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">rewrite</span> H. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">Des_ConsT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">f</span> : T(0 (0T U &amp; V )0 |-  W )0),
                      DesT (ConsT f) ~~T f .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> functional_extensionality_T. <span class="proof-tactics-name">intros</span> [ ]. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">Des_OutputT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT , <span class="type">forall</span> (<span class="variable-name">U W</span> : obT ), <span class="type">forall</span> (<span class="variable-name">v</span> : T(0 U |- T(0 V |- W )0 )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : T(0 W |- W' )0),
                        DesT( [0T V ~&gt; w ]1 &lt;&lt;o v ) ~~T w &lt;&lt;o DesT( v ) .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> functional_extensionality_T. <span class="proof-tactics-name">intros</span> [ ]. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="comment-delimiter">(*</span><span class="comment"> this is some form of functional extensionality </span><span class="comment-delimiter">*)</span>
  <span class="keyword">Lemma</span> <span class="function-name">CongConsT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">v v'</span> : T(0 (0T U &amp; V )0 |- W )0 ),
                      v' ~~T v -&gt; ConsT v' ~~T ConsT v .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">compute</span>. <span class="proof-tactics-name">rewrite</span> H. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.
  <span class="keyword">Lemma</span> <span class="function-name">Cons_DesT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U W</span> : obT), <span class="type">forall</span> (<span class="variable-name">f</span> : T(0 U |-  [0T V ~&gt; W ]0 )0),
                      ConsT (DesT f) ~~T f .
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">Cons_InputT</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obT, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obT) (<span class="variable-name">w</span> : T(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obT) (<span class="variable-name">v</span> : T(0 (0T U &amp; V )0 |- W )0),
                        ConsT(v &lt;&lt;o (1T w &amp; V )0 )  ~~T ConsT( v ) &lt;&lt;o w .
    <span class="proof-tactics-name">intros</span>.  <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">Assoc_RevT</span> : <span class="type">forall</span>{<span class="variable-name">V W U</span> : obT},
                       T(0 (0T (0T U &amp; V )0 &amp; W )0 |- (0T U &amp; (0T V &amp; W )0 )0 )0 .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intros</span> [[u' v'] w']. <span class="coq-solve-tactics">exact</span> (u', (v', w')).
  <span class="keyword">Defined</span>.

  <span class="keyword">Lemma</span> <span class="function-name">Assoc_Assoc_RevT</span> : <span class="type">forall</span>(<span class="variable-name">V W U</span> : obT),
                             '1T ~~T (Assoc_RevT &lt;&lt;o (<span class="constant">@</span>AssocT V W U)) .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> functional_extensionality_T. <span class="proof-tactics-name">intros</span> [? []]. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.
  <span class="keyword">Lemma</span> <span class="function-name">Assoc_Rev_AssocT</span> : <span class="type">forall</span>(<span class="variable-name">V W U</span> : obT),
                             '1T ~~T ((<span class="constant">@</span>AssocT V W U) &lt;&lt;o Assoc_RevT) .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> functional_extensionality_T. <span class="proof-tactics-name">intros</span> [[] ?]. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Definition</span> <span class="function-name">DesInT</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obT), <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obT), T(0 U0 |- [0T U1 ~&gt; [0T V ~&gt; W ]0 ]0 )0 -&gt; T(0 U0 |- [0T (0T U1 &amp; V )0 ~&gt; W ]0 )0.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> ConsT. <span class="proof-tactics-name">eapply</span> polyT_relT_identitary. <span class="keyword">Check</span> <span class="constant">@</span>AssocT. 2: <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>AssocT _ _ _).  <span class="proof-tactics-name">eapply</span> DesT.
    <span class="proof-tactics-name">eapply</span> DesT. <span class="coq-solve-tactics">exact</span> X.
  <span class="keyword">Defined</span>.

  <span class="keyword">Definition</span> <span class="function-name">DesIdenObRT</span> : <span class="type">forall</span> {<span class="variable-name">U W</span> : obT}, T(0 U |- [0T IT ~&gt; W ]0 )0 -&gt; T(0 U  |- W )0 .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intro</span>. <span class="proof-tactics-name">apply</span> X. <span class="coq-solve-tactics">assumption</span>. <span class="coq-solve-tactics">exact</span> tt.
  <span class="keyword">Defined</span>.

  <span class="keyword">Definition</span> <span class="function-name">DesIdenObLT</span> : <span class="type">forall</span> {<span class="variable-name">V W</span> : obT}, T(0 IT |- [0T V ~&gt; W ]0 )0 -&gt; T(0 V  |- W )0 .
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intro</span>. <span class="proof-tactics-name">apply</span> X. <span class="coq-solve-tactics">exact</span> tt. <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Defined</span>.

  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_constant_rel_identitary</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obT) , <span class="type">forall</span> (<span class="variable-name">A</span> : obT) ,
                                              <span class="type">forall</span> <span class="variable-name">X</span> : obT , <span class="type">forall</span> (<span class="variable-name">a</span> : T(0 A |- X )0),  <span class="type">forall</span> (<span class="variable-name">b</span> : T(0 B |- A )0),
                                                <span class="constant">@</span>polyT_relT_constant B A b X a ~~T  a &lt;&lt;o b  . 
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B A</span> : obT) (<span class="variable-name">V V'</span> : obT) (<span class="variable-name">v</span> : T(0 V' |- V )0)
                             (<span class="variable-name">f</span> : T(0 V |- T(0 B |- A )0 )0) (<span class="variable-name">X</span> : obT),
                           <span class="type">forall</span> (<span class="variable-name">a1</span> : T(0 A |- X )0), <span class="type">forall</span> <span class="variable-name">a2</span>, a1 ~~T a2 -&gt; <span class="type">forall</span> (_v' : V'),
                                                                      (T(1 f &lt;&lt;o v |- X )0) a1 _v' ~~T
                                                                                           ([1T v ~&gt; T(0 B |- X )0 ]0 &lt;&lt;o (T(1 f |- X )0)) a2 _v'.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span> * H * . <span class="proof-tactics-name">rewrite</span> H. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_arrow_simpl</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                                  <span class="type">forall</span> (<span class="variable-name">T T'</span> : obT) (<span class="variable-name">b</span> : T' -&gt; T),
                                  <span class="type">forall</span> (<span class="variable-name">f</span> : T -&gt; T(0 B |- A )0 ) (<span class="variable-name">X</span> : obT),
                                  <span class="type">forall</span> (<span class="variable-name">a</span> : T(0 A |- X )0), <span class="type">forall</span> (<span class="variable-name">ttt</span>: T'),
                                    T(1 (<span class="type">fun</span> <span class="variable-name">v'</span> =&gt; f (b v')) |- X )0 a ttt
                                     ~~T T(1 f |- X )0 a (b ttt) .
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span>  <span class="function-name">polyT_relT_morphism</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obT) (<span class="variable-name">W</span> : obT) (<span class="variable-name">A'</span> : obT)
                                 (<span class="variable-name">g</span> : T(0 W |- T(0 A |- A' )0 )0)
                                 (<span class="variable-name">f</span> : T(0 V |- T(0 B |- idT A )0 )0) (<span class="variable-name">X</span> : obT), <span class="type">forall</span> (<span class="variable-name">a'</span> : T(0 idT A' |- X )0) (_w_v : (0T W &amp; V )0),
                                 T(1 DesT([1T f ~&gt; T(0 B |- idT A' )0 ]0 &lt;&lt;o (T(1 '1T |- A' )0) &lt;&lt;o g) |- X )0 a' _w_v
                                  ~~T DesInT ([0T W ~&gt; T(1 f |- X )0 ]1 &lt;&lt;o (T(1 g |- X )0)) a' _w_v.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">destruct</span> _w_v. <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.
  
  <span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_morphism_simpl</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obT), 
                                     <span class="type">forall</span> (<span class="variable-name">A</span> : obT) (<span class="variable-name">A'</span> : obT) (<span class="variable-name">g</span> : T(0 A |- A')0),
                                     <span class="type">forall</span> (<span class="variable-name">X</span> : obT), <span class="type">forall</span> (<span class="variable-name">pull</span> : T(0 B |- A)0), <span class="type">forall</span> (<span class="variable-name">push</span> : T(0 A'  |- X )0 ),
                                       T(1I T(0 A' |- g )1 pull |- X )0 push
                                        ~~T  T(0 X |- T(1I g |- X )0 push )1 pull .
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_unitT</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obT, <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~T a2 -&gt;
                                                 <span class="constant">@</span>IdenT _ a1 ~~T DesIdenObRT (T(1 <span class="constant">@</span>unitT_relT A |- X )0) a2.
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_unitT_simpl</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obT), <span class="type">forall</span> <span class="variable-name">X</span> : obT, <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~T a2 -&gt; ( <span class="constant">@</span>idT (T(0 A |- X )0)  ) a1 ~~T ( T(1I (<span class="constant">@</span>IdenT A) |- X )0 ) a2 .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>.  <span class="proof-tactics-name">intros</span>. <span class="coq-solve-tactics">assumption</span>.
  <span class="keyword">Qed</span>.

  <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyT is injective **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_inputUnitT</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obT) (<span class="variable-name">f</span> : T(0 V |- T(0 B |- A )0 )0), <span class="type">forall</span> _v,
                                  f _v ~~T DesIdenObLT( T(1 f |- A )0 &lt;&lt;o  unitT_relT) _v.
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.
  
  <span class="keyword">Lemma</span> <span class="function-name">polyT_relT_inputUnitT_simpl</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obT), <span class="type">forall</span> (<span class="variable-name">A</span> : obT),
                                      <span class="type">forall</span> (<span class="variable-name">b</span> : T(0 B |- A )0),
                                        b  ~~T ( (T(1I b |- A )0)  (<span class="constant">@</span>IdenT A) ) .
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.
<span class="keyword">End</span> <span class="function-name">METALOGIC</span>.

<span class="keyword">Import</span> METALOGIC.

<span class="keyword">Module</span> <span class="function-name">LOGIC</span>.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.

  <span class="doc">(**  put any `arrows :^) logic'  V   ...  this says that rewrite polyV_relT more generally as if enriched in T  then get old instance... therefore must rewrite polyV_relT_polymorphism more generally then get old instance  **)</span>

  <span class="keyword">Record</span> <span class="function-name">data</span> :=
    Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
        <span class="variable-name">obV</span> : <span class="type">Type</span>;
        polyV_relT00 : obV -&gt; obV -&gt; obT;
        convV : <span class="type">forall</span> <span class="variable-name">V1 V2</span>, polyV_relT00 V1 V2 -&gt; polyV_relT00 V1 V2 -&gt; <span class="type">Prop</span>;
        polyV_relT : <span class="type">forall</span> (<span class="variable-name">T</span> : obT), <span class="type">forall</span> <span class="variable-name">B</span> : obV,  <span class="type">forall</span> (<span class="variable-name">A</span> : obV),
                       T(0 T |- (polyV_relT00 B A) )0 -&gt;
                       <span class="type">forall</span> (<span class="variable-name">X</span> : obV), T(0 (polyV_relT00 A X) |-  T(0 T |- (polyV_relT00 B X) )0 )0;
        IdenV : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, (polyV_relT00 V V);

        consV00 : obV -&gt; obV -&gt; obV;
        consV01 : <span class="type">forall</span> <span class="variable-name">V1</span> : obV, <span class="type">forall</span> {V2 V2'}, (polyV_relT00 V2 V2') -&gt; (polyV_relT00 (consV00 V1 V2)  (consV00 V1 V2'));
        consV10 : <span class="type">forall</span> {V1' V1}, (polyV_relT00 V1' V1) -&gt; <span class="type">forall</span> <span class="variable-name">V2</span> : obV, (polyV_relT00 (consV00 V1 V2) (consV00 V1' V2));
        desV00 : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> <span class="variable-name">V1</span> : obV, obV;
        desV10 : <span class="type">forall</span> <span class="variable-name">V2</span> : obV, <span class="type">forall</span> {V1 V1'}, (polyV_relT00 V1 V1') -&gt; (polyV_relT00 (desV00 V2 V1) (desV00 V2 V1'));
        Cons : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, <span class="type">forall</span> {<span class="variable-name">U W</span> : obV}, (polyV_relT00 (desV00 V U) W) -&gt; (polyV_relT00 U (consV00 V W));
        Des : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, <span class="type">forall</span> {<span class="variable-name">U W</span> : obV}, (polyV_relT00 U (consV00 V W)) -&gt; (polyV_relT00 (desV00 V U) W);

        IdenObV : obV;
        unitV : <span class="type">forall</span> {<span class="variable-name">A</span> : obV}, (polyV_relT00 IdenObV (consV00 A A) );
        Assoc : <span class="type">forall</span> {<span class="variable-name">V W</span> :obV}, <span class="type">forall</span> {<span class="variable-name">U</span>: obV}, (polyV_relT00 (desV00 (desV00 W V) U )  ((desV00 W (desV00  V U ))  ) );
        DesIdenObR : <span class="type">forall</span> {<span class="variable-name">U W</span> : obV}, (polyV_relT00 U (consV00 IdenObV W) ) -&gt; (polyV_relT00 U W);
        DesIdenObL : <span class="type">forall</span> {<span class="variable-name">V</span> : obV}, <span class="type">forall</span> {<span class="variable-name">W</span> : obV}, (polyV_relT00 IdenObV (consV00 V W)) -&gt; (polyV_relT00 V W);
      }.

  Arguments Des {_} {_ _ _} _ .
  Arguments Cons {_} {_ _ _} _ .
  Arguments Assoc {_} {_ _ _}.
  Arguments DesIdenObR {_} {_ _} _ .
  Arguments DesIdenObL {_} {_ _} _ .

  <span class="keyword">Definition</span> <span class="function-name">polyV_relV00</span> := (<span class="constant">@</span>consV00) .
  
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-V(0 B |- A )0"</span> := (<span class="constant">@</span>polyV_relT00 dat B A) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(0  B  |-  A  )0"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations</span>.
  <span class="keyword">Import</span> Ex_Notations.
  <span class="keyword">Notation</span> <span class="string">"V(0 B |- A )0"</span> := (_ .-V(0 B |- A )0) (<span class="type">at</span> level 35).

  <span class="doc">(** remember these polyV_relT_constant and polyV_relT_identitary forms are non-general and are particular for _relT, because no unit-picking mentionned **)</span>
  <span class="keyword">Definition</span> <span class="function-name">polyV_relT_constant</span> {<span class="variable-name">log</span>: data} : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                                 V(0 B |- A )0 -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV log, T(0 V(0 A |- X )0  |- V(0 B |- X )0 )0
    := (<span class="type">fun</span> (<span class="variable-name">B A</span> : obV log) (<span class="variable-name">f</span> : V(0 B |- A )0) (<span class="variable-name">X</span> : obV log) (<span class="variable-name">g</span> : V(0 A |- X )0) =&gt;
          polyV_relT (cstT f) g tt) .
  <span class="comment-delimiter">(*</span><span class="comment">    Arguments polyV_relT_constant : simpl never.</span><span class="comment-delimiter">*)</span>

  <span class="doc">(** remember these polyV_relT_constant and polyV_relT_identitary forms are non-general and are particular for _relT, because no unit-picking mentionned **)</span>
  <span class="keyword">Definition</span> <span class="function-name">polyV_relT_identitary</span> {<span class="variable-name">log</span> : data} : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                                  <span class="type">forall</span> <span class="variable-name">X</span> : obV log, T(0 V(0 A |- X )0  |- T(0 V(0 B |- A )0 |- V(0 B |- X )0 )0 )0
    :=  <span class="type">fun</span> (<span class="variable-name">B</span> : obV log) =&gt; <span class="type">fun</span> (<span class="variable-name">A</span> : obV log) =&gt;
                            <span class="type">fun</span> <span class="variable-name">X</span> : obV log =&gt;  <span class="type">fun</span> (<span class="variable-name">a</span> : V(0 A |- X )0) =&gt; <span class="type">fun</span> (<span class="variable-name">b</span> : V(0 B |- A )0) =&gt;
                                                                      <span class="constant">@</span>polyV_relT log (V(0 B |- A )0) B A (idT) X a b .
  <span class="comment-delimiter">(*</span><span class="comment">    Arguments polyV_relT_identitary : simpl never.</span><span class="comment-delimiter">*)</span>


  <span class="keyword">Definition</span> <span class="function-name">unitV_relT</span> {<span class="variable-name">log</span> : data} : <span class="type">forall</span> {<span class="variable-name">A</span> : obV log}, T(0 IT |- V(0 A |- A )0 )0.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">intro</span>. <span class="proof-tactics-name">eapply</span> IdenV.
  <span class="keyword">Defined</span>.
  
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations2</span>.
    <span class="keyword">Export</span> Ex_Notations.
    <span class="keyword">Notation</span> <span class="string">"dat .-V(1 b |- X )0"</span> := (<span class="constant">@</span>polyV_relT dat _ _ _ b X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(1  b  |-  X  )0"</span>).
    <span class="doc">(**  more precisely ( ( b 0 ) o&gt; _ )   **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-V(1I b |- X )0"</span> := (<span class="constant">@</span>polyV_relT_constant dat _ _ b X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(1I  b  |-  X  )0"</span>).
    <span class="doc">(**  more precisely ( ( b 0 ) o&gt; a )  **)</span>
    <span class="comment-delimiter">(*</span><span class="comment">TODO: write this as coming from application ( b o&gt;dat&gt; ) a </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Notation</span> <span class="string">"b o&gt; dat &gt; a"</span> := (<span class="constant">@</span>polyV_relT_constant dat _ _ b _ a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity, dat <span class="type">at</span> next level, format <span class="string">"b  o&gt; dat &gt;  a"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-V(0 X |- - )1"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ X) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(0  X  |-  -  )1"</span>).
    <span class="doc">(**  more precisely ( ( id _ ) o&gt; a )  **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-V(0 X |- a )1"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ X a) (<span class="type">at</span> level 35, format <span class="string">"dat .-V(0  X  |-  a  )1"</span>).
    <span class="doc">(**  more precisely ( ( id b ) o&gt; a )  **)</span>
    <span class="comment-delimiter">(*</span><span class="comment">TODO: write this as coming from application ( a &lt;&lt;o ) a </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Notation</span> <span class="string">"a &lt; dat &lt;o b"</span> := (<span class="constant">@</span>polyV_relT_identitary dat _ _ _ a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity, dat <span class="type">at</span> next level, format <span class="string">"a  &lt; dat &lt;o  b"</span>).

    <span class="keyword">Notation</span> <span class="string">"v2 ~~ dat ` v1"</span> := (<span class="constant">@</span>convV dat _ _ v2 v1)  (<span class="type">at</span> level 70, dat <span class="type">at</span> next level, format <span class="string">"v2  ~~ dat `  v1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-1"</span> := (<span class="constant">@</span>IdenV dat _) (<span class="type">at</span> level 0, format <span class="string">"dat .-1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-[0 V1 ~&gt; V2 ]0"</span> := (<span class="constant">@</span>consV00 dat V1 V2) (<span class="type">at</span> level 30, format <span class="string">"dat .-[0  V1  ~&gt;  V2  ]0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-[0 V1 ~&gt; v ]1"</span> := (<span class="constant">@</span>consV01 dat V1 _ _ v) (<span class="type">at</span> level 30, format <span class="string">"dat .-[0  V1  ~&gt;  v  ]1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-[1 v ~&gt; V2 ]0"</span> := (<span class="constant">@</span>consV10 dat _ _ v V2) (<span class="type">at</span> level 30, format <span class="string">"dat .-[1  v  ~&gt;  V2  ]0"</span>).
    <span class="keyword">Notation</span>  <span class="string">"dat .-(0 V1 &amp; V2 )0"</span> := (<span class="constant">@</span>desV00 dat V2 V1) (<span class="type">at</span> level 30, format <span class="string">"dat .-(0  V1  &amp;  V2  )0"</span>).
    <span class="keyword">Notation</span>  <span class="string">"dat .-(1 v &amp; V2 )0"</span> := (<span class="constant">@</span>desV10 dat V2 _ _ v) (<span class="type">at</span> level 30, format <span class="string">"dat .-(1  v  &amp;  V2  )0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-V[0 V1 ~&gt; V2 ]0"</span> := (<span class="constant">@</span>polyV_relV00 dat V1 V2) (<span class="type">at</span> level 25, only parsing).
    <span class="keyword">Notation</span>  <span class="string">"dat .-I"</span> := (<span class="constant">@</span>IdenObV dat ) (<span class="type">at</span> level 0, format <span class="string">"dat .-I"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-uV"</span> := (<span class="constant">@</span>unitV dat _) (<span class="type">at</span> level 0, format <span class="string">"dat .-uV"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations2</span>.
  <span class="keyword">Import</span> Ex_Notations2.
  <span class="keyword">Notation</span> <span class="string">"V(1 b |- X )0"</span> := (_ .-V(1 b |- X )0) (<span class="type">at</span> level 35, format <span class="string">"V(1  b  |-  X  )0"</span>).
  <span class="keyword">Notation</span> <span class="string">"V(1I b |- X )0"</span> := (_ .-V(1I b |- X )0) (<span class="type">at</span> level 35, format <span class="string">"V(1I  b  |-  X  )0"</span>).
  <span class="comment-delimiter">(*</span><span class="comment">TODO: write this as coming from application ( b o&gt; ) a </span><span class="comment-delimiter">*)</span>
  <span class="keyword">Notation</span> <span class="string">"b o&gt; a"</span> := (b o&gt; _ &gt; a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Notation</span> <span class="string">"V(0 X |- - )1"</span> := (_ .-V(0 X |- - )1) (<span class="type">at</span> level 35, format <span class="string">"V(0  X  |-  -  )1"</span>).
  <span class="keyword">Notation</span> <span class="string">"V(0 X |- a )1"</span> := (_ .-V(0 X |- a )1) (<span class="type">at</span> level 35, format <span class="string">"V(0  X  |-  a  )1"</span>).
  <span class="comment-delimiter">(*</span><span class="comment">TODO: write this as coming from application ( a &lt;o ) b </span><span class="comment-delimiter">*)</span>
  <span class="keyword">Notation</span> <span class="string">"a &lt;o b"</span> := (a &lt; _ &lt;o b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Notation</span> <span class="string">"v2 ~~ v1"</span> := (<span class="constant">@</span>convV _ _ _ v2 v1)  (<span class="type">at</span> level 70).
  <span class="keyword">Notation</span> <span class="string">"1"</span> := (_ .-1) (<span class="type">at</span> level 0).
  <span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; V2 ]0"</span> := (_ .-[0 V1 ~&gt; V2 ]0) (<span class="type">at</span> level 30, format <span class="string">"[0  V1  ~&gt;  V2  ]0"</span>).
  <span class="keyword">Notation</span> <span class="string">"[0 V1 ~&gt; v ]1"</span> := (_ .-[0 V1 ~&gt; v ]1) (<span class="type">at</span> level 30, format <span class="string">"[0  V1  ~&gt;  v  ]1"</span> ).
  <span class="keyword">Notation</span> <span class="string">"[1 v ~&gt; V2 ]0"</span> := (_ .-[1 v ~&gt; V2 ]0) (<span class="type">at</span> level 30, format <span class="string">"[1  v  ~&gt;  V2  ]0"</span>).
  <span class="keyword">Notation</span>  <span class="string">"(0 V1 &amp; V2 )0"</span> := (_ .-(0 V1 &amp; V2 )0) (<span class="type">at</span> level 30, format <span class="string">"(0  V1  &amp;  V2  )0"</span>).
  <span class="keyword">Notation</span>  <span class="string">"(1 v &amp; V2 )0"</span> := (_ .-(1 v &amp; V2 )0) (<span class="type">at</span> level 30, format <span class="string">"(1  v  &amp;  V2  )0"</span>).
  <span class="keyword">Notation</span> <span class="string">"V[0 V1 ~&gt; V2 ]0"</span> := (_ .-V[0 V1 ~&gt; V2 ]0) (<span class="type">at</span> level 25, only parsing).
  <span class="keyword">Notation</span>  <span class="string">"'I'"</span> := (_ .-I) (<span class="type">at</span> level 0).
  <span class="keyword">Notation</span> <span class="string">"'uV'"</span> := (_ .-uV) (<span class="type">at</span> level 0).

  <span class="doc">(** Class not critical, only for easy proofs without doing (class_of _) **)</span>
  <span class="keyword">Class</span> <span class="function-name">class</span> {<span class="variable-name">dat</span> : data} :=
    <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
        <span class="variable-name">ReflV</span> : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV dat) (<span class="variable-name">f</span> : V(0 A1 |- A2 )0), f ~~ f;
        TransV : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV dat) , <span class="type">forall</span> (<span class="variable-name">uTrans f</span> : V(0 A1 |- A2)0), uTrans ~~ f -&gt; <span class="type">forall</span> (<span class="variable-name">f'</span> : V(0 A1 |- A2)0), f' ~~ uTrans -&gt; f' ~~ f;
        SymV : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV dat),  <span class="type">forall</span> (<span class="variable-name">f' f</span> : V(0 A1 |- A2)0), f ~~ f' -&gt; f' ~~ f;
        Cong_polyV_relT :   <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obV dat) (<span class="variable-name">f f'</span> : T(0 V |- V(0 B |- A )0 )0),
                              (<span class="type">forall</span> _v : V, f' _v ~~ f _v) -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV dat,  <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt; <span class="type">forall</span> _v, V(1 f' |- X )0 a1 _v ~~ V(1 f |- X )0 a2 _v;
        <span class="doc">(** remember that polyV_relT_arrow , relate in particular the polyV_relT_constant to polyV_relT_identitary **)</span>
        polyV_relT_arrow : <span class="type">forall</span> (<span class="variable-name">B A</span> : obV dat) (<span class="variable-name">V V'</span> : obT) (<span class="variable-name">v</span> : T(0 V' |- V )0)
                             (<span class="variable-name">f</span> : T(0 V |- dat.-V(0 B |- A )0 )0) (<span class="variable-name">X</span> : obV dat),
                           <span class="type">forall</span> (<span class="variable-name">a</span> : dat.-V(0 A |- X )0) a0, a ~~ a0 -&gt;  <span class="type">forall</span> (_v': V'),
                                                                      (dat.-V(1 f &lt;&lt;o v |- X )0) a _v' ~~
                                                                                                ([1T v ~&gt; dat.-V(0 B |- X )0 ]0 &lt;&lt;o (dat.-V(1 f |- X )0)) a0 _v';
        <span class="doc">(** written here :   (outer modification) ~~ (inner modification) **)</span>
        polyV_relT_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obV dat) (<span class="variable-name">W</span> : obT) (<span class="variable-name">A'</span> : obV dat)
                                (<span class="variable-name">g</span> : T(0 W |- dat.-V(0 A |- A' )0 )0)
                                (<span class="variable-name">f</span> : T(0 V |- dat.-V(0 B |- idT A )0 )0) (<span class="variable-name">X</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">a'</span> : V(0 idT A' |- X )0) (_w_v : (0T W &amp; V )0),
                                dat.-V(1 DesT ([1T f ~&gt; dat.-V(0 B |- idT A' )0 ]0 &lt;&lt;o (dat.-V(1 '1T |- A' )0) &lt;&lt;o g) |- X )0 a' _w_v
                                   ~~ DesInT ([0T W ~&gt; dat.-V(1 f |- X )0 ]1 &lt;&lt;o (dat.-V(1 g |- X )0)) a' _w_v;
        <span class="doc">(** related to non-variance when unit pull the input, commonly  ( 1 o&gt; h ) ~~ h  **)</span>
        polyV_relT_unitV : <span class="type">forall</span> <span class="variable-name">A X</span> : obV dat, <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt;
                                                     <span class="constant">@</span>IdenT _ a1 ~~ DesIdenObRT (dat.-V(1 <span class="constant">@</span>unitV_relT _ A |- X )0) a2;
        <span class="doc">(** related to non-variance when unit push the output, commonly  ( (f _i) o&gt; 1 ) ~~ (f _i)  , 
       therefore polyV is injective **)</span>
        polyV_relT_inputUnitV : <span class="type">forall</span> (<span class="variable-name">V</span> : obT) (<span class="variable-name">B A</span> : obV dat) (<span class="variable-name">f</span> : T(0 V |- V(0 B |- A )0 )0), <span class="type">forall</span> _v,
                                  f _v ~~ DesIdenObLT( V(1 f |- A )0 &lt;&lt;o  unitV_relT) _v;
        CongDes : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 U |- [0 V ~&gt; W ]0 )0),
                    f' ~~ f -&gt; Des f' ~~ Des f ;
        Des_Cons : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 (0 U &amp; V )0 |-  W )0),
                     Des (Cons f) ~~ f ;
        Des_Output : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                       Des( [0 V ~&gt; w ]1 &lt;o v ) ~~ w &lt;o Des( v ) ;
        CongCons : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 (0 U &amp; V )0 |- W )0 ),
                     v' ~~ v -&gt; Cons v' ~~ Cons v ;
        Cons_Des : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV dat), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U |-  [0 V ~&gt; W ]0 )0),
                     Cons (Des f) ~~ f ;
        Cons_Input : <span class="type">forall</span> <span class="variable-name">V</span> : obV dat, <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV dat) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV dat) (<span class="variable-name">v</span> : V(0 (0 U &amp; V )0 |- W )0),
                       Cons(v &lt;o (1 w &amp; V )0 )  ~~ Cons( v ) &lt;o w ;
        Assoc_Rev : <span class="type">forall</span>{<span class="variable-name">V W U</span> : obV dat},
                      V(0 (0(0U &amp; V )0 &amp; W )0 |- (0U &amp; (0V &amp; W )0 )0 )0;
        Assoc_Assoc_Rev : <span class="type">forall</span>(<span class="variable-name">V W U</span> : obV dat),
                            1 ~~ (Assoc_Rev &lt;o (<span class="constant">@</span>Assoc dat V W U));
        Assoc_Rev_Assoc : <span class="type">forall</span>(<span class="variable-name">V W U</span> : obV dat),
                            1 ~~ ((<span class="constant">@</span>Assoc dat V W U) &lt;o Assoc_Rev);
      }.

  Arguments ReflV {_ _} _ _ _ .
  Arguments TransV {_ _} _ _ _ _ _ _ _ .
  Arguments SymV {_ _} _ _ _ _ _ .
  Arguments Cong_polyV_relT {_ _} [_ _ _ _ _ _ _ _]  _ _ _ .
  Arguments polyV_relT_arrow {_ _} {_ _ _ _} _ _ {_ _ _} _ _ .
  Arguments polyV_relT_morphism {_ _} {_ _ _ _ _} _ _ {_} _ _ .
  Arguments polyV_relT_unitV {_ _} [_ _ _ _] _ .
  Arguments polyV_relT_inputUnitV {_ _} {_ _ _} _ _ .
  Arguments CongDes {_ _} [_ _ _ _ _] _ .
  Arguments Des_Cons {_ _} [_ _ _] _ .
  Arguments Des_Output {_ _} [_ _ _ _ _] _ .
  Arguments CongCons {_ _} [_ _ _] _ _ _.
  Arguments Cons_Des {_ _} [_ _ _ _] .
  Arguments Cons_Input {_ _} [_ _ _ _ _] _ .
  Arguments Assoc_Rev {_ _} {_ _ _} .

  <span class="keyword">Structure</span> <span class="function-name">logic</span> :=
    Logic <span class="company-coq-featuresXcode-folding-bullet">{</span>
        data_of :&gt; data;
        class_of :&gt; <span class="constant">@</span>class data_of
      }.

  <span class="doc">(** not critical, only for easy proofs without doing (class_of _) **)</span>
  <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.
  
  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic}.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relT_arrow_simpl</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log) (<span class="variable-name">A</span> : obV log) (<span class="variable-name">V V'</span> : obT) (<span class="variable-name">v</span> : V' -&gt; V),
                                   <span class="type">forall</span> (<span class="variable-name">f</span> : V -&gt; V(0 B |- A )0 ) (<span class="variable-name">X</span> : obV log),
                                   <span class="type">forall</span> (<span class="variable-name">a</span> : V(0 A |- X )0) a0, a ~~ a0 -&gt; <span class="type">forall</span> (_v' : V'),
                                                                        V(1 f &lt;&lt;o v |- X )0 a _v'
                                                                         ~~   V(1 f |- X )0 a0 (v _v').
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> polyV_relT_arrow. <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relT_unitV_simpl</span> : <span class="type">forall</span> (<span class="variable-name">A X</span> : obV log), <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt; ( <span class="constant">@</span>idT (V(0 A |- X )0)  ) a1 ~~ ( V(1I (<span class="constant">@</span>IdenV _ A) |- X )0 ) a2.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> polyV_relT_unitV. <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relT_inputUnitV_simpl</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                        <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 B |- A )0),  b  ~~ ( (V(1I b |- A )0)  (<span class="constant">@</span>IdenV _ A) ).
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> polyV_relT_inputUnitV <span class="type">with</span> (f:=(<span class="type">fun</span> _ : unit =&gt; b)).
    <span class="keyword">Qed</span>.

    <span class="keyword">Definition</span> <span class="function-name">ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0 -&gt; V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 .
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> Cons. <span class="proof-tactics-name">apply</span> Cons. <span class="keyword">Check</span> <span class="constant">@</span>Assoc. <span class="proof-tactics-name">eapply</span> polyV_relT_identitary. <span class="proof-tactics-name">eapply</span> Des.  2:  <span class="proof-tactics-name">eapply</span> Assoc_Rev. <span class="coq-solve-tactics">exact</span> H.
    <span class="keyword">Defined</span>.

    <span class="keyword">Definition</span> <span class="function-name">polyV_relV</span> :  <span class="type">forall</span> (<span class="variable-name">U</span> : obV log), <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">V</span> : obV log),
                               V(0 U |- [0 W ~&gt; V ]0 )0 -&gt;
                               <span class="type">forall</span> <span class="variable-name">X</span> : obV log, V(0 [0 V ~&gt; X ]0  |- [0 U ~&gt; [0 W ~&gt; X ]0 ]0 )0 .
      <span class="proof-tactics-name">intros</span> ? ? ? v ?.  <span class="coq-solve-tactics">exact</span>  (ConsIn( [1 Des v ~&gt; X]0)).
    <span class="keyword">Defined</span>.

    <span class="keyword">Lemma</span> <span class="function-name">CongConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0),
                         v' ~~ v -&gt; ConsIn v' ~~ ConsIn v .
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Definition</span> <span class="function-name">DesIn</span> : <span class="type">forall</span> {<span class="variable-name">V</span> : obV log}, <span class="type">forall</span> {<span class="variable-name">U0 U1 W</span> : obV log}, V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0 -&gt; V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> Cons. <span class="proof-tactics-name">eapply</span> polyV_relT_identitary. <span class="keyword">Check</span> <span class="constant">@</span>Assoc. 2: <span class="proof-tactics-name">eapply</span> Assoc. <span class="proof-tactics-name">eapply</span> Des.
      <span class="proof-tactics-name">eapply</span> Des. <span class="coq-solve-tactics">exact</span> H.
    <span class="keyword">Defined</span>.
    
    <span class="comment-delimiter">(*</span><span class="comment"> polyV_relT_constant_rel_identitary  :  b o&gt; a ~~ a &lt;o b </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Lemma</span> <span class="function-name">polyV_relT_constant_rel_identitary</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV log) , <span class="type">forall</span> (<span class="variable-name">A</span> : obV log) ,
                                                <span class="type">forall</span> <span class="variable-name">X</span> : obV log , <span class="type">forall</span> (<span class="variable-name">a</span> : V(0 A |- X )0),  <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 B |- A )0),
                                                  <span class="constant">@</span>polyV_relT_constant log B A b X a  ~~  a &lt;o b .
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">unfold</span> polyV_relT_identitary. <span class="proof-tactics-name">unfold</span> polyV_relT_constant.
      <span class="proof-tactics-name">intros</span>.  <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>polyV_relT_arrow _ log) <span class="type">with</span> (f := <span class="type">fun</span> <span class="variable-name">b0</span> =&gt; b0) (v := <span class="type">fun</span> _ : unit =&gt; b). <span class="proof-tactics-name">eapply</span> ReflV.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">Cong_polyV_relT_constant</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                     <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 B |- A )0), f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV log,
                                                                        <span class="type">forall</span> <span class="variable-name">a1 a2</span>, a1 ~~ a2 -&gt; <span class="constant">@</span>polyV_relT_constant log B A f' X a1 ~~  <span class="constant">@</span>polyV_relT_constant _ B A f X a2.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span>  (<span class="constant">@</span>Cong_polyV_relT _ log)  <span class="type">with</span> (f:=<span class="type">fun</span> _ : unit =&gt; f)  (f':=<span class="type">fun</span> _ : unit =&gt; f'); <span class="proof-tactics-name">intros</span>; <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.
    Arguments Cong_polyV_relT_constant [_ _ _ _ _ _ _] _ _ .

    <span class="keyword">Lemma</span> <span class="function-name">CongCom_identitary</span> : <span class="type">forall</span> (<span class="variable-name">A2 A3</span> : obV log), <span class="type">forall</span> (<span class="variable-name">f2 f2'</span> : V(0 A2 |- A3 )0), f2 ~~ f2' -&gt; <span class="type">forall</span> <span class="variable-name">A1</span>, <span class="type">forall</span> (<span class="variable-name">f1 f1'</span> : V(0 A1 |- A2 )0), f1 ~~ f1' -&gt; f2 &lt;o f1 ~~ f2' &lt;o f1'.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_constant_rel_identitary |].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, polyV_relT_constant_rel_identitary].
      <span class="proof-tactics-name">eapply</span> Cong_polyV_relT_constant;  <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.
    
    <span class="keyword">Lemma</span> <span class="function-name">CongCom_constant</span> : <span class="type">forall</span> (<span class="variable-name">A2 A3</span> : obV log), <span class="type">forall</span> (<span class="variable-name">f2 f2'</span> : V(0 A2 |- A3 )0), f2 ~~ f2' -&gt; <span class="type">forall</span> <span class="variable-name">A1</span>, <span class="type">forall</span> (<span class="variable-name">f1 f1'</span> : V(0 A1 |- A2 )0), f1 ~~ f1' -&gt; f1 o&gt; f2 ~~ f1' o&gt; f2'.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> Cong_polyV_relT_constant;  <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relT_morphism_simpl</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obV log), 
                                      <span class="type">forall</span> (<span class="variable-name">A</span> : obV log) (<span class="variable-name">A'</span> : obV log) (<span class="variable-name">g</span> : V(0 A |- A')0),
                                      <span class="type">forall</span> (<span class="variable-name">X</span> : obV log), <span class="type">forall</span> (<span class="variable-name">pull</span> : V(0 B |- A)0), <span class="type">forall</span> (<span class="variable-name">push</span> : V(0 A'  |- X )0 ),
                                        V(1I V(0 A' |- g )1 pull |- X )0 push
                                         ~~ V(0 X |- V(1I g |- X )0 push )1 pull.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">generalize</span> (<span class="constant">@</span>polyV_relT_morphism log log). <span class="proof-tactics-name">intros</span> H_polyV_relT_morphism.
      <span class="proof-tactics-name">specialize</span> H_polyV_relT_morphism <span class="type">with</span> (V:=unit)(B:=B)(A:=A)(W:=unit)(g:=(<span class="type">fun</span> _ : unit =&gt; g))(f:=(<span class="type">fun</span> _ : unit =&gt; pull))(X:=X)(a':=push)(_w_v:=(tt,tt)).
      <span class="proof-tactics-name">unfold</span> polyV_relT_constant. <span class="proof-tactics-name">unfold</span> polyV_relT_identitary.
      <span class="proof-tactics-name">unfold</span> DesInT, DesT, ConsT, AssocT, polyT_relT_identitary, polyT_relT, consT10, consT01, idT, cstT <span class="type">in</span> H_polyV_relT_morphism.
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_polyV_relT_morphism; [|<span class="proof-tactics-name">eapply</span> polyV_relT_arrow <span class="type">with</span> (f := idT); <span class="proof-tactics-name">eapply</span> ReflV].
      <span class="proof-tactics-name">unfold</span> DesInT, DesT, ConsT, AssocT, polyT_relT_identitary, polyT_relT, consT10, consT01, idT, cstT <span class="type">in</span> H_polyV_relT_morphism.
      <span class="comment-delimiter">(*</span><span class="comment"> remember that polyV_relT_arrow , relate in particular the polyV_relT_constant to polyV_relT_identitary </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_polyV_relT_morphism; [|<span class="proof-tactics-name">eapply</span> polyV_relT_arrow <span class="type">with</span> (f:=idT); <span class="proof-tactics-name">eapply</span> ReflV].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> polyV_relT_arrow <span class="type">with</span> (v:=<span class="type">fun</span> _ : unit =&gt; (V(1 idT |- _ )0) g pull) (f:=idT); <span class="proof-tactics-name">eapply</span> ReflV].
      <span class="proof-tactics-name">unfold</span> DesInT, DesT, ConsT, AssocT, polyT_relT_identitary, polyT_relT, consT10, consT01, idT, cstT <span class="type">in</span> H_polyV_relT_morphism |- *.
      <span class="proof-tactics-name">eapply</span> H_polyV_relT_morphism.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">CongDesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                        v' ~~ v -&gt; DesIn v' ~~ DesIn v.
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Lemma</span> <span class="function-name">ConsIn_DesIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0),
                           ConsIn (DesIn f) ~~ f .
    <span class="coq-cheat">Admitted</span>.
    
    <span class="keyword">Lemma</span> <span class="function-name">DesIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 U1 ~&gt; [0 V ~&gt; W ]0 ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV log) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                          (DesIn v) &lt;o i ~~ DesIn( v &lt;o i ) .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">Des_Input</span> : <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV log) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> (<span class="variable-name">V W</span> : obV log) (<span class="variable-name">v</span> : V(0 U |- [0 V ~&gt; W ]0 )0), 
                        Des( v &lt;o w ) ~~ Des( v ) &lt;o desV10 V w .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">ConsIn_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U1 U1'</span> : obV log) (<span class="variable-name">u1</span> : V(0 U1' |- U1 )0), <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0),
                            ConsIn( [1 (1 u1 &amp; V )0 ~&gt; W ]0 &lt;o v ) ~~ [1 u1 ~&gt; [0 V ~&gt; W ]0 ]0 &lt;o ConsIn( v ) .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">CongConsV01</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV log, <span class="type">forall</span> (<span class="variable-name">V2 V2'</span> : obV log) (<span class="variable-name">v v'</span> : V(0 V2 |- V2' )0),
                          v' ~~ v -&gt; [0 V1 ~&gt; v' ]1 ~~ [0 V1 ~&gt; v ]1 .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">ConsIn_Input</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0), <span class="type">forall</span> (<span class="variable-name">U0'</span> : obV log) (<span class="variable-name">i</span> : V(0 U0' |- U0 )0),
                           ConsIn( v &lt;o i ) ~~ (ConsIn v) &lt;o i .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">consV01_functorial</span> : <span class="type">forall</span> <span class="variable-name">V1</span> : obV log, <span class="type">forall</span> V2 V2' (<span class="variable-name">v</span> : V(0 V2 |- V2' )0), <span class="type">forall</span> V2'' (<span class="variable-name">v'</span> : V(0 V2' |- V2'' )0),
                                 [0 V1 ~&gt; v' &lt;o v ]1 ~~  [0 V1 ~&gt; v' ]1 &lt;o  [0 V1  ~&gt; v ]1 .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">DesIn_ConsIn</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0 U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0),
                           DesIn (ConsIn f) ~~ f.
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">Assoc_Iso</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U</span>: obV log),
                      <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV log) (<span class="variable-name">f g</span> : V(0 Y |-  [0 (0 ((0 U &amp; V )0) &amp; W )0 ~&gt; X ]0 )0 ), 
                        [1 Assoc ~&gt; X ]0 &lt;o f ~~ [1 Assoc  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">Assoc_nat0</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U U'</span> : obV log) (<span class="variable-name">f</span> : V(0 U |- U' )0 ),
                         Assoc &lt;o (1 f &amp; (0 V &amp; W )0 )0 ~~ (1 ((1 f &amp; V )0) &amp; W )0 &lt;o Assoc .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">Des_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0) ,
                                     (Des ([1 Des (g &lt;o f) ~&gt; PA' ]0 ))
                                       ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))) ) &lt;o Assoc
                                            : V(0 (0 ([0 QA ~&gt; PA' ]0) &amp; (0V &amp; B )0 )0 |- PA' )0 ).
    <span class="coq-cheat">Admitted</span>.
    <span class="doc">(** Lemma Assoc_Des_Des_old : forall V B PA PA' (f : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                     ( (Des ([1 Des f ~&gt; PA' ]0 )) : V(0 (0 ([0 PA ~&gt; PA' ]0) &amp; (0V &amp; B )0 )0 |- PA' )0 )
                                       ~~ ( ( Des (Des ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (</span><span class="constant"><span class="doc">@</span></span><span class="doc">IdenV ([0 B ~&gt; PA ]0)) ~&gt; PA' ]0))) ) &lt;o Assoc ). **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">Assoc_DesIn_DesIn</span> :  <span class="type">forall</span> <span class="variable-name">W PX</span>, <span class="type">forall</span>  V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0),
                                 DesIn ([0 W ~&gt;  ([1 Des f ~&gt; PX ]0) ]1)
                                       ~~ [1 Assoc ~&gt; PX ]0 &lt;o DesIn( DesIn ([0 W ~&gt;  ConsIn([1 Des f ~&gt; PX ]0) ]1) ) .
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Lemma</span> <span class="function-name">Cons_Output</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> :  V(0 (0 U &amp; V )0 |-  W )0), <span class="type">forall</span> W' (<span class="variable-name">w</span> : V(0 W |- W' )0),
                          [0 V ~&gt; w ]1 &lt;o Cons( v ) ~~ Cons( w &lt;o v ) .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">ConsIn_Output2</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U0</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U1</span> : obV log) , <span class="type">forall</span> (<span class="variable-name">W W'</span> : obV log) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U0 |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0),
                             ConsIn( [0 (0 U1 &amp; V )0 ~&gt; w ]1 &lt;o v ) ~~ [0 U1 ~&gt; [0 V ~&gt; w ]1 ]1 &lt;o ConsIn( v ) .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">ConsIn_consV10_functorial</span> : <span class="type">forall</span> V B PA (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; PA ]0 )0) PA' QA (<span class="variable-name">g</span> : V(0 [0 B ~&gt; PA ]0 |- [0 B ~&gt; QA ]0 )0),
                                        ( ConsIn (([1 Des (g &lt;o f) ~&gt; PA' ]0)) )
                                          ~~ ( ([1 f ~&gt; [0 B ~&gt; PA' ]0 ]0 &lt;o ConsIn ([1 Des (g) ~&gt; PA' ]0))
                                               : V(0 [0 QA ~&gt; PA' ]0 |- [0 V ~&gt; [0 B ~&gt; PA' ]0 ]0 )0 ) .
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Lemma</span> <span class="function-name">Des_I_Iso</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                      <span class="type">forall</span> (<span class="variable-name">Y X</span> : obV log) (<span class="variable-name">f g</span> : V(0 Y |-  [0  A ~&gt; X ]0 )0 ), 
                        [1 Des (<span class="constant">@</span>IdenV _ ([0 I ~&gt; A ]0)) ~&gt; X ]0 &lt;o f ~~ [1  Des (<span class="constant">@</span>IdenV _ ([0 I ~&gt; A ]0))  ~&gt; X ]0 &lt;o g -&gt; f ~~ g .
    <span class="coq-cheat">Admitted</span>.
  <span class="keyword">End</span> <span class="function-name">Context</span>.

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations3</span>.
    <span class="keyword">Export</span> Ex_Notations2.
    <span class="keyword">Notation</span> <span class="string">"dat .-V[1 v ~&gt; X ]0"</span> := (<span class="constant">@</span>polyV_relV dat _ _ _ v X) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"dat .-V[0 X ~&gt; w ]1"</span> := ((<span class="constant">@</span>polyV_relV dat _ _ _ 1 X) &lt;dat&lt;o w) (<span class="type">at</span> level 25).
    <span class="keyword">Notation</span> <span class="string">"dat .-V[0 W ~&gt; - ]1"</span> := (<span class="type">fun</span> <span class="variable-name">V X</span> =&gt; <span class="constant">@</span>polyV_relV dat _ _ _ (<span class="constant">@</span>IdenV dat (dat.-V[0 W ~&gt; V ]0)) X) (<span class="type">at</span> level 25).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations3</span>.
  <span class="keyword">Import</span> Ex_Notations3.
  <span class="keyword">Notation</span> <span class="string">"V[1 v ~&gt; X ]0"</span> := (_ .-V[1 v ~&gt; X ]0) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"V[0 X ~&gt; w ]1"</span> := (_ .-V[0 X ~&gt; w ]1) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"V[0 W ~&gt; - ]1"</span> := (_ .-V[0 W ~&gt; - ]1) (<span class="type">at</span> level 25).

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic}.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relV_polyV_relT</span> : <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">U</span> : obV log) (<span class="variable-name">V</span> : obV log),
                                  <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 U |- [0 W ~&gt; V ]0 )0), <span class="type">forall</span> <span class="variable-name">X</span> : obV log,
                                    [1 Des v ~&gt; X]0
                                                  ~~ DesIn( V[1 v ~&gt; X ]0 ) .
    <span class="coq-cheat">Admitted</span>.

    <span class="doc">(** TODO: PUT IN DATA OR CLASS **)</span>
    <span class="keyword">Axiom</span> <span class="variable-name">CongDesIdenObR</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 U |- [0 I ~&gt; W ]0 )0),
                             v' ~~ v -&gt; DesIdenObR v' ~~ DesIdenObR v .
    <span class="keyword">Axiom</span> <span class="variable-name">DesIdenObR_output</span> : <span class="type">forall</span> (<span class="variable-name">U</span> : obV log) (<span class="variable-name">W W'</span> : obV log) (<span class="variable-name">w</span> : V(0 W |- W' )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                                DesIdenObR( [0 I ~&gt; w ]1 &lt;o v ) ~~ w &lt;o DesIdenObR( v ) .
    <span class="keyword">Axiom</span> <span class="variable-name">DesIdenObR_Input</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV log) (<span class="variable-name">U'</span> : obV log) (<span class="variable-name">w</span> : V(0 U' |- U )0), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 U |- [0 I ~&gt; W ]0 )0, 
                               DesIdenObR( v &lt;o w ) ~~ DesIdenObR( v ) &lt;o w .
    <span class="keyword">Axiom</span> <span class="variable-name">DesIdenObRInCons</span> : <span class="type">forall</span> (<span class="variable-name">U W</span> : obV log),
                               [1 DesIdenObR (Cons (<span class="constant">@</span>IdenV _ ((0 U &amp; I )0))) ~&gt; W ]0 ~~
                                                                                   ([0 U ~&gt; DesIdenObR (<span class="constant">@</span>IdenV _ ([0 I ~&gt; W ]0)) ]1 &lt;o
                                                                                                                                       ConsIn (<span class="constant">@</span>IdenV _ ([0 (0 U &amp; I )0 ~&gt; W ]0)) 
                                                                                    : V(0 [0 (0 U &amp; I )0 ~&gt; W ]0 |- [0 U ~&gt; W ]0 )0 ) .

    <span class="keyword">Axiom</span> <span class="variable-name">CongDesIdenObL</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 I |- [0 V ~&gt; W ]0 )0),
                             v' ~~ v -&gt; DesIdenObL v' ~~ DesIdenObL v .
    <span class="keyword">Parameter</span> <span class="variable-name">ConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), V(0 V |- W )0 -&gt; V(0 I |- [0 V ~&gt; W ]0 )0 .
    <span class="keyword">Axiom</span> <span class="variable-name">ConsIdenObL_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> <span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0,
                                     v ~~ ConsIdenObL( DesIdenObL v) .
    <span class="keyword">Axiom</span> <span class="variable-name">DesIdenObR_ConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> <span class="variable-name">v</span> : V(0 I |- V )0,
                                     v ~~ DesIdenObR( ConsIdenObL v) .
    <span class="keyword">Axiom</span> <span class="variable-name">Des_ConsIn</span> :  <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">U1 W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 I |- [0 (0 U1 &amp; V )0 ~&gt; W ]0 )0),
                          DesIdenObL (v) ~~ Des (DesIdenObL (ConsIn (v))).
    <span class="keyword">Axiom</span> <span class="variable-name">DesIdenObRConsIdenObL</span> : <span class="type">forall</span> (<span class="variable-name">V W</span> : obV log),
                                    (<span class="constant">@</span>IdenV log ([0 V ~&gt; W ]0)) ~~ DesIdenObR (ConsIn ([1 Des (ConsIdenObL 1) ~&gt;  W ]0)).
    <span class="keyword">Axiom</span> <span class="variable-name">CongConsIdenObL</span> : <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v v'</span> : V(0 V |- W )0),
                              v' ~~ v -&gt; ConsIdenObL v' ~~ ConsIdenObL v .
    <span class="keyword">Axiom</span> <span class="variable-name">consV10_functorial</span> : <span class="type">forall</span> (<span class="variable-name">V1' V1</span> : obV log) (<span class="variable-name">v</span> :  V(0 V1' |- V1 )0), <span class="type">forall</span> V1'' (<span class="variable-name">v'</span> : V(0 V1'' |- V1' )0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV log,
                                 [1 v &lt;o v' ~&gt; V2 ]0 ~~  [1 v' ~&gt; V2 ]0 &lt;o  [1 v ~&gt; V2 ]0 .
    <span class="keyword">Axiom</span> <span class="variable-name">consV11_bifunctorial</span> : <span class="type">forall</span> (<span class="variable-name">V1' V1</span> : obV log) (<span class="variable-name">v</span> : V(0 V1' |- V1 )0), <span class="type">forall</span> W1 W1' (<span class="variable-name">w</span> : V(0 W1 |- W1' )0),
                                   [0 V1' ~&gt; w ]1 &lt;o  [1 v ~&gt; W1 ]0 ~~ [1 v ~&gt; W1' ]0 &lt;o [0 V1 ~&gt; w ]1 .
    <span class="keyword">Axiom</span> <span class="variable-name">CongConsV10</span> : <span class="type">forall</span> (<span class="variable-name">V1' V1</span> : obV log) (<span class="variable-name">v v'</span> : V(0 V1' |- V1)0), <span class="type">forall</span> <span class="variable-name">V2</span> : obV log,
                          v' ~~ v -&gt; [1 v' ~&gt; V2 ]0 ~~ [1 v ~&gt; V2 ]0 .

    
    <span class="keyword">Axiom</span> <span class="variable-name">consV10_DesIdenObL</span> : <span class="type">forall</span> <span class="variable-name">U</span> : obV log, <span class="type">forall</span> <span class="variable-name">V</span> : obV log, <span class="type">forall</span> (<span class="variable-name">W</span> : obV log), <span class="type">forall</span> (<span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0), 
                                 [1 DesIdenObL  v ~&gt; U ]0  ~~ DesIdenObR( ConsIn( [1 Des v ~&gt; U ]0 ) ) .  <span class="comment-delimiter">(*</span><span class="comment">/!\SAME/!\</span><span class="comment-delimiter">*)</span><span class="keyword">Axiom</span> <span class="variable-name">DesIdenObR_DesIdenObL</span> : <span class="type">forall</span> ( <span class="variable-name">V W X</span> : obV log) (<span class="variable-name">v</span> : V(0 I |- [0 V ~&gt; W ]0 )0),
                                                                                                                                                        [1 DesIdenObL v ~&gt; X ]0 ~~ DesIdenObR (ConsIn ([1 Des v ~&gt; X ]0)) .

    <span class="keyword">Axiom</span> <span class="variable-name">consV10_functorial_fun1</span> : <span class="type">forall</span> <span class="variable-name">V1</span>, <span class="type">forall</span> <span class="variable-name">V2</span> : obV log,
                                      (<span class="constant">@</span>IdenV _ _) ~~    [1 (<span class="constant">@</span>IdenV _ V1) ~&gt; V2 ]0 .

    
    <span class="doc">(** remember that  unitV is not really primitive **)</span>
    <span class="keyword">Axiom</span> <span class="variable-name">unitV_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A</span> : obV log,  (<span class="constant">@</span>IdenV log A) ~~ DesIdenObL (<span class="constant">@</span>unitV log A).

    <span class="doc">(** even/same for these that the decision are recursively-decidable because still purely logical after unfolding polyV_relV **)</span> 
    <span class="keyword">Lemma</span> <span class="function-name">CongPolyV</span> : <span class="type">forall</span> (<span class="variable-name">V B A</span> : obV log) (<span class="variable-name">f f'</span> : V(0 V |- V[0 B ~&gt; A ]0 )0),
                        f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obV log, V[1 f' ~&gt; X ]0 ~~ V[1 f ~&gt; X ]0 .
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relV_arrow</span> :  <span class="type">forall</span> (<span class="variable-name">B</span> : obV log) (<span class="variable-name">A</span> : obV log) (<span class="variable-name">V</span> : obV log),
                              <span class="type">forall</span> (<span class="variable-name">V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                              <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- [0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obV log),
                                V[1 (f &lt;o v) ~&gt; X ]0
                                 ~~ [1 v ~&gt; [0 B ~&gt; X ]0 ]0 &lt;o (V[1 f ~&gt;  X ]0) .
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relV_morphism</span> :  <span class="type">forall</span> (<span class="variable-name">V B A W A'</span> : obV log) (<span class="variable-name">g</span> : V(0 W |-V[0 A ~&gt; A' ]0 )0)
                                   (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; idT A ]0 )0) (<span class="variable-name">X</span> : obV log),
                                   V[1 Des ([1 f ~&gt; [0 B ~&gt; idT A' ]0 ]0 &lt;o V[0 A' ~&gt; g ]1) ~&gt; X ]0 ~~
                                    DesIn ([0 W ~&gt; V[1 f ~&gt; X ]0 ]1 &lt;o V[1 g ~&gt; X ]0) .
    <span class="coq-cheat">Admitted</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyV_relV_unitV</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obV log), <span class="type">forall</span> <span class="variable-name">X</span> : obV log, (<span class="constant">@</span>IdenV log (V[0 A ~&gt; X ]0)) ~~ DesIdenObR( V[1 (<span class="constant">@</span>unitV log A) ~&gt; X ]0 ) .
    <span class="coq-cheat">Admitted</span>.
    <span class="keyword">Lemma</span> <span class="function-name">polyV_relV_inputUnitV</span> :<span class="type">forall</span> (<span class="variable-name">V</span> : obV log),  <span class="type">forall</span> (<span class="variable-name">B</span> : obV log),  <span class="type">forall</span> (<span class="variable-name">A</span> : obV log),
                                 <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- V[0 B ~&gt; A ]0 )0),
                                   f  ~~ DesIdenObL( (V[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitV log A) ).
    <span class="coq-cheat">Admitted</span>.


    <span class="doc">(**  Section: common categories *)</span>

    <span class="keyword">Definition</span> <span class="function-name">ComV</span> : <span class="type">forall</span> (<span class="variable-name">V1</span> : obV log), <span class="type">forall</span> <span class="variable-name">UCom</span>, V(0 V1 |-  UCom )0 -&gt; <span class="type">forall</span> <span class="variable-name">V3</span>, V(0 UCom |- V3 )0 -&gt; V(0 V1 |- V3 )0 := polyV_relT_constant .

    <span class="keyword">Definition</span> <span class="function-name">CongCom</span> := (<span class="constant">@</span>CongCom_identitary).

    <span class="keyword">Lemma</span> <span class="function-name">Cat2V</span> : <span class="type">forall</span> (<span class="variable-name">A3 A4</span> : obV log) (<span class="variable-name">f3</span> : V(0 A3 |- A4)0), <span class="type">forall</span> A2 (<span class="variable-name">f2</span> : V(0 A2 |- A3)0), <span class="type">forall</span> A1 (<span class="variable-name">f1</span> : V(0 A1 |- A2)0),
                    (f3 &lt;o f2) &lt;o f1 ~~ f3 &lt;o (f2 &lt;o f1).
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_constant_rel_identitary  |].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, polyV_relT_constant_rel_identitary  ].
      <span class="proof-tactics-name">apply</span> SymV, polyV_relT_morphism_simpl.
      <span class="comment-delimiter">(*</span><span class="comment"> OLD DEFINITIONALLY intros. apply SymV, polyV_relT_morphism. </span><span class="comment-delimiter">*)</span> 
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">Cat1RightV</span> : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV log), <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ f &lt;o 1.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_constant_rel_identitary |].
      <span class="proof-tactics-name">apply</span> polyV_relT_unitV.
      <span class="proof-tactics-name">apply</span> ReflV.
    <span class="keyword">Qed</span>.
    
    <span class="keyword">Lemma</span> <span class="function-name">Cat1LeftV</span> : <span class="type">forall</span> (<span class="variable-name">A1 A2</span> : obV log), <span class="type">forall</span> <span class="variable-name">f</span> : V(0 A1 |- A2)0,  f ~~ 1 &lt;o f.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> polyV_relT_constant_rel_identitary |].
      <span class="proof-tactics-name">apply</span> polyV_relT_inputUnitV_simpl. 
    <span class="keyword">Qed</span>.      
  <span class="keyword">End</span> <span class="function-name">Context2</span>.

  <span class="keyword">Canonical Structure</span> <span class="function-name">logT</span> : logic :=
    <span class="constant">@</span>Logic _ (<span class="constant">@</span><span class="keyword">Class</span>
                (<span class="constant">@</span>Data obT polyT_relT00 convT polyT_relT 
                       (<span class="constant">@</span>IdenT) consT00 (<span class="constant">@</span>consT01) consT10 desT00 desT10 ConsT DesT
                       IdenObT (<span class="constant">@</span>unitT) (<span class="constant">@</span>AssocT) (<span class="constant">@</span>DesIdenObRT) (<span class="constant">@</span>DesIdenObLT))
                ReflT TransT SymT Cong_polyT_relT polyT_relT_arrow
                polyT_relT_morphism polyT_relT_unitT polyT_relT_inputUnitT CongDesT
                Des_ConsT Des_OutputT CongConsT Cons_DesT Cons_InputT (<span class="constant">@</span>Assoc_RevT) Assoc_Assoc_RevT Assoc_Rev_AssocT).
<span class="keyword">End</span> <span class="function-name">LOGIC</span>.

<span class="keyword">Module</span> <span class="function-name">FUNCTOR</span>.
  <span class="keyword">Export</span> LOGIC.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic}.

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">obA</span> : <span class="type">Type</span>;
          polyA00 : obA -&gt; obA -&gt; obV log;
          polyA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A2</span> : obA), <span class="type">forall</span> (<span class="variable-name">A1</span> : obA),
                    V(0 V |- (polyA00 A2 A1) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 (polyA00 A1 X)  |- [0 V ~&gt; (polyA00 A2 X) ]0 )0;
          obB : <span class="type">Type</span>;
          polyB00 : obB -&gt; obB -&gt; obV log;
          polyB : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B2</span> : obB),  <span class="type">forall</span>(<span class="variable-name">B1</span> : obB),
                    V(0 V |- (polyB00 B2 B1) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">Y</span> : obB, V(0 (polyB00 B1 Y)  |- [0 V ~&gt; (polyB00 B2 Y) ]0 )0;
          polyF0 : obA -&gt; obB;
          polyF : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB) (<span class="variable-name">A</span> : obA),
                    V(0 V |- (polyB00 B (polyF0 A)) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 (polyA00 A X)  |- [0 V ~&gt; (polyB00 B (polyF0 X)) ]0 )0;
          unitA : <span class="type">forall</span> {<span class="variable-name">A</span> : obA}, V(0 I |- (polyA00 A A) )0;
        }.
    
  <span class="keyword">End</span> <span class="function-name">Context</span>.

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations3</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-A[0 A1 ~&gt; A2 ]0"</span> := (<span class="constant">@</span>polyA00 _ dat A1 A2) (<span class="type">at</span> level 25, format <span class="string">"dat .-A[0  A1  ~&gt;  A2  ]0"</span>).
    <span class="doc">(** therefore "A[1 f ~&gt; X ]0" is similar to ( f _3 o&gt; _2 ) **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-A[1 f ~&gt; X ]0"</span> := (<span class="constant">@</span>polyA _ dat _ _ _ f X) (<span class="type">at</span> level 25, format <span class="string">"dat .-A[1  f  ~&gt;  X  ]0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-uA"</span> := (<span class="constant">@</span>unitA _ dat _) (<span class="type">at</span> level 0, format <span class="string">"dat .-uA"</span>).
    
    <span class="keyword">Notation</span> <span class="string">"dat .-B[0 B1 ~&gt; B2 ]0"</span> := (<span class="constant">@</span>polyB00 _ dat B1 B2) (<span class="type">at</span> level 25, format <span class="string">"dat .-B[0  B1  ~&gt;  B2  ]0"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-B[1 m ~&gt; Y ]0"</span> := (<span class="constant">@</span>polyB _ dat _ _ _ m Y) (<span class="type">at</span> level 25, format <span class="string">"dat .-B[1  m  ~&gt;  Y  ]0"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations3</span>.
  <span class="keyword">Import</span> Ex_Notations3.
  <span class="keyword">Notation</span> <span class="string">"A[0 A1 ~&gt; A2 ]0"</span> := (_  .-A[0 A1 ~&gt; A2 ]0) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"A[1 f ~&gt; X ]0"</span> := (_.-A[1 f ~&gt; X ]0) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"'uA'"</span> := (_ .-uA) (<span class="type">at</span> level 0).
  <span class="keyword">Notation</span> <span class="string">"B[0 B1 ~&gt; B2 ]0"</span> := (_.-B[0 B1 ~&gt; B2 ]0) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"B[1 m ~&gt; Y ]0"</span> := (_.-B[1 m ~&gt; Y ]0) (<span class="type">at</span> level 25).

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic}.
    Context {<span class="variable-name">dat</span> : <span class="constant">@</span>data log}.
    
    <span class="keyword">Definition</span> <span class="function-name">polyA_IdenV</span>  : <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                              <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, V(0 A[0 A ~&gt; X ]0  |- [0 A[0 B ~&gt; A ]0 ~&gt; A[0 B ~&gt; X ]0 ]0 )0
      := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyA _ _ (A[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV _ (A[0 B ~&gt; A ]0)) X).
    
    <span class="keyword">Definition</span> <span class="function-name">polyB_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obB dat),
                             <span class="type">forall</span> <span class="variable-name">X</span> : obB dat, V(0 B[0 A ~&gt; X ]0  |- [0 B[0 B ~&gt; A ]0 ~&gt; B[0 B ~&gt; X ]0 ]0 )0
      := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyB _ _ (B[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV _ (B[0 B ~&gt; A ]0)) X).
  <span class="keyword">End</span> <span class="function-name">Context2</span>.
  
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations4'</span>.
    <span class="keyword">Export</span> Ex_Notations3.
    <span class="keyword">Notation</span> <span class="string">"dat .-A[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyA_IdenV _ dat B) (<span class="type">at</span> level 25, format  <span class="string">"dat .-A[0  B  ~&gt;  -  ]1"</span>).
    <span class="doc">(** therefore "A[0 X ~&gt; g ]1" is similar to the common ( _ &lt;o g ) **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-A[0 X ~&gt; a ]1"</span> := ( (dat.-A[0 _ ~&gt; - ]1) _ X &lt;o (<span class="variable-name">a</span> : V(0 _ |- dat.-A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25, format <span class="string">"dat .-A[0  X  ~&gt;  a  ]1"</span>).      

    <span class="keyword">Notation</span> <span class="string">"dat .-B[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyB_IdenV _ dat B) (<span class="type">at</span> level 25, format <span class="string">"dat .-B[0  B  ~&gt;  -  ]1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-B[0 Y ~&gt; n ]1"</span> := ( (dat.-B[0 _ ~&gt; - ]1) _ Y &lt;o (<span class="variable-name">n</span> : V(0 _ |- dat.-B[0 _ ~&gt; Y ]0 )0)) (<span class="type">at</span> level 25, format <span class="string">"dat .-B[0  Y  ~&gt;  n  ]1"</span>).
    
    <span class="keyword">Notation</span> <span class="string">"dat .-F|0 A"</span> := (<span class="constant">@</span>polyF0 _ dat A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"dat .-F|0  A"</span>).
    <span class="doc">(** :^) **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-F[0 B ~&gt; A ]0"</span> := (dat.-B[0 B ~&gt; (dat.-F|0 A) ]0) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[0  B  ~&gt;  A  ]0"</span>).
    <span class="doc">(** therefore "F[1 b ~&gt; X ]0" is similar to   ( b o&gt; ( F|1 _ ) )   , alternatively   ( b o&gt;F _ )   **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-F[1 b ~&gt; X ]0"</span> := (<span class="constant">@</span>polyF _ dat _ _ _ b X) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[1  b  ~&gt;  X  ]0"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations4'</span>.
  <span class="keyword">Import</span> Ex_Notations4'.
  <span class="keyword">Notation</span> <span class="string">"A[0 B ~&gt; - ]1"</span> := (_ .-A[0 B ~&gt; - ]1) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"A[0 X ~&gt; g ]1"</span> := (_.-A[0 X ~&gt; g ]1) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"B[0 B ~&gt; - ]1"</span> := (_ .-B[0 B ~&gt; - ]1) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"B[0 Y ~&gt; n ]1"</span> := (_.-B[0 Y ~&gt; n ]1) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"F|0 A"</span> := (_ .-F|0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (_ .-F[0 B ~&gt; A ]0) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"F[1 b ~&gt; X ]0"</span> := (_ .-F[1 b ~&gt; X ]0) (<span class="type">at</span> level 25).

  <span class="keyword">Section</span> <span class="function-name">Context3</span>.
    Context {<span class="variable-name">log</span> : logic}.
    Context {<span class="variable-name">dat</span> : <span class="constant">@</span>data log}.

    <span class="keyword">Definition</span> <span class="function-name">polyF_IdenV</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                             <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, V(0 A[0 A ~&gt; X ]0  |- [0 F[0 B ~&gt; A ]0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0
      := (<span class="type">fun</span> <span class="variable-name">B A X</span> =&gt; <span class="constant">@</span>polyF _ dat (F[0 B ~&gt; A ]0) B A (<span class="constant">@</span>IdenV _ (F[0 B ~&gt; A ]0)) X).

  <span class="keyword">End</span> <span class="function-name">Context3</span>.

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations4</span>.
    <span class="keyword">Export</span> Ex_Notations4'.
    <span class="keyword">Notation</span> <span class="string">"dat .-F[0 B ~&gt; - ]1"</span> := (<span class="constant">@</span>polyF_IdenV _ dat B) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[0  B  ~&gt;  -  ]1"</span>).
    <span class="keyword">Notation</span> <span class="string">"dat .-F[0 X ~&gt; a ]1"</span> := ( (dat.-F[0 _ ~&gt; - ]1) _ X &lt;o (<span class="variable-name">a</span> : V(0 _ |- dat.-A[0 _ ~&gt; X ]0 )0)) (<span class="type">at</span> level 25, format <span class="string">"dat .-F[0  X  ~&gt;  a  ]1"</span>).      

    <span class="doc">(** therefore "F[0 X ~&gt; a ]1" is similar to   ( B[0 B ~&gt; ( F|1 a ) ]1 ) which is ( _ o&gt; ( F|1 a ) )  , alternatively  ( _ o&gt;F a )   **)</span>
    <span class="keyword">Check</span> <span class="type">fun</span> (<span class="variable-name">log</span> : logic) (<span class="variable-name">dat</span> : data) (<span class="variable-name">B</span> : obB dat) =&gt;
            ( dat.-F[0 B ~&gt; - ]1 : <span class="type">forall</span> (<span class="variable-name">A X</span> : obA dat), V(0 dat.-A[0 A ~&gt; X ]0 |- [0 dat.-F[0 B ~&gt; A ]0 ~&gt; dat.-F[0 B ~&gt; X ]0 ]0 )0 ).
    <span class="keyword">Check</span> <span class="type">fun</span> (<span class="variable-name">log</span> : logic) (<span class="variable-name">dat</span> : data) (_B : obB dat) (_A : obA dat) (<span class="variable-name">X</span> : obA dat) (_W : obV log) (<span class="variable-name">a</span> : V(0 _W |- A[0 _A ~&gt; X ]0 )0) =&gt;
            ( dat.-F[0 X ~&gt; a ]1 : V(0 _W |- [0 dat.-F[0 _B ~&gt; _A ]0 ~&gt; dat.-F[0 _B ~&gt; X ]0 ]0 )0 ).

  <span class="comment-delimiter">(*</span><span class="comment"> Lemma tmp_dkdkd  : forall (log : logic) (dat : data) (_B : obB dat) (_A : obA dat) (X : obA dat) (_W : obV log) (a : V(0 _W |- dat.-A[0 _A ~&gt; X ]0 )0) ,
                       ( </span><span class="constant"><span class="comment">@</span></span><span class="comment">eq (V(0 _W |- [0 dat.-F[0 _B ~&gt; _A ]0 ~&gt; dat.-F[0 _B ~&gt; X ]0 ]0 )0)
                             (dat.-F[0 X ~&gt; a ]1)  (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF _ dat _ _ _ (</span><span class="constant"><span class="comment">@</span></span><span class="comment">IdenV _ _) X &lt;o (a : V(0 _ |- A[0 _ ~&gt; X ]0 )0)) ).
        reflexivity.
      Qed. </span><span class="comment-delimiter">*)</span>
  <span class="keyword">End</span> <span class="function-name">Ex_Notations4</span>.
  <span class="keyword">Import</span> Ex_Notations4.
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; - ]1"</span> := (_.-F[0 B ~&gt; - ]1) (<span class="type">at</span> level 25).
  <span class="keyword">Notation</span> <span class="string">"F[0 X ~&gt; a ]1"</span> := (_ .-F[0 X ~&gt; a ]1) (<span class="type">at</span> level 25).

  <span class="keyword">Section</span> <span class="function-name">Context4</span>.
    Context {<span class="variable-name">log</span> : logic}.
    
    <span class="keyword">Class</span> <span class="function-name">class</span> (<span class="variable-name">dat</span> : <span class="constant">@</span>data log) :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                      <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                        f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, polyA f' X ~~ polyA f X;
          polyA_arrow :  <span class="type">forall</span> (<span class="variable-name">B</span> : obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat),
                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                           A[1 f &lt;o v ~&gt; X ]0
                            ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0;
          polyF_arrow : <span class="type">forall</span> (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                        <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                          F[1 f &lt;o v ~&gt; X ]0
                           ~~ [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0;
          polyF_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat),
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA dat) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                             <span class="comment-delimiter">(*</span><span class="comment"> may use ( F[1 f ~&gt; A']0 &lt;o g ) because polyF_arrow is present .. may use ( DesIn( _ ) &lt;o _ ) .. ConsIn </span><span class="comment-delimiter">*)</span>
                             F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                              ~~  ( DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 )
                                    :  V(0 A[0 A' ~&gt; X ]0 |- [0 (0 W &amp; V )0 ~&gt; F[0 B ~&gt; X ]0 ]0 )0 );
          CongPolyF : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                      <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                        f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, polyF f' X ~~ polyF f X;
          polyA_unitA : <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat), <span class="type">forall</span> <span class="variable-name">X</span> : obA dat, (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>unitA _ dat A) ~&gt; X ]0 );
          polyF_inputUnitA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat) (<span class="variable-name">A</span> : obA dat),
                             <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0),
                               f ~~ DesIdenObL( (F[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA _ dat A) )
        }.

    Global Arguments CongPolyA {_ _} [_ _ _ _ _] _ _  .
    Global Arguments polyA_arrow {_ _} [_ _ _ _] _ _ _ .
    Global Arguments polyF_arrow {_ _} [_ _ _ _] _ _  _ .
    Global Arguments polyF_morphism {_ _} [_ _ _ _ _] _ _ _ .
    Global Arguments CongPolyF {_ _} [_ _ _ _ _] _ _ .
    Global Arguments polyA_unitA {_ _} _ _ .
    Global Arguments polyF_inputUnitA {_ _} [_ _ _] _  .

  <span class="doc">(** (** possible but yoneda does not require polymorphism in B **)
      Parameter polyF_morphism_codomain : forall (dat : data) (V : obV log) (B : obB dat),
                             forall (A : obA dat) (W : obV log) (B' : obB dat) (b : V(0 W |- B[0 B' ~&gt; B]0 )0),
                             forall (f : V(0 V |-F[0 B ~&gt; A ]0 )0) (X : obA dat), (* use ( B[1 b ~&gt; F|0 A ]0 &lt;o f  ) because no polyB_arrow *)
                               F[1 Des( B[1 b ~&gt; F|0 A ]0 &lt;o f ) ~&gt; X]0
                                ~~ ( DesIn( [0 V ~&gt; B[1 b ~&gt; F|0 X ]0 ]1 &lt;o F[1 f ~&gt; X ]0 )
                                        : V(0 A[0 A ~&gt; X ]0 |- [0 (0 V &amp; W )0 ~&gt; F[0 B' ~&gt; X ]0 ]0 )0 ) .
   **)</span>
  <span class="keyword">End</span> <span class="function-name">Context4</span>.

  <span class="keyword">Coercion</span> dat {<span class="variable-name">log</span> : logic} {<span class="variable-name">dat</span> : <span class="constant">@</span>data log} (<span class="variable-name">ext</span> : <span class="constant">@</span>class log dat) := dat.

  <span class="keyword">Section</span> <span class="function-name">Context5</span>.
    <span class="keyword">Variable</span> (<span class="variable-name">log</span> : logic).

    <span class="doc">(** printing for documentation
    Import LOGIC.Ex_Notations2.
    Check </span><span class="constant"><span class="doc">@</span></span><span class="doc">polyF : forall (log : logic) (dat : data) (V : obV log) (B : obB dat) (A : obA dat),
                     log.-V(0 V |- dat.-F[0 B ~&gt; A ]0 )0 -&gt;
                     forall X : obA dat, log.-V(0 dat.-A[0 A ~&gt; X ]0 |- log.-[0 V ~&gt; dat.-F[0 B ~&gt; X ]0 ]0 )0 . **)</span>
    
    <span class="keyword">Structure</span> <span class="function-name">functor</span> :=
      Functor <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; <span class="constant">@</span>data log;
          class_of :&gt; <span class="constant">@</span>class _ data_of
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> not critical, only for easy proofs without doing (class_of _) </span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>. 
  <span class="keyword">End</span> <span class="function-name">Context5</span>.

  <span class="keyword">Section</span> <span class="function-name">Context8</span>.
    Context {<span class="variable-name">log</span> : logic}.
    Context {<span class="variable-name">dat_</span> : <span class="constant">@</span>data log}.
    Context {<span class="variable-name">func</span> : <span class="constant">@</span>class _ dat_}.

    <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">polyF_arrowIn</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func),
                          <span class="type">forall</span> (<span class="variable-name">V W V'</span> : obV log) (<span class="variable-name">v</span> : V(0 W |- [0 V' ~&gt; V ]0 )0),
                          <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA func),
                            F[1 f &lt;o (Des v) ~&gt; X ]0
                             ~~ DesIn( V[1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o F[1 f ~&gt; X ]0 ) .
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> DesIn_Input | ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> polyF_arrow ]. 
      <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">apply</span> polyV_relV_polyV_relT. 
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">polyF_natural</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">f</span> : V(0 V |- F[0 B ~&gt; A ]0)0),
                          <span class="type">forall</span> (<span class="variable-name">Y X</span> : obA func),
                            ( [0 A[0 A ~&gt; Y ]0 ~&gt; F[1 f ~&gt; X ]0 ]1
                              &lt;o A[0 A ~&gt; - ]1 Y X )
                              ~~ ( [1 F[1 f ~&gt; Y ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                   &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; Y ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 Y X ) .
    <span class="keyword">Proof</span>.
      <span class="comment-delimiter">(*</span><span class="comment"> enough ( DesIn( _ ) ~~ DesIn( _ ) ) </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
      <span class="proof-tactics-name">apply</span> CongConsIn.

      <span class="comment-delimiter">(*</span><span class="comment"> convert left hand side : outer polyF_morphism then inner polyF_arrow </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS1</span> : F[1 Des( [1 f ~&gt; F[0 B ~&gt; Y ]0 ]0 &lt;o F[0 Y ~&gt; (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; Y]0)) ]1 ) ~&gt; X ]0
                       ~~ DesIn( [0 A[0 A ~&gt; Y ]0 ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[0 A ~&gt; - ]1 Y X ) )
        <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_morphism.

      <span class="proof-tactics-name">assert</span> ( <span class="variable-name">LHS2</span> : F[1 Des( F[1 (<span class="constant">@</span>IdenV _ (F[0 B ~&gt; A ]0)) &lt;o f ~&gt; Y ]0 ) ~&gt; X ]0
                       ~~ F[1 Des( [1 f ~&gt; F[0 B ~&gt; Y ]0 ]0 &lt;o F[0 Y ~&gt; (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; Y ]0)) ]1 ) ~&gt; X ]0 )
        <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">apply</span> CongPolyF, CongDes;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V | ]; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat1RightV | ];
             <span class="proof-tactics-name">apply</span> polyF_arrow ).

      <span class="comment-delimiter">(*</span><span class="comment"> convert right hand side : outer polyV_relV_arrow then outer polyF_arrowIn which is inner form of polyF_arrow </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS1</span> : DesIn( ( V[1 (<span class="constant">@</span>IdenV _ (V[0 V ~&gt; (F[0 B ~&gt; Y ]0) ]0)) &lt;o (F[1 f ~&gt; Y ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 Y X )
                           ~~ DesIn( [1 F[1 f ~&gt; Y ]0 ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; Y ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 Y X ) )
        <span class="coq-solve-tactics">by</span> ( <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> Cat2V | ];
             <span class="proof-tactics-name">apply</span> CongDesIn; <span class="proof-tactics-name">apply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV];
             <span class="proof-tactics-name">apply</span> polyV_relV_arrow ).

      <span class="proof-tactics-name">assert</span> ( <span class="variable-name">RHS2</span> : ( F[1 (<span class="constant">@</span>IdenV _ (F[0 B ~&gt; Y ]0)) &lt;o Des( (<span class="constant">@</span>IdenV _ (V[0 V ~&gt; (F[0 B ~&gt; Y ]0) ]0)) &lt;o (F[1 f ~&gt; Y ]0) ) ~&gt; X ]0 )
                        ~~ DesIn( ( V[1 (<span class="constant">@</span>IdenV _ (V[0 V ~&gt; (F[0 B ~&gt; Y ]0) ]0)) &lt;o (F[1 f ~&gt; Y ]0) ~&gt; (F[0 B ~&gt; X ]0) ]0 ) &lt;o F[0 B ~&gt; - ]1 Y X ) )
        <span class="coq-solve-tactics">by</span> <span class="proof-tactics-name">apply</span> polyF_arrowIn.

      <span class="comment-delimiter">(*</span><span class="comment"> clean right hand side </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS1 | ] .  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> RHS2 | ]. <span class="proof-tactics-name">clear</span> RHS2 RHS1.
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, Cat1LeftV | ]. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, Cat1LeftV | ].

      <span class="comment-delimiter">(*</span><span class="comment"> clean left hand side </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS1 ] .  <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, LHS2 ]. <span class="proof-tactics-name">clear</span> LHS2 LHS1.
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> CongPolyF, CongDes, CongPolyF, SymV, Cat1LeftV ].
      
      <span class="proof-tactics-name">apply</span> ReflV.
    <span class="keyword">Qed</span>.

    <span class="keyword">Definition</span> <span class="function-name">natural</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#946;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
      <span class="type">forall</span> (<span class="variable-name">Y X</span> : obA func),
        ( [0 A[0 A ~&gt; Y ]0 ~&gt; &#946; X ]1
          &lt;o A[0 A ~&gt; - ]1 Y X )
          ~~ ( [1 &#946; Y ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
               &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; Y ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 Y X ) .

    <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">natural_unitF_explicit</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#966;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                                     natural &#966; -&gt;
                                     <span class="type">forall</span> (<span class="variable-name">X</span> : obA func),
                                       DesIdenObR( [1 &#966; A &lt;o (<span class="constant">@</span>unitA _ func A) ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                                   &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A X )
                                                 ~~ ( &#966; X ) .
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV]; <span class="proof-tactics-name">apply</span> consV10_functorial ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, H ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> SymV, consV11_bifunctorial ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_arrow ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongDesIdenObR; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> CongPolyA, SymV, Cat1LeftV ].  
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> DesIdenObR_output].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">apply</span> ReflV | ]; <span class="proof-tactics-name">apply</span> SymV, polyA_unitA ].
      <span class="proof-tactics-name">apply</span> SymV, Cat1RightV.
    <span class="keyword">Qed</span>.
    
    <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">natural_unitF</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                            natural &#966; -&gt; natural &#966;' -&gt;
                            &#966;' A &lt;o (<span class="constant">@</span>unitA _ func A)  ~~ &#966; A &lt;o (<span class="constant">@</span>unitA _ func A) -&gt;
                            <span class="type">forall</span> <span class="variable-name">X</span> : obA func, &#966;' X ~~ &#966; X.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> |
                               <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> SymV, natural_unitF_explicit; <span class="coq-solve-tactics">assumption</span> ] ].
      <span class="proof-tactics-name">apply</span> CongDesIdenObR, CongCom; [ | <span class="proof-tactics-name">apply</span> ReflV ]; <span class="proof-tactics-name">apply</span> CongConsV10.
      <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.

    <span class="doc">(** for polymorph functor, get this copy-paste same deduction as for polymorph category **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">YONEDA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func) (<span class="variable-name">&#966; &#966;'</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0),
                     natural &#966; -&gt;
                     <span class="type">forall</span> <span class="variable-name">X</span> : obA func, &#966; X ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA _ func A) ) ~&gt; X ]0 .
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>; enough( &#966; A &lt;o (<span class="constant">@</span>unitA _ func A) ~~ F[1 DesIdenObL( (&#966; A) &lt;o (<span class="constant">@</span>unitA _ func A) ) ~&gt; A ]0 &lt;o (<span class="constant">@</span>unitA _ func A) ).
      <span class="proof-tactics-name">apply</span> natural_unitF; [ |  <span class="coq-solve-tactics">assumption</span> | <span class="coq-solve-tactics">assumption</span> ] .
      <span class="proof-tactics-name">unfold</span> natural; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">apply</span> polyF_natural.
      
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> SymV, ConsIdenObL_DesIdenObL | ].
      <span class="proof-tactics-name">eapply</span> TransV; [ | <span class="proof-tactics-name">apply</span> ConsIdenObL_DesIdenObL].
      <span class="proof-tactics-name">apply</span> CongConsIdenObL.
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">apply</span> polyF_inputUnitA |  <span class="proof-tactics-name">apply</span> ReflV ].
    <span class="keyword">Qed</span>.

  <span class="keyword">End</span> <span class="function-name">Context8</span>.
  
  <span class="keyword">Check</span> <span class="type">fun</span> <span class="variable-name">log</span> =&gt; <span class="type">fun</span> <span class="variable-name">ff</span> : <span class="constant">@</span>functor log  =&gt;  polyF_arrowIn (func:=ff).
<span class="keyword">End</span> <span class="function-name">FUNCTOR</span>.

<span class="keyword">Module</span> <span class="function-name">FORM</span>.
  <span class="keyword">Import</span> FUNCTOR.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context6</span>.
    Context {<span class="variable-name">log</span> : logic}.

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">obA</span> : <span class="type">Type</span>;
          polyA00 : obA -&gt; obA -&gt; obV log;
          polyA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">A2</span> : obA), <span class="type">forall</span> (<span class="variable-name">A1</span> : obA),
                    V(0 V |- (polyA00 A2 A1) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA, V(0 (polyA00 A1 X)  |- [0 V ~&gt; (polyA00 A2 X) ]0 )0;
          unitA : <span class="type">forall</span> <span class="variable-name">A</span> : obA, V(0 I |- polyA00 A A )0;
        }.

    <span class="keyword">Coercion</span> dataFun_of_dataCatForm (<span class="variable-name">d</span> : data)
    : <span class="constant">@</span>FUNCTOR.data log := {|
                            FUNCTOR.obA := obA d;
                            FUNCTOR.polyA00 := <span class="constant">@</span>polyA00 d;
                            FUNCTOR.polyA := <span class="constant">@</span>polyA d;
                            FUNCTOR.obB := obA d;
                            FUNCTOR.polyB00 := <span class="constant">@</span>polyA00 d;
                            FUNCTOR.polyB := <span class="constant">@</span>polyA d;
                            FUNCTOR.polyF0 := (<span class="constant">@</span>idT (obA d));
                            FUNCTOR.polyF := <span class="constant">@</span>polyA d;
                            FUNCTOR.unitA := <span class="constant">@</span>unitA d|}.

    Global Arguments dataFun_of_dataCatForm : <span class="proof-tactics-name">simpl</span> never.

  <span class="keyword">End</span> <span class="function-name">Context6</span>.
  
  <span class="keyword">Section</span> <span class="function-name">Context7</span>.
    Context {<span class="variable-name">log</span> : logic}.
    
    <span class="keyword">Class</span> <span class="function-name">class</span> (<span class="variable-name">dat</span> : data) :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> : FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : FUNCTOR.obA dat),
                      <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                        f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : FUNCTOR.obA dat, polyA f' X ~~ polyA f X;
          polyA_arrow :  <span class="type">forall</span> (<span class="variable-name">B</span> : FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : FUNCTOR.obA dat),
                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> :  FUNCTOR.obA dat),
                           A[1 f &lt;o v ~&gt; X ]0
                            ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0;
          polyA_unitA : <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat), <span class="type">forall</span> <span class="variable-name">X</span> :  FUNCTOR.obA dat, (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>FUNCTOR.unitA _ dat A) ~&gt; X ]0 );
        }.

    Global Arguments CongPolyA {_ _} [_ _ _ _ _] _ _  .
    Global Arguments polyA_arrow {_ _} [_ _ _ _] _ _ _ .
    Global Arguments polyA_unitA {_ _} _ _ .

  <span class="keyword">End</span> <span class="function-name">Context7</span>.

  <span class="keyword">Section</span> <span class="function-name">Context8</span>.
    <span class="keyword">Structure</span> <span class="function-name">form</span> (<span class="variable-name">log</span> : logic) :=
      Form <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; <span class="constant">@</span>data log;
          class_of :&gt; <span class="constant">@</span>class log (data_of)
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.

    <span class="keyword">Coercion</span> dataForm_of_dataFun {log} (<span class="variable-name">dat</span> : <span class="constant">@</span>FUNCTOR.data log)
    : <span class="constant">@</span>data log := {|
                    obA := FUNCTOR.obA dat;
                    polyA00 := <span class="constant">@</span>FUNCTOR.polyA00 _ dat;
                    polyA := <span class="constant">@</span>FUNCTOR.polyA _ dat;
                    unitA := <span class="constant">@</span>FUNCTOR.unitA _ dat |}.

    Global Arguments dataForm_of_dataFun : <span class="proof-tactics-name">simpl</span> never.

    <span class="keyword">Coercion</span> classForm_of_classFun {log} (<span class="variable-name">dat</span> : <span class="constant">@</span>FUNCTOR.data log) (<span class="variable-name">ext</span> : <span class="constant">@</span>FUNCTOR.class log dat)
    : <span class="constant">@</span>FORM.class log dat :=
      <span class="constant">@</span>FORM.<span class="keyword">Class</span> <span class="function-name">log</span> dat (<span class="constant">@</span>FUNCTOR.CongPolyA log dat ext) (<span class="constant">@</span>FUNCTOR.polyA_arrow log dat ext)
                  (<span class="constant">@</span>FUNCTOR.polyA_unitA log dat ext).

    Global Arguments classForm_of_classFun : <span class="proof-tactics-name">simpl</span> never.

    <span class="keyword">Definition</span> <span class="function-name">form_of_functor</span> {<span class="variable-name">log</span> : logic} (<span class="variable-name">func</span> : <span class="constant">@</span>functor log)
    : <span class="constant">@</span>form log :=  {| data_of := func ; class_of := func |}.
    <span class="doc">(** ?? Canonical Structure form_of_functor. ?? **)</span>

    <span class="keyword">Goal</span> <span class="type">forall</span> log (<span class="variable-name">func</span> : <span class="constant">@</span>functor log), 
           FUNCTOR.data_of func = (<span class="constant">@</span>dataFun_of_dataCatForm log (<span class="constant">@</span>data_of log (<span class="constant">@</span>form_of_functor log func))) .
      Fail <span class="coq-solve-tactics">reflexivity</span>.
      <span class="proof-tactics-name">destruct</span> func <span class="type">as</span> [datfunc extfunc]. <span class="proof-tactics-name">simpl</span>. <span class="keyword">Set Printing All</span>.  <span class="keyword">Show</span>. Fail <span class="coq-solve-tactics">reflexivity</span>.
      <span class="proof-tactics-name">destruct</span> datfunc. <span class="keyword">Unset Printing All</span>.   <span class="proof-tactics-name">compute</span>. Fail <span class="coq-solve-tactics">reflexivity</span>.
    <span class="keyword">Abort</span>.

  <span class="keyword">End</span> <span class="function-name">Context8</span>.

  <span class="keyword">Notation</span> form_of func := (<span class="constant">@</span>form_of_functor _ func).

  <span class="keyword">Export</span> FUNCTOR.
<span class="keyword">End</span> <span class="function-name">FORM</span>.

<span class="keyword">Module</span> <span class="function-name">CATEGORY</span>.
  <span class="keyword">Export</span> FORM.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context8</span>.
    Context {<span class="variable-name">log</span> : logic}.
    
    <span class="keyword">Class</span> <span class="function-name">class</span> (<span class="variable-name">dat</span> : FORM.data) :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">CongPolyA</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> : FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : FUNCTOR.obA dat),
                      <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                        f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : FUNCTOR.obA dat, polyA f' X ~~ polyA f X;
          <span class="comment-delimiter">(*</span><span class="comment"> remember that polyV_relT_arrow , relate in particular the polyV_relT_constant to polyV_relT_identitary </span><span class="comment-delimiter">*)</span>
          polyA_arrow :  <span class="type">forall</span> (<span class="variable-name">B</span> : FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> : FUNCTOR.obA dat),
                         <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                         <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> :  FUNCTOR.obA dat),
                           A[1 f &lt;o v ~&gt; X ]0
                            ~~ [1 v ~&gt; A[0 B ~&gt; X ]0 ]0 &lt;o A[1 f ~&gt; X ]0;
          polyF_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> :  FUNCTOR.obB dat),
                           <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> :  FUNCTOR.obA dat) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                             F[1 Des( [1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o F[0 A' ~&gt; g ]1 ) ~&gt; X]0
                              ~~  DesIn( [0 W ~&gt; F[1 f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0 );
          polyA_unitA : <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat), <span class="type">forall</span> <span class="variable-name">X</span> :  FUNCTOR.obA dat, (<span class="constant">@</span>IdenV _ (A[0 A ~&gt; X ]0)) ~~ DesIdenObR( A[1 (<span class="constant">@</span>FUNCTOR.unitA _ dat A) ~&gt; X ]0 );
          polyF_inputUnitA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log), <span class="type">forall</span> (<span class="variable-name">B</span> :  FUNCTOR.obA dat), <span class="type">forall</span> (<span class="variable-name">A</span> :  FUNCTOR.obA dat),
                             <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- A[0 B ~&gt; A ]0 )0),
                               f  ~~ DesIdenObL( (A[1 f ~&gt; A ]0) &lt;o (<span class="constant">@</span>FUNCTOR.unitA _ dat A) );
        }.

    Global Arguments CongPolyA {_ _} [_ _ _ _ _] _ _  .
    Global Arguments polyA_arrow {_ _} [_ _ _ _] _ _ _ .
    Global Arguments polyF_morphism {_ _} [_ _ _ _ _] _ _ _ .
    Global Arguments polyA_unitA {_ _} _ _ .
    Global Arguments polyF_inputUnitA {_ _} [_ _ _] _ .

    <span class="keyword">Coercion</span> classFun_of_classCat (<span class="variable-name">dat</span> : <span class="constant">@</span>FORM.data log) (<span class="variable-name">ext</span> : <span class="constant">@</span>class  dat)
    : <span class="constant">@</span>FUNCTOR.class log (dataFun_of_dataCatForm dat) := 
      {|
        FUNCTOR.CongPolyA := CongPolyA;
        FUNCTOR.polyA_arrow := polyA_arrow;
        FUNCTOR.polyF_arrow := polyA_arrow;
        FUNCTOR.polyF_morphism := polyF_morphism;
        FUNCTOR.CongPolyF := CongPolyA;
        FUNCTOR.polyA_unitA := polyA_unitA;
        FUNCTOR.polyF_inputUnitA := polyF_inputUnitA |}.

    Global Arguments classFun_of_classCat : <span class="proof-tactics-name">simpl</span> never.

  <span class="keyword">End</span> <span class="function-name">Context8</span>.

  <span class="keyword">Section</span> <span class="function-name">Context9</span>.
    <span class="keyword">Structure</span> <span class="function-name">category</span> (<span class="variable-name">log</span> : logic) :=
      Category <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; <span class="constant">@</span>FORM.data log;
          class_of :&gt; <span class="constant">@</span>class  log (data_of)
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.

    <span class="keyword">Coercion</span> functor_of_category {<span class="variable-name">log</span> : logic} (<span class="variable-name">c</span> : <span class="constant">@</span>category log)
    : <span class="constant">@</span>FUNCTOR.functor log :=  {| FUNCTOR.data_of := data_of c; FUNCTOR.class_of :=  class_of c |}.
    <span class="comment-delimiter">(*</span><span class="comment"> false ambiguity : new coercion produce same output as old coercion ; the new coercion will be used to coerce but also the notational hiddenness/implicitness of old coercion is kept for printing </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Canonical Structure</span> <span class="function-name">functor_of_category</span>.

    <span class="keyword">Goal</span> <span class="type">forall</span> (<span class="variable-name">log</span> : logic) (<span class="variable-name">func</span> : <span class="constant">@</span>category log),
           FUNCTOR.data_of func = (<span class="constant">@</span>dataFun_of_dataCatForm log (<span class="constant">@</span>FORM.data_of log (<span class="constant">@</span>form_of_functor log func))) .
      <span class="coq-solve-tactics">reflexivity</span>.
    <span class="keyword">Qed</span>.
    
    <span class="keyword">Coercion</span> category_of_logic (<span class="variable-name">log</span> : logic) : <span class="constant">@</span>category log :=
      <span class="constant">@</span>Category log _
                (<span class="constant">@</span><span class="keyword">Class</span> <span class="function-name">log</span>
                        {|
                          FORM.obA := obV log;
                          FORM.polyA00 := <span class="constant">@</span>consV00 log;
                          FORM.polyA := <span class="constant">@</span>polyV_relV log;
                          FORM.unitA := <span class="constant">@</span>unitV log |} (<span class="constant">@</span>CongPolyV log) (<span class="constant">@</span>polyV_relV_arrow log)
                        (<span class="constant">@</span>polyV_relV_morphism log) (<span class="constant">@</span>polyV_relV_unitV log)
                        (<span class="constant">@</span>polyV_relV_inputUnitV log)) .

    <span class="keyword">Canonical Structure</span> <span class="function-name">category_of_logic</span>.
  <span class="keyword">End</span> <span class="function-name">Context9</span>.
  <span class="keyword">Export</span> FUNCTOR.
<span class="keyword">End</span> <span class="function-name">CATEGORY</span>.

<span class="keyword">Module</span> <span class="function-name">FUNCTORTOCAT</span>.
  <span class="keyword">Export</span> CATEGORY.
  <span class="keyword">Import</span> FUNCTOR.Ex_Notations4.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset  Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">from</span> : <span class="constant">@</span>form log) (<span class="variable-name">to</span> : <span class="constant">@</span>category log).
    
    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">polyF0</span> : obA from -&gt; obA to;
          polyF :   <span class="type">forall</span> {<span class="variable-name">V</span> : obV log}{<span class="variable-name">B</span> : obA to} {<span class="variable-name">A</span> : obA from},
                      V(0 V |- to .-A[0 B ~&gt; polyF0 A ]0 )0 -&gt;
                      <span class="type">forall</span> <span class="variable-name">X</span> : obA from,
                        V(0 from .-A[0 A ~&gt; X ]0 |- [0V ~&gt; to .-A[0 B ~&gt; polyF0 X ]0 ]0 )0;
        }.

    <span class="keyword">Coercion</span> dataFun_of_dataFuntoCat (<span class="variable-name">d</span> : data)
    : <span class="constant">@</span>FUNCTOR.data log :=  {|
                            FUNCTOR.obA := <span class="constant">@</span>obA _ from;
                            FUNCTOR.polyA00 := <span class="constant">@</span>polyA00 _ from;
                            FUNCTOR.polyA := <span class="constant">@</span>polyA _ from;
                            FUNCTOR.obB := <span class="constant">@</span>obA _ to;
                            FUNCTOR.polyB00 := <span class="constant">@</span>polyA00 _ to;
                            FUNCTOR.polyB := <span class="constant">@</span>polyA _ to;
                            FUNCTOR.polyF0 := polyF0 d;
                            FUNCTOR.polyF := <span class="constant">@</span>polyF d;
                            FUNCTOR.unitA := <span class="constant">@</span>unitA _ from |}.

    Global Arguments dataFun_of_dataFuntoCat : <span class="proof-tactics-name">simpl</span> never. <span class="doc">(** really useful with cbn **)</span>

  <span class="keyword">End</span> <span class="function-name">Context</span>.

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">from</span> : <span class="constant">@</span>form log} {<span class="variable-name">to</span> : <span class="constant">@</span>category log}.

    <span class="keyword">Class</span> <span class="function-name">class</span> (<span class="variable-name">dat</span> : <span class="constant">@</span>data log from to) :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">polyF_arrow</span> :    <span class="type">forall</span> {<span class="variable-name">B</span> : obA to} {<span class="variable-name">A</span> : obA from} {<span class="variable-name">V V'</span> : obV log} 
                             (<span class="variable-name">v</span> : V(0 V' |- V )0) (<span class="variable-name">f</span> : V(0 V |- to .-A[0 B ~&gt; polyF0 dat A ]0 )0)
                             (<span class="variable-name">X</span> : obA from),
                             dat.-F[1  (f &lt;o v) ~&gt; X ]0 ~~
                                [1v ~&gt; to .-A[0 B ~&gt; dat.-F|0 X ]0 ]0 &lt;o dat.-F[1 f ~&gt; X ]0 ;
          polyF_morphism :    <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA to) (<span class="variable-name">A</span> : obA from) 
                                (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA from) (<span class="variable-name">g</span> : V(0 W |- from .-A[0 A ~&gt; A' ]0 )0)
                                (<span class="variable-name">f</span> : V(0 V |- to .-A[0 B ~&gt; polyF0 dat A ]0 )0) (<span class="variable-name">X</span> : obA from),
                                dat.-F[1 (Des ([1f ~&gt; to .-A[0 B ~&gt; dat.-F|0 A' ]0 ]0 &lt;o dat.-F[1 1 ~&gt; A' ]0 &lt;o g)) ~&gt; X ]0 ~~
                                   DesIn ([0W ~&gt; dat.-F[1 f ~&gt; X ]0 ]1 &lt;o from .-A[1 g ~&gt; X ]0) ;
          CongPolyF :    <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA to) (<span class="variable-name">A</span> : obA from)
                           (<span class="variable-name">f f'</span> : V(0 V |- to .-A[0 B ~&gt; dat.-F|0 A ]0 )0),
                           f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA from, dat.-F[1 f' ~&gt; X ]0 ~~ dat.-F[1 f ~&gt; X ]0 ;
          polyF_inputUnitA :    <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA to) (<span class="variable-name">A</span> : obA from)
                                  (<span class="variable-name">f</span> : V(0 V |- to .-A[0 B ~&gt; dat.-F|0 A ]0 )0),
                                  f ~~ DesIdenObL (dat.-F[1 f ~&gt; A ]0 &lt;o (from) .-uA)
        }.

    Global Arguments polyF_arrow {_ _} [_ _ _ _] _ _  _ .
    Global Arguments polyF_morphism {_ _} [_ _ _ _ _] _ _ _ .
    Global Arguments CongPolyF {_ _} [_ _ _ _ _] _ _ .
    Global Arguments polyF_inputUnitA {_ _} [_ _ _] _  .

    <span class="keyword">Coercion</span> classFun_of_classFuntoCat (<span class="variable-name">dat</span> : <span class="constant">@</span>data log from to) (<span class="variable-name">ext</span> : <span class="constant">@</span>class dat)  :  <span class="constant">@</span>FUNCTOR.class log dat :=
      FUNCTOR.<span class="keyword">Class</span> (dat:=dat) (<span class="constant">@</span>FORM.CongPolyA _ _ from) (<span class="constant">@</span>FORM.polyA_arrow _ _ from) (<span class="constant">@</span>polyF_arrow dat ext)
                    (<span class="constant">@</span>polyF_morphism _ ext) (<span class="constant">@</span>CongPolyF _ ext) (<span class="constant">@</span>FORM.polyA_unitA _ _ from)
                    (<span class="constant">@</span>polyF_inputUnitA _ ext).

    Global Arguments classFun_of_classFuntoCat : <span class="proof-tactics-name">simpl</span> never.

  <span class="keyword">End</span> <span class="function-name">Context2</span>.

  <span class="keyword">Section</span> <span class="function-name">Context3</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">from</span> : <span class="constant">@</span>form log) (<span class="variable-name">to</span> : <span class="constant">@</span>category log).

    <span class="keyword">Structure</span> <span class="function-name">functorToCat</span> :=
      FunctorToCat <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; <span class="constant">@</span>data log from to;
          class_of :&gt; <span class="constant">@</span>class _ _ _ (data_of)
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.

    <span class="keyword">Coercion</span> functor_of_functorToCat (<span class="variable-name">func</span> : functorToCat)
    : <span class="constant">@</span>FUNCTOR.functor log :=  {| FUNCTOR.data_of := data_of func; FUNCTOR.class_of := class_of func |}.
    <span class="comment-delimiter">(*</span><span class="comment"> false ambiguity : new coercion produce same output as old coercion ; the new coercion will be used to coerce but also the notational hiddenness/implicitness of old coercion is kept for printing </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Canonical Structure</span> <span class="function-name">functor_of_functorToCat</span>.

    <span class="keyword">Definition</span> <span class="function-name">polyF_unitB</span> {<span class="variable-name">func</span> : functorToCat} : <span class="type">forall</span> (<span class="variable-name">A</span> : obA from),
                                                   <span class="type">forall</span> <span class="variable-name">X</span> : obA from, V(0 from.-A[0 A ~&gt; X ]0  |- to.-A[0 func.-F|0 A ~&gt; func.-F|0 X ]0 )0.
      <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">apply</span> DesIdenObR.
      <span class="proof-tactics-name">eapply</span> polyF.
      <span class="proof-tactics-name">apply</span> (<span class="constant">@</span>unitA _ to).
      <span class="keyword">Show</span> <span class="keyword">Proof</span>.
    <span class="comment-delimiter">(*</span><span class="comment"> (fun (func : functorToCat) (A X : obA from) =&gt;
 DesIdenObR (polyF (d:=func) (to) .-uA X)) </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Defined</span>.

  <span class="keyword">End</span> <span class="function-name">Context3</span>.
  
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations6</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-F|1"</span> := (<span class="constant">@</span>polyF_unitB _ _ _ dat) (<span class="type">at</span> level 0, format <span class="string">"dat .-F|1"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations6</span>.
  <span class="keyword">Import</span> Ex_Notations6.
  <span class="keyword">Notation</span> <span class="string">"F|1"</span> := (_ .-F|1) (<span class="type">at</span> level 0).

  <span class="keyword">Section</span> <span class="function-name">Context4</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">catA</span> : form log) (<span class="variable-name">catB</span> : category log) (<span class="variable-name">funF</span> : functorToCat catA catB) (<span class="variable-name">B</span> : obB catB).

    <span class="doc">(** functors are very primitive therefore no reason for this sequencing lemma to hold,         
but later polyF_identitary_rel_polyF_unitB do hold    for alone functorToCat_of_metafunctor    or   for funComp composition of two functors  ,
also later with the polymorphism in B assumption and the B is category (polyB_inputUnitB) assumption then this lemma hold **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">polyF_identitary_rel_polyF_unitB_ABORT</span> : <span class="type">forall</span> (<span class="variable-name">A X</span> : obA catA),
                                                     (catB.-F[0 B ~&gt; - ]1) (funF.-F|0 A) (funF.-F|0 X) &lt;o funF.-F|1 A X ~~
                                                                                                                    (funF.-F[0 B ~&gt; - ]1) A X  .
    <span class="keyword">Proof</span>. <span class="comment-delimiter">(*</span><span class="comment">intros.
        Check  (funF.-F[0 B ~&gt; - ]1) A X . Check F|1 A X. Check  (catB.-F[0 B ~&gt; - ]1).
        Set Printing Coercions. intros. Show.
        intros. simpl.   simpl. Unset Printing Implicit Defensive. Show. unfold polyF_unitB. simpl. 
        eapply TransV; [| eapply SymV, DesIdenObR_output ].
        
        unfold polyF_IdenV.
        eapply CongDesIdenObR.
         apply DesIdenObR_output.
      Qed.</span><span class="comment-delimiter">*)</span> 
    <span class="keyword">Abort</span>.

  <span class="keyword">End</span> <span class="function-name">Context4</span>.

  <span class="keyword">Section</span> <span class="function-name">Context5</span>.   
    <span class="comment-delimiter">(*</span><span class="comment">    Import Ex_Notations.</span><span class="comment-delimiter">*)</span>
    <span class="keyword">Import</span> LOGIC.Ex_Notations3.
    <span class="keyword">Import</span> FUNCTOR.Ex_Notations4.
    <span class="keyword">Variable</span> (<span class="variable-name">log</span> : logic).
    <span class="keyword">Variable</span> (<span class="variable-name">pf</span> : <span class="constant">@</span>convV log = <span class="type">fun</span> <span class="variable-name">V1 V2</span> =&gt; (<span class="variable-name">eq</span> : V(0 V1 |- V2 )0 -&gt; V(0 V1 |- V2 )0 -&gt; <span class="type">Prop</span>) ).

    <span class="keyword">Eval</span> <span class="proof-tactics-name">unfold</span> polyT_relT_identitary, idT <span class="type">in</span> <span class="type">fun</span> <span class="variable-name">a b</span> =&gt; a &lt;&lt;o b.
    <span class="keyword">Eval</span> <span class="proof-tactics-name">unfold</span> polyT_relT_constant, cstT <span class="type">in</span> <span class="type">fun</span> <span class="variable-name">b a</span> =&gt; b o&gt;&gt; a.
    <span class="comment-delimiter">(*</span><span class="comment">BUG fix </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Local Notation</span> <span class="string">"a &lt;&lt;o b"</span> := ((T(1 (<span class="type">fun</span> <span class="variable-name">h</span> : _ =&gt; h) |- _ )0) a b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
    <span class="keyword">Local Notation</span> <span class="string">"b o&gt;&gt; a"</span> := ( (T(1 <span class="type">fun</span> _ : unit =&gt; b |- _ )0) a tt) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).
    <span class="comment-delimiter">(*</span><span class="comment"> ATTEMPT   Notation "a &lt;o b" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_identitary _ _ _ _ a b) (at level 33, right associativity).
    Notation "b o&gt; a" := (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyV_relT_constant _ _ _ b _ a) (at level 33, right associativity).</span><span class="comment-delimiter">*)</span>
    <span class="comment-delimiter">(*</span><span class="comment"> ATTEMPT Local Notation "b o&gt; a" := (b o&gt;_&gt; a) (at level 33, right associativity).
    Local Notation "a &lt;o b" := (a &lt;_&lt;o b) (at level 33, right associativity).</span><span class="comment-delimiter">*)</span>
    <span class="keyword">Local Notation</span> <span class="string">"b o&gt;' a"</span> := (b o&gt; _ &gt; a) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity). <span class="keyword">Print</span> Grammar constr.
    <span class="keyword">Local Notation</span> <span class="string">"a &lt;o' b"</span> := (a &lt; _ &lt;o b) (<span class="type">at</span> level 33, <span class="proof-tactics-name">right</span> associativity).

    <span class="keyword">Definition</span> <span class="function-name">category_relT_of_logic</span> : <span class="constant">@</span>category logT.
      unshelve <span class="proof-tactics-name">econstructor</span>.
      <span class="company-coq-featuresXcode-folding-bullet">-</span> unshelve <span class="proof-tactics-name">econstructor</span>.
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>obV log).
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>polyV_relT00 log).
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>polyV_relT log).
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>unitV_relT log).
      <span class="company-coq-featuresXcode-folding-bullet">-</span> unshelve <span class="proof-tactics-name">econstructor</span>.
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">intros</span> * -&gt; . <span class="coq-solve-tactics">reflexivity</span>.
        <span class="company-coq-featuresXcode-folding-bullet">+</span>  <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">generalize</span> (<span class="constant">@</span>polyV_relT_arrow log log).
           <span class="proof-tactics-name">intros</span> H_polyV_relT_arrow; <span class="proof-tactics-name">intros</span>.  erewrite  !pf <span class="type">in</span> *.
           <span class="proof-tacticals-name">do</span> 2 (<span class="proof-tactics-name">apply</span> functional_extensionality_T; <span class="proof-tactics-name">intros</span>).
           <span class="proof-tactics-name">apply</span> H_polyV_relT_arrow; <span class="coq-solve-tactics">reflexivity</span>.
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">generalize</span> (<span class="constant">@</span>polyV_relT_morphism log log).
          <span class="proof-tactics-name">intros</span> H_polyV_relT_morphism; <span class="proof-tactics-name">intros</span>.  erewrite  !pf <span class="type">in</span> *.
          <span class="proof-tacticals-name">do</span> 2 (<span class="proof-tactics-name">apply</span> functional_extensionality_T; <span class="proof-tactics-name">intros</span>).
          <span class="proof-tactics-name">apply</span> H_polyV_relT_morphism.
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">generalize</span> (<span class="constant">@</span>polyV_relT_unitV log log).
          <span class="proof-tactics-name">intros</span> H_polyV_relT_unitV; <span class="proof-tactics-name">intros</span>.  erewrite  !pf <span class="type">in</span> *.
          <span class="proof-tacticals-name">do</span> 1 (<span class="proof-tactics-name">apply</span> functional_extensionality_T; <span class="proof-tactics-name">intros</span>). 
          <span class="proof-tactics-name">eapply</span> H_polyV_relT_unitV; <span class="coq-solve-tactics">reflexivity</span>.
        <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">generalize</span> (<span class="constant">@</span>polyV_relT_inputUnitV log log).
          <span class="proof-tactics-name">intros</span> H_polyV_relT_inputUnitV; <span class="proof-tactics-name">intros</span>.  erewrite  !pf <span class="type">in</span> *.
          <span class="proof-tacticals-name">do</span> 1 (<span class="proof-tactics-name">apply</span> functional_extensionality_T; <span class="proof-tactics-name">intros</span>). 
          <span class="proof-tactics-name">eapply</span> H_polyV_relT_inputUnitV; <span class="coq-solve-tactics">reflexivity</span>.
    <span class="keyword">Qed</span>.

  <span class="keyword">End</span> <span class="function-name">Context5</span>.
  <span class="keyword">Export</span> FUNCTOR.
<span class="keyword">End</span> <span class="function-name">FUNCTORTOCAT</span>.

<span class="keyword">Module</span> <span class="function-name">TRANSFORMATION</span>.
  <span class="keyword">Import</span> FUNCTORTOCAT.
  <span class="keyword">Import</span> FUNCTOR.Ex_Notations4.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : <span class="constant">@</span>form log} {<span class="variable-name">catB</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funG</span> : functorToCat catA catB).

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">poly&#946;</span> : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">A</span> : obA catA),
                    V(0 V |- funF.-F[0 B ~&gt; A ]0 )0 -&gt;
                    V(0 V |- funG.-F[0 B ~&gt; A ]0 )0
        }.
  <span class="keyword">End</span> <span class="function-name">Context</span>.

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-&#946;|1 f"</span> := (<span class="constant">@</span>poly&#946; _ _ _ _ _ dat _ _ _ f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"dat .-&#946;|1  f"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations</span>.
  <span class="keyword">Import</span> Ex_Notations.
  <span class="keyword">Notation</span> <span class="string">"&#946;|1 f"</span> := (_.-&#946;|1 f) (<span class="type">at</span> level 5, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : form log} {<span class="variable-name">catB</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funG</span> : functorToCat catA catB).
    

    <span class="keyword">Class</span> <span class="function-name">class</span> {<span class="variable-name">dat</span> : data funF funG} :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">poly&#946;_arrow</span> : <span class="type">forall</span> (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">A</span> : obA catA),
                        <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
                          dat.-&#946;|1 (f &lt;o v)
                                   ~~ dat.-&#946;|1 f &lt;o v;
          <span class="doc">(** written here : (inner modification) ~~ (outer modification)**)</span>
          poly&#946;_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA catB),
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obA catA) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA catA) (<span class="variable-name">a</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
                             dat.-&#946;|1 (Des( [1 f ~&gt; funF.-F[0 B ~&gt; A' ]0 ]0 &lt;o funF.-F[0 A' ~&gt; a ]1 ))
                                      ~~ (Des( [1 dat.-&#946;|1 f ~&gt; funG.-F[0 B ~&gt; A' ]0 ]0 &lt;o funG.-F[0 A' ~&gt; a ]1 )) ;
          poly&#946;_morphism_codomain : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log),
                                    <span class="type">forall</span> (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">B'</span> : obA catB) (<span class="variable-name">b</span> : V(0 W |- catB.-A[0 B' ~&gt; B]0 )0),
                                    <span class="type">forall</span> (<span class="variable-name">A</span> : obA catA),
                                    <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-funF.-F[0 B ~&gt; A ]0 )0),
                                      dat.-&#946;|1 (Des( catB.-A[1 b ~&gt; funF.-F|0 A ]0 &lt;o f ))
                                               ~~  Des( catB.-A[1 b ~&gt; funG.-F|0 A ]0 &lt;o dat.-&#946;|1 f );
        }.

    Global Arguments poly&#946;_arrow {_ _} [_ _ _ _] _ _ .
    Global Arguments poly&#946;_morphism {_ _} [_ _ _ _ _] _ _ .
    Global Arguments poly&#946;_morphism_codomain {_ _} [_ _ _ _ _] _ _ .
    
    <span class="keyword">Structure</span> <span class="function-name">transformation</span> :=
      Transf <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; data funF funG;
          class_of :&gt; <span class="constant">@</span>class (data_of)
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.

  <span class="keyword">End</span> <span class="function-name">Context2</span>.
<span class="keyword">End</span> <span class="function-name">TRANSFORMATION</span>.

<span class="keyword">Module</span> <span class="function-name">METAFUNCTOR</span>.
  <span class="keyword">Export</span> FUNCTORTOCAT.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">from</span> : form log).

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">metaF0</span> : obA from -&gt; obV log;
          metaF : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">A</span> : obA from),
                    V(0 V |- (metaF0 A) )0 -&gt;
                    <span class="type">forall</span> <span class="variable-name">X</span> : obA from, V(0 (polyA00 A X)  |- [0 V ~&gt; (metaF0 X) ]0 )0;
        }.
    
  <span class="keyword">End</span> <span class="function-name">Context</span>.

  <span class="keyword">Delimit Scope</span> meta <span class="type">with</span> meta.
  <span class="keyword">Local Open Scope</span> meta.
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations</span>.
    <span class="doc">(** no scoping necessary for duplicate because definitionally same with poly for same notations     dat .-F|0 A   ,    dat .-F[0 B ~&gt; A ]0, 
      else extra notation  dat .-F[1M b ~&gt; X ]0 **)</span>
    <span class="keyword">Notation</span> <span class="string">"dat .-F|0 A"</span> := (<span class="constant">@</span>metaF0 _ _ dat A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity) : meta.
    <span class="keyword">Notation</span> <span class="string">"dat .-F[0 B ~&gt; A ]0"</span> := (V[0 B ~&gt; dat .-F|0 A ]0) (<span class="type">at</span> level 25) : meta.
    <span class="keyword">Notation</span> <span class="string">"dat .-F[1M b ~&gt; X ]0"</span> := (<span class="constant">@</span>metaF _ _ dat _ _ b X) (<span class="type">at</span> level 25).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations</span>.
  <span class="keyword">Import</span> Ex_Notations.
  <span class="keyword">Notation</span> <span class="string">"F|0 A"</span> := (_ .-F|0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity) : meta.
  <span class="keyword">Notation</span> <span class="string">"F[0 B ~&gt; A ]0"</span> := (_ .-F[0 B ~&gt; A ]0) (<span class="type">at</span> level 25) : meta.
  <span class="keyword">Notation</span> <span class="string">"F[1M b ~&gt; X ]0"</span> := (_ .-F[1M b ~&gt; X ]0) (<span class="type">at</span> level 25).
  
  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic}  (<span class="variable-name">from</span> : form log).
    Context {<span class="variable-name">dat</span> : <span class="constant">@</span>data log from}.

    <span class="keyword">Definition</span> <span class="function-name">metaF_IdenV</span> : <span class="type">forall</span> <span class="variable-name">A X</span> : obA from, V(0 A[0 A ~&gt; X ]0 |- [0 F|0 A ~&gt; F|0 X ]0 )0
      :=  (<span class="type">fun</span> <span class="variable-name">A X</span> =&gt; <span class="constant">@</span>metaF _ _ dat _ A (<span class="constant">@</span>IdenV _ _) X).

  <span class="keyword">End</span> <span class="function-name">Context2</span>.

  <span class="keyword">Module</span> <span class="function-name">Ex_Notations2</span>.
    <span class="keyword">Export</span> Ex_Notations.
    <span class="keyword">Notation</span> <span class="string">"dat .-F||1"</span> := (<span class="constant">@</span>metaF_IdenV _ _ dat _ _) (<span class="type">at</span> level 0).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations2</span>.
  <span class="keyword">Import</span> Ex_Notations2.
  <span class="keyword">Notation</span> <span class="string">"F||1"</span> := (_ .-F||1) (<span class="type">at</span> level 0).

  <span class="keyword">Section</span> <span class="function-name">Context3</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">from</span> : form log}.
    
    <span class="keyword">Class</span> <span class="function-name">class</span> {<span class="variable-name">dat</span> : <span class="constant">@</span>data log from} :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">metaF_arrow</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA from),
                        <span class="type">forall</span> (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0),
                        <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- dat.-F|0 A )0) (<span class="variable-name">X</span> : obA from),
                          F[1M f &lt;o v ~&gt; X ]0
                           ~~ [1 v ~&gt; F|0 X ]0 &lt;o F[1M f ~&gt; X ]0 ;
          metaF_morphism : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log),
                           <span class="type">forall</span> (<span class="variable-name">A</span> : obA from) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA from) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A']0 )0),
                           <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F|0 A )0) (<span class="variable-name">X</span> : obA from),
                             F[1M Des( [1 f ~&gt; F|0 A' ]0 &lt;o (dat.-F||1 &lt;o g) ) ~&gt; X]0
                              ~~  DesIn( [0 W ~&gt; F[1M f ~&gt; X ]0 ]1 &lt;o A[1 g ~&gt; X ]0) ;
          CongMetaF : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log)(<span class="variable-name">A</span> : obA from),
                      <span class="type">forall</span> (<span class="variable-name">f f'</span> : V(0 V |- dat.-F|0 A )0),
                        f' ~~ f -&gt; <span class="type">forall</span> <span class="variable-name">X</span> : obA from, F[1M f' ~&gt; X ]0 ~~ F[1M f ~&gt; X ]0 ;
          metaF_inputUnitA : <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">A</span> : obA from),
                             <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |- dat.-F|0 A )0),
                               f ~~ DesIdenObL( (F[1M f ~&gt; A ]0) &lt;o (<span class="constant">@</span>unitA _ from A) ) ;
        }.

    Global Arguments metaF_arrow {_ _} [_ _ _] _ _  _ .
    Global Arguments metaF_morphism {_ _} [_ _ _ _] _ _ _ .
    Global Arguments CongMetaF {_ _} [_ _ _ _] _ _  .
    Global Arguments metaF_inputUnitA {_ _} [_ _] _  .

  <span class="keyword">End</span> <span class="function-name">Context3</span>.
  <span class="keyword">Section</span> <span class="function-name">Context4</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">from</span> : form log).

    <span class="keyword">Structure</span> <span class="function-name">metafunctor</span> :=
      Metafunctor <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; <span class="constant">@</span>data log from;
          class_of :&gt; <span class="constant">@</span>class log from data_of
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> not critical, only for easy proofs without doing (class_of _) </span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>. 
    
    <span class="keyword">Coercion</span> dataFunToCat_of_metafunctor  (<span class="variable-name">dat</span> : <span class="constant">@</span>metafunctor)
    : <span class="constant">@</span>FUNCTORTOCAT.data log from (CATEGORY.category_of_logic log) :=
      <span class="constant">@</span>FUNCTORTOCAT.Data log
                         from (CATEGORY.category_of_logic log)
                         (<span class="constant">@</span>metaF0 log from dat)
                         (<span class="type">fun</span> (<span class="variable-name">V B</span> : obV log) (<span class="variable-name">A</span> : obA from) (<span class="variable-name">b</span> : V(0 V |- F[0 B ~&gt; A ]0 )0)
                            (<span class="variable-name">X</span> : obA from) =&gt; ConsIn (F[1M Des b ~&gt; X ]0)).

    Global Arguments dataFunToCat_of_metafunctor : <span class="proof-tactics-name">simpl</span> never.

    <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaF_arrow</span>:
      <span class="type">forall</span> (<span class="variable-name">dat</span> : data from)(<span class="variable-name">ext</span> : <span class="constant">@</span>class log from dat) (<span class="variable-name">B</span> : obV log) (<span class="variable-name">A</span> : obA from) 
        (<span class="variable-name">V V'</span> : obV log) (<span class="variable-name">v</span> : V(0 V' |- V )0) (<span class="variable-name">f</span> : V(0 V |- dat.-F[0 B ~&gt; A ]0 )0)
        (<span class="variable-name">X</span> : obA from),
        ConsIn (F[1M Des (f &lt;o v) ~&gt; X ]0) ~~
               [1 v ~&gt; F[0 B ~&gt; X ]0 ]0 &lt;o ConsIn (F[1M Des f ~&gt; X ]0).
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaF, Des_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, metaF_arrow ].
      <span class="proof-tactics-name">apply</span> ConsIn_Output.  
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaF_morphism</span>:
      <span class="type">forall</span> <span class="variable-name">dat</span> : data from, <span class="constant">@</span>class log from dat -&gt;
                         <span class="type">forall</span> (<span class="variable-name">V B</span> : obV log) (<span class="variable-name">A</span> : obA from) (<span class="variable-name">W</span> : obV log) 
                           (<span class="variable-name">A'</span> : obA from) (<span class="variable-name">g</span> : V(0 W |- A[0 A ~&gt; A' ]0 )0)
                           (<span class="variable-name">f</span> : V(0 V |- dat.-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA from),
                           ConsIn
                             (F[1M Des
                                   (Des
                                      ([1 f ~&gt; F[0 B ~&gt; A' ]0 ]0 &lt;o
                                                                    ConsIn (F[1M Des 1 ~&gt; A' ]0) &lt;o g)) ~&gt; X ]0) ~~
                             DesIn ([0 W ~&gt; ConsIn (F[1M Des f ~&gt; X ]0) ]1 &lt;o A[1 g ~&gt; X ]0).
    <span class="keyword">Proof</span>.
      <span class="comment-delimiter">(*</span><span class="comment"> enough (  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ~~  [1Assoc ~&gt; P|0 X ]0 &lt;o DesIn ( _ ) ) </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">intros</span>;  <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> TransV | ]; [ <span class="proof-tactics-name">apply</span> ConsIn_DesIn | <span class="proof-tactics-name">idtac</span> | <span class="proof-tactics-name">apply</span> SymV, ConsIn_DesIn].
      <span class="proof-tactics-name">apply</span> CongConsIn, Assoc_Iso.

      <span class="doc">(** LHS **)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_ConsIn].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, metaF_arrow ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaF, Cat1LeftV | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsIn, metaF_arrow | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ConsIn_Input | <span class="proof-tactics-name">eapply</span> ReflV]  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> Cat2V  ] | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, CongDes, SymV, Cat2V  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> CongDes, Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> Des_Input  | <span class="proof-tactics-name">eapply</span> ReflV ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, Cat2V ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV | <span class="proof-tactics-name">eapply</span> SymV, Assoc_nat0 ] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, SymV, Cat2V ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, Des_consV10_functorial  | <span class="proof-tactics-name">eapply</span> ReflV] ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsV10, CongDes, SymV, Cat1LeftV ] .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongMetaF, SymV, Des_Input ] .

      <span class="doc">(** RHS **)</span>
      <span class="comment-delimiter">(*</span><span class="comment">extraline</span><span class="comment-delimiter">*)</span>         <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDesIn; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIn_Input |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, CongMetaF, SymV, Cat1LeftV |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, CongConsIn, SymV, metaF_arrow  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, CongConsV01, SymV, ConsIn_Input  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongDesIn, SymV, consV01_functorial  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, DesIn_Input  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIn_Input  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> Assoc_DesIn_DesIn  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIn_Input  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, consV01_functorial  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, metaF_arrow  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDesIn, CongConsV01, CongMetaF, Cat1LeftV  |].
      <span class="comment-delimiter">(*</span><span class="comment">extraline</span><span class="comment-delimiter">*)</span>         <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, DesIn_Input |].

      <span class="proof-tactics-name">eapply</span> metaF_morphism.
    <span class="keyword">Qed</span>.            
    
    <span class="keyword">Lemma</span> <span class="function-name">Cong_poly_of_metaF</span>:
      <span class="type">forall</span> <span class="variable-name">dat</span> : data from,
        <span class="constant">@</span>class log from dat -&gt;
        <span class="type">forall</span> (<span class="variable-name">V B</span> : obV log) (<span class="variable-name">A</span> : obA from) (<span class="variable-name">f f'</span> : V(0 V |- dat.-F[0 B ~&gt; A ]0 )0),
          f' ~~ f -&gt;
          <span class="type">forall</span> <span class="variable-name">X</span> : obA from,
            ConsIn (F[1M Des f' ~&gt; X ]0) ~~ ConsIn (F[1M Des f ~&gt; X ]0).
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaF, CongDes. <span class="coq-solve-tactics">assumption</span>.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaF_inputUnitA</span>:
      <span class="type">forall</span> <span class="variable-name">dat</span> : data from,
        <span class="constant">@</span>class log from dat -&gt;
        <span class="type">forall</span> (<span class="variable-name">V B</span> : obV log) (<span class="variable-name">A</span> : obA from) (<span class="variable-name">f</span> : V(0 V |- dat.-F[0 B ~&gt; A ]0 )0),
          f ~~ DesIdenObL (ConsIn (F[1M Des f ~&gt; A ]0) &lt;o uA).
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span> ? ext; <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> Cons_Des|]. <span class="proof-tactics-name">eapply</span> TransV; [|<span class="proof-tactics-name">eapply</span> SymV, Cons_Des].
      <span class="proof-tactics-name">eapply</span> CongCons.
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDes, CongDesIdenObL, ConsIn_Input|].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> Des_ConsIn|].
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>metaF_inputUnitA _ _ _ ext).
    <span class="keyword">Qed</span>.

    <span class="keyword">Coercion</span> classFunToCat_of_metafunctor (<span class="variable-name">func</span> : <span class="constant">@</span>metafunctor)
    : <span class="constant">@</span>FUNCTORTOCAT.class log from (CATEGORY.category_of_logic log) (dataFunToCat_of_metafunctor func) :=
      <span class="constant">@</span>FUNCTORTOCAT.<span class="keyword">Class</span> <span class="function-name">log</span>
                          from (CATEGORY.category_of_logic log)
                          (dataFunToCat_of_metafunctor func)
                          (poly_of_metaF_arrow func)
                          (poly_of_metaF_morphism func) (Cong_poly_of_metaF func)  (poly_of_metaF_inputUnitA func).
    
    <span class="keyword">Coercion</span> functorToCat_of_metafunctor (<span class="variable-name">func</span> : <span class="constant">@</span>metafunctor)
    : <span class="constant">@</span>FUNCTORTOCAT.functorToCat log from (CATEGORY.category_of_logic log) :=  {| FUNCTORTOCAT.data_of :=  func; FUNCTORTOCAT.class_of :=  func |}.
    <span class="keyword">Canonical Structure</span> <span class="function-name">functorToCat_of_metafunctor</span>.
    
    <span class="comment-delimiter">(*</span><span class="comment"> poly_of_metaF_unitV_metaF_IdenV
     : forall (func : metafunctor) (A X : METAFUNCTOR.obA func),
       F|1 A X ~~ F||1 </span><span class="comment-delimiter">*)</span>  <span class="comment-delimiter">(*</span><span class="comment"> solve difference in notation? </span><span class="comment-delimiter">*)</span>
    <span class="keyword">Lemma</span> <span class="function-name">poly_of_metaF_unitV_metaF_IdenV</span> (<span class="variable-name">func</span> : metafunctor): <span class="type">forall</span> <span class="variable-name">A X</span> : obA from, 
                                                                  <span class="constant">@</span>FUNCTORTOCAT.polyF_unitB log from (CATEGORY.category_of_logic log) func A X ~~ <span class="constant">@</span>metaF_IdenV _ _ func A X .
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">unfold</span> metaF_IdenV.
      <span class="proof-tactics-name">eapply</span> TransV; cycle 1.
      <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaF, Cat1LeftV .
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaF_arrow ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> SymV, consV10_DesIdenObL | <span class="proof-tactics-name">eapply</span> ReflV] ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  | <span class="proof-tactics-name">eapply</span> ReflV] ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1  | <span class="proof-tactics-name">eapply</span> ReflV] ].
      <span class="proof-tactics-name">eapply</span> SymV, Cat1LeftV.
    <span class="keyword">Qed</span>.
    
  <span class="keyword">End</span> <span class="function-name">Context4</span>.

  <span class="keyword">Import</span> FUNCTOR.Ex_Notations4.
  <span class="keyword">Import</span> FUNCTORTOCAT.Ex_Notations6.
  <span class="keyword">Section</span> <span class="function-name">Context6</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">func</span> : functor log)  (<span class="variable-name">B</span> : obB func) .

    <span class="keyword">Definition</span> <span class="function-name">dataMetafun_of_functor_at</span> : <span class="constant">@</span>METAFUNCTOR.data log (FORM.form_of_functor func)  := {|
                                                                                                  metaF0 := <span class="type">fun</span> <span class="variable-name">A</span> : FUNCTOR.obA (form_of_functor func) =&gt; func.-F[0 B ~&gt; A ]0;
                                                                                                  metaF := (<span class="type">fun</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">A</span> : obA (form_of_functor func)) (<span class="variable-name">f</span> : V(0 V |- func.-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA (form_of_functor func)) =&gt; func.-F[1 f ~&gt; X ]0  <span class="comment-delimiter">(*</span><span class="comment"> </span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF log func V B A f X </span><span class="comment-delimiter">*)</span>  ) |}.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary ?</span><span class="comment-delimiter">*)</span>
    Global Arguments dataMetafun_of_functor_at : <span class="proof-tactics-name">simpl</span> never.

    <span class="keyword">Definition</span> <span class="function-name">classMetafun_of_functor_at</span> : <span class="constant">@</span>METAFUNCTOR.class log (FORM.form_of_functor func) dataMetafun_of_functor_at  :=
      (<span class="constant">@</span><span class="keyword">Class</span> <span class="function-name">log</span> (<span class="constant">@</span>form_of_functor log func) dataMetafun_of_functor_at
              (<span class="type">fun</span> <span class="variable-name">A V V' v f X</span> =&gt; <span class="constant">@</span>polyF_arrow _ _ func B A V V' v f X)
              (<span class="type">fun</span> <span class="variable-name">V A W A' g f X</span> =&gt; <span class="constant">@</span>polyF_morphism _ _ func V B A W A' g f X)
              (<span class="type">fun</span> <span class="variable-name">V A f f' H X</span> =&gt;  <span class="constant">@</span>CongPolyF _ _ func V B A f f' H X)
              (<span class="type">fun</span> <span class="variable-name">V A f</span> =&gt;  <span class="constant">@</span>polyF_inputUnitA _ _ func V B A f)) .

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary *</span><span class="comment-delimiter">*)</span>
    Global Arguments classMetafun_of_functor_at : <span class="proof-tactics-name">simpl</span> never.

  <span class="keyword">End</span> <span class="function-name">Context6</span>.

  <span class="keyword">Definition</span> <span class="function-name">metafunctor_of_functor_at</span> {<span class="variable-name">log</span> : logic} (<span class="variable-name">func</span> : functor log)  (<span class="variable-name">B</span> : <span class="constant">@</span>FUNCTOR.obB log func)
  : <span class="constant">@</span>metafunctor log (form_of_functor func) :=  {| data_of := (<span class="constant">@</span>dataMetafun_of_functor_at log func B) ; class_of := (<span class="constant">@</span>classMetafun_of_functor_at log func B) |}.
  <span class="doc">(**    Coercion metafunctor_of_functor_at : FUNCTOR.obB &gt;-&gt; metafunctor. (* coercion ? *) **)</span>
  <span class="keyword">Canonical Structure</span> <span class="function-name">metafunctor_of_functor_at</span>.

  <span class="keyword">Notation</span> meta_of func B := (<span class="constant">@</span>metafunctor_of_functor_at _ func B).
  
  <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_identitary_rel_polyF_identitary</span> {<span class="variable-name">log</span> : logic} (<span class="variable-name">func</span> : functor log) (<span class="variable-name">B</span> : <span class="constant">@</span>obB log func)
  : <span class="type">forall</span> <span class="variable-name">A X</span> : obA func, (<span class="constant">@</span>metafunctor_of_functor_at log func B).-F||1= func.-F[0 B ~&gt; - ]1 A X .
  <span class="keyword">Proof</span>.
    <span class="coq-solve-tactics">reflexivity</span>.
  <span class="keyword">Qed</span>.

  <span class="keyword">Lemma</span> <span class="function-name">meta_of_polyF_at_identitary_rel_polyF_identitary'</span> {<span class="variable-name">log</span> : logic} (<span class="variable-name">func</span> : functor log) (<span class="variable-name">B</span> : <span class="constant">@</span>obB log func)
  : <span class="type">forall</span> <span class="variable-name">A X</span> : obA func, (<span class="constant">@</span>metafunctor_of_functor_at log func B).-F||1 ~~ func.-F[0 B ~&gt; - ]1 A X .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> ReflV.
  <span class="keyword">Qed</span>.
  
  <span class="keyword">Section</span> <span class="function-name">Context8</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">from</span> : form log) (<span class="variable-name">func</span> : <span class="constant">@</span>metafunctor log from).
    <span class="keyword">Let</span> <span class="function-name">funF</span> : functorToCat from (category_of_logic log) := functorToCat_of_metafunctor func.
    <span class="keyword">Variable</span> (<span class="variable-name">B</span> : obB (category_of_logic log)).

    Local Unset Printing Implicit Defensive.
    <span class="keyword">Lemma</span> <span class="function-name">polyF_identitary_rel_polyF_unitB_metaFunc</span> : <span class="type">forall</span> (<span class="variable-name">A X</span> : obA from),
                                                        ( (category_of_logic log).-F[0 B ~&gt; - ]1) (funF.-F|0 A) (funF.-F|0 X) &lt;o funF.-F|1 A X ~~
                                                                                                                                           (funF.-F[0 B ~&gt; - ]1) A X  .
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">simpl</span>. <span class="proof-tactics-name">unfold</span> polyV_relV. <span class="proof-tactics-name">unfold</span> polyF_unitB. <span class="proof-tactics-name">simpl</span>.
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input ].
      <span class="proof-tactics-name">eapply</span> CongConsIn.

      <span class="comment-delimiter">(*</span><span class="comment"> LHS </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, CongMetaF, Cat1LeftV ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDesIdenObR, CongConsIn, metaF_arrow ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDesIdenObR, ConsIn_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIdenObR_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].

      <span class="comment-delimiter">(*</span><span class="comment"> RHS </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongMetaF, SymV, Cat1LeftV  |].
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, metaF_arrow  |].

      <span class="comment-delimiter">(*</span><span class="comment"> pure logic </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> SymV, Cat1RightV |]. <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, DesIdenObR_DesIdenObL].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsV10, SymV, unitV_IdenV  ].
      <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1.
    <span class="keyword">Qed</span>.
  <span class="keyword">End</span> <span class="function-name">Context8</span>.

  <span class="keyword">Export</span> FUNCTOR.
<span class="keyword">End</span> <span class="function-name">METAFUNCTOR</span>.

<span class="keyword">Module</span> <span class="function-name">METATRANSFORMATION</span>.
  <span class="keyword">Import</span> TRANSFORMATION.
  <span class="keyword">Export</span> METAFUNCTOR.
  <span class="keyword">Import</span> FUNCTOR.Ex_Notations4.
  <span class="keyword">Import</span> TRANSFORMATION.Ex_Notations.
  <span class="keyword">Import</span> METAFUNCTOR.Ex_Notations2.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : form log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : metafunctor catA).
    <span class="keyword">Variable</span> (<span class="variable-name">funG</span> : metafunctor catA).

    <span class="keyword">Record</span> <span class="function-name">data</span> :=
      Data <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">meta&#946;</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA catA),
                    V(0 funF.-F|0 A |- funG.-F|0 A )0
        }.

  <span class="keyword">End</span> <span class="function-name">Context</span>.
  
  <span class="keyword">Module</span> <span class="function-name">Ex_Notations</span>.
    <span class="keyword">Notation</span> <span class="string">"dat .-&#946;||0 A"</span> := (<span class="constant">@</span>meta&#946; _ _ _ _ dat A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity, format <span class="string">"dat .-&#946;||0  A"</span>).
  <span class="keyword">End</span> <span class="function-name">Ex_Notations</span>.
  <span class="keyword">Import</span> Ex_Notations.
  <span class="keyword">Notation</span> <span class="string">"&#946;||0 A"</span> := (_ .-&#946;||0 A) (<span class="type">at</span> level 4, <span class="proof-tactics-name">right</span> associativity).

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : form log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : metafunctor catA).
    <span class="keyword">Variable</span> (<span class="variable-name">funG</span> : metafunctor catA).  

    <span class="keyword">Class</span> <span class="function-name">class</span> (<span class="variable-name">dat</span> : data funF funG) :=
      <span class="keyword">Class</span> <span class="company-coq-featuresXcode-folding-bullet">{</span>
          <span class="variable-name">meta&#946;_morphism</span> : <span class="type">forall</span> (<span class="variable-name">A</span> : obA catA)  (<span class="variable-name">A'</span> : obA catA),
                             [0 funF.-F|0 A ~&gt;  dat.-&#946;||0 A' ]1 &lt;o funF.-F||1
                                                                  ~~ [1 dat.-&#946;||0 A ~&gt; funG.-F|0 A' ]0 &lt;o funG.-F||1;
        }.

    Global Arguments meta&#946;_morphism {_ _} _ _ .
    
    <span class="keyword">Structure</span> <span class="function-name">metatransformation</span> :=
      Metatransf <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; data funF funG;
          class_of :&gt; <span class="constant">@</span>class (data_of)
        }.

    <span class="comment-delimiter">(*</span><span class="comment"> is this necessary?</span><span class="comment-delimiter">*)</span>
    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.

    <span class="keyword">Coercion</span> dataTransformation_of_dataMetatransformation log catA funF funG (<span class="variable-name">dat</span> : <span class="constant">@</span>data log catA funF funG)
    : <span class="constant">@</span>TRANSFORMATION.data log catA (CATEGORY.category_of_logic log) funF funG :=
      <span class="constant">@</span>TRANSFORMATION.Data log catA (CATEGORY.category_of_logic log) funF funG
                           ( <span class="type">fun</span> (<span class="variable-name">V B</span> : obV log) (<span class="variable-name">A</span> : obA catA) (<span class="variable-name">b</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0) =&gt;
                               Cons (dat.-&#946;||0 A &lt;o Des b) ).

    Global Arguments dataTransformation_of_dataMetatransformation : <span class="proof-tactics-name">simpl</span> never.

    <span class="doc">(** lemmas **)</span>
    <span class="keyword">Lemma</span>  <span class="function-name">poly_of_meta&#946;_arrow</span>:
      <span class="type">forall</span> <span class="variable-name">dat</span> : data funF funG,
        <span class="constant">@</span>class dat -&gt;
        <span class="type">forall</span> (<span class="variable-name">B</span> : obA log) (<span class="variable-name">A</span> : obA catA) (<span class="variable-name">V V'</span> : obV log) 
          (<span class="variable-name">v</span> : V(0 V' |- V )0) (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
          dat.-&#946;|1 (f &lt;o v) ~~ dat.-&#946;|1 f &lt;o v.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cons_Input  |] .
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCons; <span class="proof-tactics-name">eapply</span> SymV, Cat2V  |] .
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCons; <span class="proof-tactics-name">eapply</span> CongCom; [ <span class="proof-tactics-name">eapply</span> ReflV |  <span class="proof-tactics-name">eapply</span> Des_Input  ] |] .
      <span class="proof-tactics-name">eapply</span> ReflV.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_morphism</span>:
      <span class="type">forall</span> <span class="variable-name">dat</span> : data funF funG,
        <span class="constant">@</span>class dat -&gt;
        <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA log) (<span class="variable-name">A</span> : obA catA) 
          (<span class="variable-name">W</span> : obV log) (<span class="variable-name">A'</span> : obA catA) (<span class="variable-name">a</span> : V(0 W |- catA .-A[0 A ~&gt; A' ]0 )0)
          (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
          dat.-&#946;|1 (Des ([1 f ~&gt; funF.-F[0 B ~&gt; A' ]0 ]0 &lt;o funF.-F[1 1 ~&gt; A' ]0 &lt;o a)) ~~
                   Des ([1 dat.-&#946;|1 f ~&gt; funG.-F[0 B ~&gt; A' ]0 ]0 &lt;o funG.-F[1 1 ~&gt; A' ]0 &lt;o a).
    <span class="keyword">Proof</span>.
      <span class="doc">(** LHS **)</span>
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV| <span class="proof-tactics-name">eapply</span> Cons_Des] ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaF, Cat1LeftV ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, metaF_arrow ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Des_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, ConsIn_consV10_functorial ].        
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Des_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  SymV, Des_Output ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, SymV, Cat2V].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2 ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> CongConsIn, consV11_bifunctorial ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV] ; <span class="proof-tactics-name">eapply</span> ConsIn_Input ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|] ; <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span>  CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|] ; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> meta&#946;_morphism   ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDes; <span class="proof-tactics-name">eapply</span> SymV, Cat2V]. 
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, Cat2V].

      <span class="doc">(** RHS **)</span>
      <span class="proof-tactics-name">eapply</span> CongDes. <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |]. <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn , CongMetaF, SymV, Cat1LeftV |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn , SymV, metaF_arrow |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |].
      <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV].

      <span class="doc">(** more pure logic *)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10, CongDes, SymV, Cat1LeftV].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn; <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10,  SymV, Des_Cons ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongConsIn, CongConsV10,  CongDes, Cat1LeftV ].
      <span class="proof-tactics-name">eapply</span> ConsIn_consV10_functorial.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">poly_of_meta&#946;_morphism_codomain</span>:
      <span class="type">forall</span> <span class="variable-name">dat</span> : data funF funG,
        class dat -&gt;
        <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA log) (<span class="variable-name">W</span> : obV log) 
          (<span class="variable-name">B'</span> : obA log) (<span class="variable-name">b</span> : V(0 W |- log .-A[0 B' ~&gt; B ]0 )0) 
          (<span class="variable-name">A</span> : obA catA) (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
          dat.-&#946;|1 (Des (log .-A[1 b ~&gt; funF.-F|0 A ]0 &lt;o f)) ~~
                   Des (log .-A[1 b ~&gt; funG.-F|0 A ]0 &lt;o dat.-&#946;|1 f).
    <span class="keyword">Proof</span>.
      <span class="doc">(** LHS **)</span>
      <span class="proof-tactics-name">intros</span>; <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
      <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV| <span class="proof-tactics-name">eapply</span> Cons_Des] ].

      <span class="doc">(** RHS **)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> Cons_Output |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cons_Des |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_DesIn |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, polyV_relV_polyV_relT |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, Cat2V |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, consV11_bifunctorial |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, Cat1RightV |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2 |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> SymV, Des_Output  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, Cat2V |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> ConsIn_Input  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, Cat1LeftV  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, polyV_relV_polyV_relT  |].
      <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV |]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_DesIn  |].

      <span class="proof-tactics-name">eapply</span> ReflV.
    <span class="keyword">Qed</span>.

    <span class="doc">(** now class part**)</span>
    <span class="keyword">Coercion</span> classTransformation_of_classMetatransformation (<span class="variable-name">dat</span> : <span class="constant">@</span>data log catA funF funG) (<span class="variable-name">ext</span> : <span class="constant">@</span>class dat)
    : <span class="constant">@</span>TRANSFORMATION.class log catA (CATEGORY.category_of_logic log) funF funG dat :=
      <span class="constant">@</span>TRANSFORMATION.<span class="keyword">Class</span> <span class="function-name">log</span> catA (CATEGORY.category_of_logic log) funF funG
                            (dataTransformation_of_dataMetatransformation dat)
                            (poly_of_meta&#946;_arrow ext)
                            (poly_of_meta&#946;_morphism ext)
                            (poly_of_meta&#946;_morphism_codomain ext).
    
    <span class="keyword">Coercion</span> transformation_of_metatransformation (<span class="variable-name">trans</span> : <span class="constant">@</span>metatransformation)
    : <span class="constant">@</span>TRANSFORMATION.transformation log catA (CATEGORY.category_of_logic log) funF funG
      := {| TRANSFORMATION.data_of :=  trans; TRANSFORMATION.class_of :=  trans |}.
    <span class="keyword">Canonical Structure</span> <span class="function-name">transformation_of_metatransformation</span>.
    
    <span class="doc">(** theorem **)</span>
    <span class="keyword">Import</span> Ex_Notations.
    <span class="keyword">Definition</span> <span class="function-name">typeof_meta&#946;_morphism</span> :=  <span class="type">forall</span> (<span class="variable-name">trans</span> : <span class="constant">@</span>metatransformation),  <span class="type">forall</span> <span class="variable-name">A A'</span> : obA catA,
                                           [0 funF.-F|0 A ~&gt; trans.-&#946;||0 A' ]1 &lt;o (funF) .-F||1 ~~
                                                                                 [1 trans.-&#946;||0 A ~&gt; funG.-F|0 A' ]0 &lt;o (funG) .-F||1.
    <span class="keyword">Check</span>  (<span class="type">fun</span> <span class="variable-name">trans</span>: <span class="constant">@</span>metatransformation =&gt; <span class="constant">@</span>meta&#946;_morphism _ trans) : typeof_meta&#946;_morphism.
    <span class="keyword">Definition</span> <span class="function-name">typeof_poly&#946;_morphism</span> :=  <span class="type">forall</span> (<span class="variable-name">trans</span> : metatransformation) (<span class="variable-name">V</span> : obV log) 
                                           (<span class="variable-name">B</span> : obA log) (<span class="variable-name">A</span> : obA catA) (<span class="variable-name">W</span> : obV log) 
                                           (<span class="variable-name">A'</span> : obA catA) (<span class="variable-name">a</span> : V(0 W |- catA .-A[0 A ~&gt; A' ]0 )0)
                                           (<span class="variable-name">f</span> : V(0 V |- funF.-F[0 B ~&gt; A ]0 )0),
                                           trans.-&#946;|1 (Des([1 f ~&gt; funF.-F[0 B ~&gt; A' ]0 ]0 &lt;o funF.-F[1 1 ~&gt; A' ]0 &lt;o a)) ~~
                                                      Des([1 trans.-&#946;|1 f ~&gt; funG.-F[0 B ~&gt; A' ]0 ]0 &lt;o funG.-F[1 1 ~&gt; A' ]0 &lt;o a).
    <span class="keyword">Check</span> (<span class="type">fun</span> <span class="variable-name">trans</span>: <span class="constant">@</span>metatransformation =&gt; <span class="constant">@</span>TRANSFORMATION.poly&#946;_morphism _ _ _ _  _ _ trans) : typeof_poly&#946;_morphism .

    <span class="keyword">Lemma</span> <span class="function-name">meta&#946;_morphism_from_poly_of_meta&#946;</span> : typeof_poly&#946;_morphism -&gt; typeof_meta&#946;_morphism.
    <span class="keyword">Proof</span>.
      <span class="doc">(** LHS **)</span>
      <span class="proof-tactics-name">unfold</span> typeof_meta&#946;_morphism, typeof_poly&#946;_morphism. <span class="proof-tactics-name">intro</span> H_poly_morphism. <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">specialize</span> H_poly_morphism <span class="type">with</span> (B := I) (A := A) (A' := A') (a := 1) (f := 1).
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Cons_Output ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cons_Des ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, consV10_functorial_fun1 ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat1LeftV ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat1RightV ]. 
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsIn, CongMetaF, Cat1LeftV ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, CongConsIn, metaF_arrow ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDes, ConsIn_Input ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Des_Output ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, SymV, Cat2V ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Output2   ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongDes, SymV, ConsIn_Input   ].

      <span class="doc">(** RHS **)</span>
      <span class="proof-tactics-name">eapply</span> CongCons <span class="type">in</span> H_poly_morphism.
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> Cons_Des]. <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> Cons_Des].
      <span class="proof-tactics-name">eapply</span>  TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, Cat1RightV ].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn, CongMetaF, Cat1LeftV ].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> CongConsIn, metaF_arrow].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|];  <span class="proof-tactics-name">eapply</span> ConsIn_Input].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, Cat2V ].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_consV10_functorial ].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input].
      <span class="proof-tactics-name">eapply</span> CongDesIn <span class="type">in</span> H_poly_morphism.
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> DesIn_ConsIn]. <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> DesIn_ConsIn].        
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> CongConsV10, CongDes, SymV, Cat1LeftV].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> CongConsV10, Des_Cons].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> consV10_functorial].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> Cat2V].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> consV11_bifunctorial ].
      <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_poly_morphism; [| <span class="proof-tactics-name">eapply</span> Cat2V ].
      <span class="proof-tactics-name">eapply</span> Des_I_Iso <span class="type">in</span> H_poly_morphism.

      <span class="coq-solve-tactics">exact</span> H_poly_morphism.
    <span class="keyword">Qed</span>.

  <span class="keyword">End</span> <span class="function-name">Context2</span>.

  <span class="doc">(**  __NEXT SECTION IS WHY : ALL THIS WORK OF INTERFACING FOR INSTANCES WAS DONE__
apply this to unfold this as identitary (external-structural) of composition (not really composition) of polyfunctors ( polyV_relV o (poly_of_meta F[0 B ~&gt; - ]1) ) .. ( polyV_relV o (poly_of_meta metaFB) )  ...  show before that
1. some metafunctor metaFB into catV on top of F[0 B ~&gt; - ]1  by polyF which becomes  metaFB := meta_of_poly F at B,
2.  then get derived polyfunctor from this metafunctor, 
3.  then unitary( |1 ) of this derived polyfunctor is  identitary( ||1 ) of the metafunctor metaFB on top of F[0 B ~&gt; - ]1 
4.  which is  identitary ( [B ~&gt; - ]1 ) of original polyfunctor F  all:
( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 A' X   (polyF is functor)
( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (meta_of_ polyF at B)||1 A' X  ( meta_IdenV  ||1 , definitionally )
(    ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o FB||1 A' X    )
( V[0 V ~&gt; - ]1 (F[0 B ~&gt; A' ]0) (F[0 B ~&gt; X ]0) ) &lt;o (poly_of_ (meta_of_ polyF at B))|1 A' X (poly_of_meta is functorToCat  ,  propositionally)
(poly_of_meta metaFB)[0 V ~&gt; - ]1 A' X   ALT   (polyV_relV_funToCat o (poly_of_meta metaFB))[0 V ~&gt; - ]1 A' X (propositionally funComp_idenV_rel_F'_IdenV_F_unitB... </span><span class="variable-name"><span class="doc">?may</span></span><span class="doc"> relate functorToCat_unitB  |1 with functor_IdenV  [0 B ~&gt; - ]1 ? )
(meta_of_poly (poly_of_meta (meta_of_poly F at B)) at V)||1 A' X   ALT  (meta_of_poly (polyV_relV_funToCat o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X
.... V( A[A' ~&gt; X] |- [ V[V ~&gt; F[B ~&gt; A']] ~&gt; V[V ~&gt; F[B ~&gt; X]] ] )  .... as above

  Definition natural (V : obV) (B : obB) (A : obA) (&#946; : forall X : obA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 )0) :=
                        forall (C X : obA),
                          ( [0 A[0 A ~&gt; C ]0 ~&gt; &#946; X ]1
                            &lt;o A[0 A ~&gt; - ]1 C X )
                            ~~ ( [1 &#946; C ~&gt; [0 V ~&gt; F[0 B ~&gt; X ]0 ]0 ]0
                                 &lt;o ( V[0 V ~&gt; - ]1 (F[0 B ~&gt; C ]0) (F[0 B ~&gt; X ]0) ) &lt;o F[0 B ~&gt; - ]1 C X ) .

  Definition natural (V : obV) (B : obB) (A : obA) 
                        (&#946; : forall X : obA, V(0 (meta_of_poly polyA at A)|0 X  |- (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X )0) :=
                        forall (A' X : obA),
                          ( [0 (meta_of_poly polyA at A)|0 A' ~&gt; &#946; X ]1
                            &lt;o (meta_of_poly polyA at A)||1 A' X )
                            ~~ ( [1 &#946; A' ~&gt; (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)|0 X ]0
                                 &lt;o (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V)||1 A' X ) .
      ... == natural_metatransformation from (meta_of_poly polyA at A) to (meta_of_poly (polyV_relV o (poly_of_meta (meta_of_poly F at B))) at V) by &#946; at A' at X    **)</span>
  <span class="keyword">Import</span> METATRANSFORMATION.Ex_Notations. <span class="comment-delimiter">(*</span><span class="comment">BUG , not working as expected</span><span class="comment-delimiter">*)</span>
  <span class="keyword">Section</span> <span class="function-name">Context3</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : category log} {<span class="variable-name">catB</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : functorToCat (form_of_functor catA) catB).
    <span class="keyword">Variables</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB funF) (<span class="variable-name">A</span> : obB catA).
    <span class="keyword">Variable</span> ( <span class="variable-name">image&#946;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA catA, V(0 ((<span class="constant">@</span>metafunctor_of_functor_at _ catA A).-F|0 X)%meta |-
                                          ((<span class="constant">@</span>metafunctor_of_functor_at _ (<span class="constant">@</span>functorToCat_of_metafunctor _ _ (<span class="constant">@</span>metafunctor_of_functor_at _ funF B)) V).-F|0 X)%meta )0 ).
    <span class="keyword">Let</span> <span class="function-name">image&#946;_as_data</span> := <span class="constant">@</span>Data log (<span class="constant">@</span>form_of_functor _ catA) (<span class="constant">@</span>metafunctor_of_functor_at _ catA A) (<span class="constant">@</span>metafunctor_of_functor_at _ (<span class="constant">@</span>functorToCat_of_metafunctor _ _ (<span class="constant">@</span>metafunctor_of_functor_at _ funF B)) V) image&#946;
                          : <span class="constant">@</span>data log (<span class="constant">@</span>form_of catA) (meta_of catA A) (meta_of (meta_of funF B) V).
    
    <span class="keyword">Check</span> eq_refl : ( <span class="constant">@</span>natural = ( <span class="type">fun</span> (<span class="variable-name">log</span> : logic) (<span class="variable-name">dat_</span> : FUNCTOR.data) (<span class="variable-name">func</span> : FUNCTOR.class dat_)
                                     (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB func) (<span class="variable-name">A</span> : obA func)
                                     (<span class="variable-name">&#946;</span> : <span class="type">forall</span> <span class="variable-name">X</span> : obA func, V(0 func.-A[0 A ~&gt; X ]0 |- [0 V ~&gt; func.-F[0 B ~&gt; X ]0 ]0 )0) =&gt; <span class="type">forall</span> <span class="variable-name">Y X</span> : obA func,
                                                                                                                           ( [0 func.-A[0 A ~&gt; Y ]0 ~&gt; &#946; X ]1 &lt;o (func.-A[0 A ~&gt; - ]1) Y X
                                                                                                                             : V(0 func.-A[0 Y ~&gt; X ]0  |- [0 func.-A[0 A ~&gt; Y ]0 ~&gt; [0 V ~&gt; func.-F[0 B ~&gt; X ]0 ]0 ]0 )0 )
                                                                                                                             ~~ [1 &#946; Y ~&gt; [0 V ~&gt; func.-F[0 B ~&gt; X ]0 ]0 ]0 &lt;o V[0 V ~&gt; - ]1 _ _ &lt;o (func.-F[0 B ~&gt; - ]1) Y X ) ).
    <span class="keyword">Eval</span> <span class="proof-tactics-name">unfold</span> natural <span class="type">in</span> <span class="constant">@</span>natural log funF funF V B A image&#946;.

    <span class="keyword">Definition</span> <span class="function-name">typeof_meta&#946;_morphism_of_image&#946;</span> := <span class="type">forall</span> <span class="variable-name">A0 A'</span> : <span class="constant">@</span>obA log (form_of catA),
                                                    [0 (meta_of catA A).-F|0 A0 ~&gt; image&#946;_as_data.-&#946;||0 A' ]1 &lt;o
                                                                                                                (meta_of catA A) .-F||1 ~~
                                                                                                                [1 image&#946;_as_data.-&#946;||0 A0 ~&gt; (meta_of (meta_of funF B) V).-F|0 A' ]0 &lt;o
                                                                                                                                                                                        (meta_of (meta_of funF B) V) .-F||1 .
    <span class="keyword">Check</span> (<span class="constant">@</span>meta&#946;_morphism log (<span class="constant">@</span>form_of catA) (meta_of catA A) (meta_of (meta_of funF B) V) image&#946;_as_data _) : typeof_meta&#946;_morphism_of_image&#946; .

    <span class="keyword">Lemma</span> <span class="function-name">soundness_natural_is_meta_polymorphism</span> :  <span class="constant">@</span>natural log funF funF V B A image&#946; -&gt; typeof_meta&#946;_morphism_of_image&#946; .
      <span class="proof-tactics-name">unfold</span> natural. <span class="proof-tactics-name">unfold</span> typeof_meta&#946;_morphism_of_image&#946;.
      <span class="proof-tactics-name">intros</span> H_natural Y X. 
      <span class="proof-tacticals-name">do</span> 2 <span class="proof-tactics-name">rewrite</span> meta_of_polyF_at_identitary_rel_polyF_identitary.
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> polyF_identitary_rel_polyF_unitB_metaFunc |]. 
      <span class="comment-delimiter">(*</span><span class="comment">FASTER eapply TransV; [eapply CongCom; [eapply ReflV|]; eapply (</span><span class="constant"><span class="comment">@</span></span><span class="comment">polyF_identitary_rel_polyF_unitB_metaFunc log _ _ (meta_of funF B) V Y X) |]. </span><span class="comment-delimiter">*)</span>
      <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, poly_of_metaF_unitV_metaF_IdenV  |].
      <span class="proof-tactics-name">rewrite</span> meta_of_polyF_at_identitary_rel_polyF_identitary.
      <span class="proof-tactics-name">eapply</span> H_natural.
    <span class="keyword">Qed</span>.

    <span class="keyword">Lemma</span> <span class="function-name">soundness_meta_polymorphism_is_natural</span> :  typeof_meta&#946;_morphism_of_image&#946; -&gt; <span class="constant">@</span>natural log funF funF V B A image&#946; .
      <span class="proof-tactics-name">unfold</span> natural. <span class="proof-tactics-name">unfold</span> typeof_meta&#946;_morphism_of_image&#946;.
      <span class="proof-tactics-name">intros</span> H_poly_morphism Y X. 
      <span class="proof-tactics-name">specialize</span> H_poly_morphism <span class="type">with</span>  (A0 := Y) (A' := X).
      <span class="proof-tacticals-name">do</span> 2 <span class="proof-tactics-name">rewrite</span> meta_of_polyF_at_identitary_rel_polyF_identitary <span class="type">in</span> H_poly_morphism.
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, polyF_identitary_rel_polyF_unitB_metaFunc ].
      <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_poly_morphism; [|<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> poly_of_metaF_unitV_metaF_IdenV].
      <span class="proof-tactics-name">rewrite</span> meta_of_polyF_at_identitary_rel_polyF_identitary <span class="type">in</span> H_poly_morphism.
      <span class="proof-tactics-name">eapply</span> H_poly_morphism.
    <span class="keyword">Qed</span>.
  <span class="keyword">End</span>  <span class="function-name">Context3</span>.

<span class="keyword">End</span> <span class="function-name">METATRANSFORMATION</span>.


<span class="doc">(** ____ ADDENDUM ; TODO: TO BE RESOLVED LATER ____ **)</span>
<span class="keyword">Module</span> <span class="function-name">FUNCOMP</span>.
  <span class="keyword">Import</span> FUNCTOR.
  <span class="keyword">Import</span> FUNCTORTOCAT.
  <span class="keyword">Import</span> FUNCTOR.Ex_Notations4.
  <span class="keyword">Set Implicit Arguments</span>.
  <span class="keyword">Unset Strict Implicit</span>.

  <span class="doc">(** possible but yoneda does not require polymorphism in B ,
  also memo that if B is category then presence of polyB_inputUnitB  *)</span>
  <span class="keyword">Hypothesis</span> <span class="variable-name">polyF_morphism_codomain</span> : <span class="type">forall</span> (<span class="variable-name">log</span> : logic) (<span class="variable-name">dat</span> : <span class="constant">@</span>data log) (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obB dat),
                                       <span class="type">forall</span> (<span class="variable-name">A</span> : obA dat) (<span class="variable-name">W</span> : obV log) (<span class="variable-name">B'</span> : obB dat) (<span class="variable-name">b</span> : V(0 W |- B[0 B' ~&gt; B]0 )0),
                                       <span class="type">forall</span> (<span class="variable-name">f</span> : V(0 V |-F[0 B ~&gt; A ]0 )0) (<span class="variable-name">X</span> : obA dat),
                                         <span class="comment-delimiter">(*</span><span class="comment"> use ( B[1 g ~&gt; F|0 A ]0 &lt;o f  ) because no polyB_arrow is assumed </span><span class="comment-delimiter">*)</span>
                                         F[1 Des( B[1 b ~&gt; F|0 A ]0 &lt;o f ) ~&gt; X]0
                                          ~~ ( DesIn( [0 V ~&gt; B[1 b ~&gt; F|0 X ]0 ]1 &lt;o F[1 f ~&gt; X ]0 )
                                               : V(0 A[0 A ~&gt; X ]0 |- [0 (0 V &amp; W )0 ~&gt; F[0 B' ~&gt; X ]0 ]0 )0 ) .

  <span class="doc">(** this lemma uses the hypothesis polyF_morphism_codomain polymorphism in B together with that B is category.
     alternative is to assume this lemma as axiom **)</span>
  <span class="keyword">Lemma</span> <span class="function-name">polyF_identitary_rel_polyF_unitB_ABORT</span>:
    <span class="type">forall</span> (<span class="variable-name">log</span> : logic) (<span class="variable-name">catA</span> : form log) (<span class="variable-name">catB</span> : category log)
      (<span class="variable-name">funF</span> : functorToCat catA catB) (<span class="variable-name">B</span> : obB catB) (<span class="variable-name">A X</span> : obA catA),
      (catB.-F[0 B ~&gt; - ]1) funF.-F|0 A funF.-F|0 X &lt;o F|1 A X ~~ (funF.-F[0 B ~&gt; - ]1) A X .
  <span class="keyword">Proof</span>.
    <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">eapply</span> SymV. <span class="proof-tactics-name">unfold</span> polyF_unitB.
    <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> DesIdenObR_output|].
    <span class="proof-tactics-name">generalize</span> (<span class="constant">@</span>polyF_morphism_codomain  log funF _ (funF.-F|0 A) _ _ B 1 ((catB).-uA) X ); <span class="proof-tactics-name">intros</span> H_polyF_morphism_codomain.

    <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_polyF_morphism_codomain;
      [|<span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDes; <span class="proof-tactics-name">eapply</span> ConsIdenObL_DesIdenObL ].
    <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_polyF_morphism_codomain;
      [|<span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDes, CongConsIdenObL; <span class="proof-tactics-name">eapply</span> SymV, (<span class="constant">@</span>polyF_inputUnitA _ _ catB)  ].
    <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_polyF_morphism_codomain;
      [|<span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, Cat1LeftV].
    <span class="proof-tactics-name">eapply</span> SymV, TransV, SymV <span class="type">in</span> H_polyF_morphism_codomain;
      [|<span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.polyF_arrow].

    <span class="proof-tactics-name">eapply</span> CongConsIn <span class="type">in</span> H_polyF_morphism_codomain.
    <span class="proof-tactics-name">eapply</span> TransV <span class="type">in</span> H_polyF_morphism_codomain; [|<span class="proof-tactics-name">eapply</span> ConsIn_DesIn].

    <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObR, H_polyF_morphism_codomain |].
    <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObR, SymV, ConsIn_Input |].
    <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, DesIdenObR_Input |].
    <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> Cat1LeftV ].
    <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV].
    <span class="proof-tactics-name">eapply</span> DesIdenObRConsIdenObL.
  <span class="keyword">Qed</span>.
  
  <span class="keyword">Section</span> <span class="function-name">Context</span>.
    Context {<span class="variable-name">log</span> : logic} (<span class="variable-name">catA</span> : form log) (<span class="variable-name">catB</span> : category log) (<span class="variable-name">catC</span> : category log).
    <span class="keyword">Definition</span> <span class="function-name">data</span> := prod (FUNCTORTOCAT.data catA catB) (FUNCTORTOCAT.data (form_of_functor catB) catC).
    <span class="keyword">Variable</span> <span class="variable-name">data_funF_data_funF'</span> : data.

    <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F</span> :
      <span class="type">forall</span> (<span class="variable-name">V</span> : obV log) (<span class="variable-name">B</span> : obA catB) (<span class="variable-name">A</span> : obA catA),
      <span class="type">forall</span> (<span class="variable-name">b</span> : V(0 V |- catB.-A[0 B ~&gt; (data_funF_data_funF'.(fst)).-F|0 A ]0 )0),
      <span class="type">forall</span> (<span class="variable-name">W</span> : obV log) (<span class="variable-name">C</span> : obA catC),
      <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- catC.-A[0 C ~&gt; (data_funF_data_funF'.(snd)).-F|0 B]0 )0),
      <span class="type">forall</span> <span class="variable-name">X</span> : obA catA, V(0 A[0 A ~&gt; X ]0  |- [0 V ~&gt; [0 W ~&gt; catC.-A[0 C ~&gt; (data_funF_data_funF'.(snd)).-F|0 (data_funF_data_funF'.(fst)).-F|0 X ]0 ]0 ]0 )0.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">eapply</span> <span class="constant">@</span>polyV_relT_identitary <span class="comment-delimiter">(*</span><span class="comment"> _ &lt;o _ </span><span class="comment-delimiter">*)</span>. <span class="proof-tactics-name">apply</span> consV01.
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>FUNCTOR.polyF log (data_funF_data_funF'.(snd)) _ _ _ c).
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>FUNCTOR.polyF log (data_funF_data_funF'.(fst)) _ _ _ b).
    <span class="keyword">Defined</span>.

    <span class="keyword">Definition</span> <span class="function-name">composition_F'_after_F_simple</span> :
      <span class="type">forall</span>  (<span class="variable-name">A</span> : obA catA),
      <span class="type">forall</span> (<span class="variable-name">W</span> : obV log) (<span class="variable-name">C</span> : obA catC),
      <span class="type">forall</span> (<span class="variable-name">c</span> : V(0 W |- catC.-A[0 C ~&gt; (data_funF_data_funF'.(snd)).-F|0 (data_funF_data_funF'.(fst)).-F|0 A ]0 )0),
      <span class="type">forall</span> <span class="variable-name">X</span> : obA catA, V(0 A[0 A ~&gt; X ]0  |- [0 W ~&gt; catC.-A[0 C ~&gt; (data_funF_data_funF'.(snd)).-F|0 (data_funF_data_funF'.(fst)).-F|0 X ]0 ]0 )0.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>.
      <span class="proof-tactics-name">apply</span> DesIdenObR.
      <span class="proof-tactics-name">eapply</span> composition_F'_after_F.
      <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>unitA _ catB).
      <span class="coq-solve-tactics">exact</span> c.
    <span class="keyword">Defined</span>.

    <span class="keyword">Definition</span> <span class="function-name">dataFunToCat_of_dataFunComp</span> : FUNCTORTOCAT.data catA catC :=
      {|
        FUNCTORTOCAT.polyF0 := <span class="type">fun</span> <span class="variable-name">A</span>  =&gt; (data_funF_data_funF'.(snd)).-F|0 (data_funF_data_funF'.(fst)).-F|0 A;
        FUNCTORTOCAT.polyF := <span class="type">fun</span> <span class="variable-name">V C A c X</span> =&gt;  composition_F'_after_F_simple c X |}.
  <span class="comment-delimiter">(*</span><span class="comment"> econstructor.
     Unshelve. 2: intro A; exact ((data_funF_data_funF'.(snd)).-F|0 (data_funF_data_funF'.(fst)).-F|0 A).
     intros; eapply composition_F'_after_F_simple. assumption.
   </span><span class="comment-delimiter">*)</span>
  <span class="keyword">End</span> <span class="function-name">Context</span>.
  <span class="keyword">Coercion</span> <span class="variable-name">dataFunToCat_of_dataFunComp</span> : data &gt;-&gt; FUNCTORTOCAT.data.

  <span class="keyword">Section</span> <span class="function-name">Context2</span>.    
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : form log} {<span class="variable-name">catB</span> : category log} {<span class="variable-name">catC</span> : category log}.

    <span class="keyword">Definition</span> <span class="function-name">class</span> (<span class="variable-name">data_funF_data_funF'</span> : data catA catB catC ) := prod (FUNCTORTOCAT.class  (data_funF_data_funF'.(fst))) (FUNCTORTOCAT.class (data_funF_data_funF'.(snd))).
    Existing <span class="keyword">Class</span> <span class="function-name">class</span>.
    
    <span class="keyword">Variable</span>  (<span class="variable-name">data_funF_data_funF'</span> : data catA catB catC ).
    <span class="keyword">Variable</span> (<span class="variable-name">class_funF_class_funF'</span> : class data_funF_data_funF').

    <span class="keyword">Definition</span> <span class="function-name">classFunToCat_of_classFunComp</span> : <span class="constant">@</span>FUNCTORTOCAT.class _ _ _ (dataFunToCat_of_dataFunComp data_funF_data_funF') .
      <span class="proof-tactics-name">destruct</span> data_funF_data_funF' <span class="type">as</span> [data_funF data_funF'].
      <span class="proof-tactics-name">destruct</span>  class_funF_class_funF' <span class="type">as</span> [class_funF   class_funF' ].
      <span class="proof-tactics-name">econstructor</span>. 
      <span class="company-coq-featuresXcode-folding-bullet">+</span> cbn.  <span class="proof-tactics-name">intros</span>.  <span class="proof-tactics-name">simpl</span> dataFunToCat_of_dataFunComp.  <span class="proof-tactics-name">simpl</span>. 
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_simple , composition_F'_after_F .
        cbn.  cbn -[dataFun_of_dataFuntoCat].
        <span class="proof-tactics-name">simpl</span> dataFunToCat_of_dataFunComp.
        
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> DesIdenObR_output|]. <span class="proof-tactics-name">eapply</span> CongDesIdenObR.
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> Cat2V |]. <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV ].
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> consV01_functorial  |].
        <span class="proof-tactics-name">eapply</span> CongConsV01.
        <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.polyF_arrow.

      <span class="company-coq-featuresXcode-folding-bullet">+</span> <span class="doc">(**   (f _v o&gt;F'F g _w) o&gt;F'F h :=
  (f _v o&gt;F' (1 o&gt;F g _w)) o&gt;F' (1 o&gt;F h)  ~~  (by polyF'_morphism)
  f _v o&gt;F' ( ( 1 o&gt;F g _w)  o&gt;B (1 o&gt;F h) )  ~~  by Hypothesis polyF_identitary_rel_polyF_unitB_ABORT
  f _v o&gt;F' ( (( 1 o&gt;F g _w)  o&gt;B 1) o&gt;F h )  ~~  by polyB_inputUnitB from that B is category
  f _v o&gt;F' (  ( 1 o&gt;F g _w) o&gt;F h )  ~~  (by polyF_morphism)
 f _v o&gt;F' (1 o&gt;F (g _w o&gt;A h )) =:
 f _v o&gt;F'F (g _w o&gt; h )    **)</span>
        
        <span class="proof-tactics-name">intros</span>. cbn. <span class="proof-tactics-name">simpl</span>.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_simple , composition_F'_after_F . cbn.
        <span class="proof-tactics-name">eapply</span> TransV; [|  <span class="proof-tactics-name">eapply</span> DesIdenObR_output ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDes; <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> DesIdenObR_output ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDes; <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cat2V ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.polyF_morphism ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> DesIn_Input ].
        <span class="proof-tactics-name">eapply</span> CongDesIn.

        <span class="comment-delimiter">(*</span><span class="comment"> RHS </span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsV01, SymV, DesIdenObR_output  |].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> Cat2V].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV];  <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>CongPolyA log catB catB), Cat1LeftV ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>polyF_arrow log catB catB) ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> Cat2V ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>polyF_identitary_rel_polyF_unitB_ABORT log catA catB (FunctorToCat class_funF) _ _ X  )]. cbn.
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, (<span class="constant">@</span>polyF_arrow log data_funF class_funF ) ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>CongPolyF log data_funF class_funF), SymV, Cat1LeftV ].
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> CongCom; [| <span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, consV01_functorial |].
        <span class="proof-tactics-name">eapply</span> TransV; [ <span class="proof-tactics-name">eapply</span> SymV, Cat2V |].
        <span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|].

        <span class="comment-delimiter">(*</span><span class="comment">final clean LHS</span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, SymV, DesIdenObR_Input  ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDesIdenObR, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF,  Cat1LeftV  ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDesIdenObR, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.polyF_arrow   ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDesIdenObR, Cat2V ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDesIdenObR, SymV, Cons_Des  ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDesIdenObR, CongCons, Cat1RightV  ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, CongDesIdenObR, SymV, Cons_Output ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF, DesIdenObR_output ].
        <span class="proof-tactics-name">eapply</span> TransV; [| <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.polyF_arrow ].

        <span class="comment-delimiter">(*</span><span class="comment">final clean RHS</span><span class="comment-delimiter">*)</span>
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsV01, CongDesIdenObR, SymV, Cat1LeftV  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> CongConsV01, SymV, DesIdenObR_Input  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, consV01_functorial  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, Cat2V  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> ConsIn_DesIn  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongConsIn, SymV, Cat1LeftV  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> SymV, ConsIn_Input  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> Cat2V  |].

        <span class="proof-tactics-name">eapply</span> TransV; [|<span class="proof-tactics-name">eapply</span> CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.polyF_morphism ].
        <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV].

        <span class="proof-tactics-name">eapply</span> DesIdenObRInCons.
        
      <span class="company-coq-featuresXcode-folding-bullet">+</span>  <span class="proof-tactics-name">intros</span>. cbn. <span class="proof-tactics-name">simpl</span>.
         <span class="proof-tactics-name">unfold</span> composition_F'_after_F_simple , composition_F'_after_F . cbn.
         <span class="proof-tactics-name">eapply</span> CongDesIdenObR. <span class="proof-tactics-name">eapply</span> CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]. <span class="proof-tactics-name">eapply</span> CongConsV01.
         <span class="proof-tactics-name">eapply</span> FUNCTORTOCAT.CongPolyF . <span class="coq-solve-tactics">assumption</span>.

      <span class="company-coq-featuresXcode-folding-bullet">+</span>   <span class="doc">(**  f o&gt;F'F unitA  := f o&gt;F' (unitB o&gt;F unitA)  ~~ (f o&gt;F' (unitB) ) ~~ f  **)</span>
        <span class="proof-tactics-name">intros</span>. cbn. <span class="proof-tactics-name">simpl</span>.
        <span class="proof-tactics-name">unfold</span> composition_F'_after_F_simple , composition_F'_after_F . cbn.
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObL, CongCom; [|<span class="proof-tactics-name">eapply</span> ReflV]; <span class="proof-tactics-name">eapply</span> SymV, DesIdenObR_output  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObL, SymV, Cat2V  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObL, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIdenObR_Input  |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObL, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> CongDesIdenObR |].
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> SymV, ConsIdenObL_DesIdenObL|].
        <span class="proof-tactics-name">eapply</span> CongConsIdenObL, (<span class="constant">@</span>FUNCTORTOCAT.polyF_inputUnitA _ _ _ _ class_funF).
        <span class="proof-tactics-name">eapply</span> TransV; [<span class="proof-tactics-name">eapply</span> CongDesIdenObL, CongCom; [<span class="proof-tactics-name">eapply</span> ReflV|]; <span class="proof-tactics-name">eapply</span> DesIdenObR_ConsIdenObL|] .
        <span class="proof-tactics-name">eapply</span> (<span class="constant">@</span>FUNCTORTOCAT.polyF_inputUnitA _ _ _ _ class_funF').
    <span class="keyword">Qed</span>.

  <span class="keyword">End</span> <span class="function-name">Context2</span>.
  <span class="keyword">Coercion</span> <span class="variable-name">classFunToCat_of_classFunComp</span> : class &gt;-&gt; FUNCTORTOCAT.class.
  
  <span class="keyword">Section</span> <span class="function-name">Context3</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : form log} {<span class="variable-name">catB</span> : category log} {<span class="variable-name">catC</span> : category log}.

    <span class="keyword">Structure</span> <span class="function-name">funComp</span> :=
      FunComp <span class="company-coq-featuresXcode-folding-bullet">{</span>
          data_of :&gt; data catA catB catC;
          class_of :&gt; class data_of; }.

    Global <span class="keyword">Existing Instance</span> <span class="function-name">class_of</span>.
    
    <span class="keyword">Coercion</span> funtorToCat_of_funComp (<span class="variable-name">funC</span> : funComp) : functorToCat catA catC :=
      {| FUNCTORTOCAT.data_of := dataFunToCat_of_dataFunComp funC;
         FUNCTORTOCAT.class_of := classFunToCat_of_classFunComp funC |}.

    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : FUNCTORTOCAT.functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funF'</span> : FUNCTORTOCAT.functorToCat (form_of_functor catB) catC ).

    <span class="keyword">Definition</span> <span class="function-name">funComp_of_seq_functorToCat</span> : funComp :=
      {| data_of := (FUNCTORTOCAT.data_of funF, FUNCTORTOCAT.data_of funF');
         class_of := (FUNCTORTOCAT.class_of funF, FUNCTORTOCAT.class_of funF') |}.
  <span class="keyword">End</span> <span class="function-name">Context3</span>.
  
  <span class="keyword">Notation</span> funCom funF funF' := (funtorToCat_of_funComp (funComp_of_seq_functorToCat funF funF')).

  <span class="keyword">Import</span> FUNCTORTOCAT.Ex_Notations6.
  <span class="keyword">Section</span> <span class="function-name">Context4</span>.
    Context {<span class="variable-name">log</span> : logic} {<span class="variable-name">catA</span> : form log} {<span class="variable-name">catB</span> : category log} {<span class="variable-name">catC</span> : category log}.
    <span class="keyword">Variable</span> (<span class="variable-name">funF</span> : FUNCTORTOCAT.functorToCat catA catB).
    <span class="keyword">Variable</span> (<span class="variable-name">funF'</span> : FUNCTORTOCAT.functorToCat (form_of_functor catB) catC ).

    <span class="doc">(** memo that may be simply the particular where funF' is catB **)</span>
    <span class="keyword">Lemma</span> <span class="function-name">composition_F'_after_F_identitary_polyF'_identitary_polyF_unitary</span> :    <span class="type">forall</span> (<span class="variable-name">C</span> : obA catC) (<span class="variable-name">A X</span> : obA catA),
                                                                                   (funF'.-F[0 C ~&gt; - ]1) funF.-F|0 A funF.-F|0 X &lt;o funF.-F|1 A X ~~ ((funCom funF funF').-F[0 C ~&gt; - ]1) A X.
    <span class="keyword">Proof</span>.
      <span class="proof-tactics-name">intros</span>. <span class="proof-tactics-name">apply</span> SymV, DesIdenObR_output.
    <span class="keyword">Qed</span>.
  <span class="keyword">End</span> <span class="function-name">Context4</span>.
<span class="keyword">End</span> <span class="function-name">FUNCOMP</span>.
</pre>
  </body>
</html>
